{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Guard","text":"<p><code>fastapi-guard</code> is a comprehensive security library for FastAPI applications, providing middleware to control IPs, log requests, and detect penetration attempts. It integrates seamlessly with FastAPI to offer robust protection against various security threats, ensuring your application remains secure and reliable.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_token_here\"),\n    enable_redis=False,\n    rate_limit=100,\n    auto_ban_threshold=5\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"#example-app","title":"Example App","text":"<p>Inside examples, you can find a simple example app that demonstrates how to use FastAPI Guard.</p>"},{"location":"#live-playground","title":"Live Playground","text":"<p>Try FastAPI Guard features directly in your browser:</p> <p>https://playground.fastapi-guard.com</p> <p>This interactive demo allows you to explore FastAPI Guard's capabilities without any setup.</p>"},{"location":"#docker-container","title":"Docker Container","text":"<p>You can also download the example app as a Docker container from GitHub Container Registry.</p> <pre><code># Pull the latest version\ndocker pull ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Or pull a specific version (matches library releases)\ndocker pull ghcr.io/rennf93/fastapi-guard-example:v4.1.0\n</code></pre>"},{"location":"#running-the-example-app","title":"Running the Example App","text":""},{"location":"#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example app is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>This will start both the FastAPI Guard example app and Redis service. The app will be available at http://0.0.0.0:8000.</p>"},{"location":"#using-docker-container-only","title":"Using Docker Container Only","text":"<p>Alternatively, you can run just the container:</p> <pre><code># Run with default settings\ndocker run -host 0.0.0.0 -p 8000:8000 ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Run with custom Redis connection\ndocker run -host 0.0.0.0 -p 8000:8000 \\\n -e REDIS_URL=redis://your-redis-host:your-redis-port \\\n -e REDIS_PREFIX=your-redis-prefix \\\n -e IPINFO_TOKEN=your-ipinfo-token \\\n ghcr.io/rennf93/fastapi-guard-example:latest\n</code></pre> <p>The example app includes endpoints to test various security features of FastAPI Guard. Access the Swagger documentation at http://0.0.0.0:8000/docs after running the container.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>IP Whitelisting and Blacklisting: Control access based on IP addresses.</li> <li>User Agent Filtering: Block requests from specific user agents.</li> <li>Rate Limiting: Limit the number of requests from a single IP.</li> <li>Automatic IP Banning: Automatically ban IPs after a certain number of suspicious requests.</li> <li>Penetration Attempt Detection: Detect and log potential penetration attempts.</li> <li>Custom Logging: Log security events to a custom file.</li> <li>CORS Configuration: Configure CORS settings for your FastAPI application.</li> <li>Cloud Provider IP Blocking: Block requests from cloud provider IPs (AWS, GCP, Azure).</li> <li>IP Geolocation: Use IPInfo.io API to determine the country of an IP address.</li> <li>Optimized Performance: Selective loading of external resources based on configuration.</li> <li>Flexible Storage: Choose between Redis-backed distributed state or in-memory storage.</li> <li>Automatic Fallback: Seamless operation with/without Redis connection.</li> <li>Secure Proxy Handling: Protection against X-Forwarded-For header injection attacks</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>First Steps</li> <li>IP Management</li> <li>Rate Limiting</li> <li>API Reference</li> <li>Redis Integration Guide</li> <li>Example App</li> </ul> <p>\ud83d\udcd6 Learn More in the Tutorial</p>"},{"location":"installation/","title":"Installation","text":"<p>Install <code>fastapi-guard</code> using pip:</p> <pre><code>pip install fastapi-guard\n</code></pre> <p>Note: Ensure you have Python 3.10 or higher installed.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before using <code>fastapi-guard</code>'s country filtering features, obtain an IPInfo token:</p> <ol> <li>Visit IPInfo's website to create a free account.</li> <li>After signing up, you'll receive an API token.</li> <li>The free tier includes:</li> <li>Up to 50,000 requests per month.</li> <li>Access to IP to Country database.</li> <li>Daily database updates.</li> <li>IPv4 &amp; IPv6 support.</li> </ol> <p>Note: The IPInfo token is only required when using the country filtering features (<code>blocked_countries</code>, <code>whitelist_countries</code> and/or <code>block_cloud_providers</code>).</p> <p>Usage Example:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country blocking\n    enable_redis=True,  # Enabled by default, disable to use in-memory storage\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"prod:security:\",\n    whitelist=[\"192.168.1.1\", \"2001:db8::1\"],\n    blacklist=[\"10.0.0.1\", \"2001:db8::2\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    blocked_user_agents=[\"curl\", \"wget\"],\n    auto_ban_threshold=5,\n    auto_ban_duration=86400,\n    custom_log_file=\"security.log\",\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre> <p>Note: When Redis is disabled: - Rate limiting and IP bans become instance-local - Cloud provider IP ranges refresh every hour - Penetration patterns reset on app restart</p>"},{"location":"installation/#secure-proxy-configuration","title":"Secure Proxy Configuration","text":"<p>If your application is behind a proxy or load balancer, configure trusted proxies:</p> <pre><code>config = SecurityConfig(\n    # Security configuration for proxies\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # Only trust specific IPs/ranges\n    trusted_proxy_depth=1,  # Default proxy depth\n    trust_x_forwarded_proto=True,  # Trust X-Forwarded-Proto from trusted proxies\n\n    # Other config options...\n)\n</code></pre> <p>This prevents IP spoofing attacks via X-Forwarded-For header manipulation.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#v410-2025-09-07","title":"v4.1.0 (2025-09-07)","text":""},{"location":"release-notes/#new-features-v410","title":"New Features (v4.1.0)","text":"<ul> <li>Enhanced Security Headers: Added 5 new default security headers following OWASP best practices:</li> <li><code>X-Permitted-Cross-Domain-Policies: none</code> - Restricts Adobe Flash cross-domain access</li> <li><code>X-Download-Options: noopen</code> - Prevents file download execution in Internet Explorer</li> <li><code>Cross-Origin-Embedder-Policy: require-corp</code> - Controls cross-origin resource embedding</li> <li><code>Cross-Origin-Opener-Policy: same-origin</code> - Controls cross-origin window interactions</li> <li><code>Cross-Origin-Resource-Policy: same-origin</code> - Controls cross-origin resource access</li> <li>Security Validation Framework: Comprehensive input validation for all header configurations</li> <li>Advanced CORS Validation: Runtime validation and logging for CORS misconfiguration attempts</li> <li>Security Event Logging: Enhanced logging for security violations and configuration warnings</li> </ul>"},{"location":"release-notes/#security-fixes-v410","title":"Security Fixes (v4.1.0)","text":"<ul> <li>Fixed header injection vulnerability in SecurityHeadersManager - preventing injection attacks via newlines and control characters</li> <li>Enhanced CORS security - wildcard origins (<code>*</code>) now properly blocked when credentials are enabled to prevent security bypass</li> <li>Implemented thread-safe singleton pattern with double-checked locking to prevent race conditions in multi-threaded environments</li> <li>Secure cache key generation using SHA256 hashing to prevent cache poisoning attacks</li> <li>Added CSP unsafe directive validation - warnings for <code>'unsafe-inline'</code> and <code>'unsafe-eval'</code> directives</li> <li>HSTS preload validation - ensures preload requirements (max_age \u2265 31536000, includeSubDomains) are met</li> <li>Input validation for all header values - sanitization of control characters and length limits (8192 bytes)</li> </ul>"},{"location":"release-notes/#improvements-v410","title":"Improvements (v4.1.0)","text":"<ul> <li>Performance: Optimized cache key generation using SHA256 with path normalization</li> <li>Reliability: Thread-safe singleton implementation prevents multiple instances in concurrent environments</li> <li>Security: All header values now validated against injection attacks, newlines, and excessive length</li> <li>Monitoring: Improved security event logging for better observability and debugging</li> <li>Documentation: Updated security headers documentation with new features and best practices</li> </ul>"},{"location":"release-notes/#v403-2025-08-09","title":"v4.0.3 (2025-08-09)","text":""},{"location":"release-notes/#bug-fixes-v403","title":"Bug Fixes (v4.0.3)","text":"<ul> <li>Logging Configuration Fix: Fixed <code>custom_log_file</code> configuration being ignored - file logging now works correctly</li> <li>Logging Behavior: File logging is now truly optional - only enabled when <code>custom_log_file</code> is explicitly set</li> <li>Namespace Consistency: All FastAPI Guard components now use consistent <code>fastapi_guard.*</code> logger namespace hierarchy</li> <li>Root logger: <code>fastapi_guard</code></li> <li>Handlers: <code>fastapi_guard.handlers.{component}</code></li> <li>Decorators: <code>fastapi_guard.decorators.{component}</code></li> <li>Detection Engine: <code>fastapi_guard.detection_engine</code></li> <li>Console Output: Console logging is now always enabled for visibility, regardless of file logging configuration</li> <li>Passive Mode Enhancement: Fixed passive mode to properly log without blocking for all security checks including rate limiting, suspicious patterns, and decorator violations</li> </ul>"},{"location":"release-notes/#improvements-v403","title":"Improvements (v4.0.3)","text":"<ul> <li>Logger Isolation: FastAPI Guard logs are now properly isolated from user application logs</li> <li>Test Compatibility: Logger propagation enabled for better test framework integration</li> <li>Documentation: Updated all logging documentation to reflect actual behavior</li> <li>Passive Mode Consistency: All security checks now properly respect passive mode - logging violations without blocking requests</li> <li>Enhanced Logging Context: Improved log messages with better context for passive mode operations, including trigger information for suspicious patterns</li> </ul>"},{"location":"release-notes/#v402-2025-08-07","title":"v4.0.2 (2025-08-07)","text":""},{"location":"release-notes/#new-features-v402","title":"New Features (v4.0.2)","text":"<ul> <li>Sus Patterns Handler Overhaul: Complete redesign of the suspicious patterns detection system with modular architecture</li> <li>Pattern Compiler: Safe regex execution with configurable timeouts to prevent ReDoS attacks</li> <li>Content Preprocessor: Intelligent content truncation that preserves attack signatures</li> <li>Semantic Analyzer: Heuristic-based detection using TF-IDF and n-gram analysis for obfuscated attacks</li> <li>Performance Monitor: Real-time tracking of pattern execution times and anomaly detection</li> <li>Enhanced Detection API: Rich detection results with threat scores, detailed threat information, and performance metrics</li> <li>Lazy Component Initialization: Detection components only load when explicitly configured</li> <li>Comprehensive Configuration: New <code>detection_*</code> configuration options for fine-tuning all components</li> </ul>"},{"location":"release-notes/#improvements-v402","title":"Improvements (v4.0.2)","text":"<ul> <li>Pattern Matching Performance: Timeout protection prevents slow patterns from blocking requests</li> <li>Detection Accuracy: Multi-layered approach combines regex patterns with semantic analysis</li> <li>Memory Efficiency: Configurable limits on content length and pattern tracking</li> <li>Observability: Detailed performance metrics and slow pattern identification</li> <li>Backward Compatibility: Legacy <code>detect_pattern_match</code> API maintained for smooth migration</li> <li>Agent Integration: Automatic telemetry for pattern detection events and performance metrics</li> </ul>"},{"location":"release-notes/#v302-2025-07-22","title":"v3.0.2 (2025-07-22)","text":""},{"location":"release-notes/#security-fixes-v302","title":"Security Fixes (v3.0.2)","text":"<ul> <li>IMPORTANT: Enhanced ReDoS prevention - Prevent regex bypass due to length limitations on pattern regex. (GHSA-rrf6-pxg8-684g)</li> <li>CVE ID: CVE-2025-54365</li> <li>Added timeout to avoid catastrophical backtracking and/or regex bypass by length limitation expression.</li> <li>Added new <code>regex_timeout</code> parameter to <code>SecurityConfig</code> to allow for custom timeout for regex pattern matching.</li> </ul>"},{"location":"release-notes/#v301-2025-07-07","title":"v3.0.1 (2025-07-07)","text":""},{"location":"release-notes/#security-fixes-v301","title":"Security Fixes (v3.0.1)","text":"<ul> <li>IMPORTANT: Prevented ReDoS (Regular Expression Denial of Service - CWE-1333) attacks by replacing unbounded regex quantifiers with bounded ones. (GHSA-j47q-rc62-w448)</li> <li>CVE ID: CVE-2025-53539</li> </ul>"},{"location":"release-notes/#v300-2025-06-21","title":"v3.0.0 (2025-06-21)","text":""},{"location":"release-notes/#new-features-v300","title":"New Features (v3.0.0)","text":"<ul> <li>Security Decorators: Added comprehensive route-level security decorator system</li> <li><code>SecurityDecorator</code> class combining all security capabilities</li> <li>Access control decorators for IP filtering, geographic restrictions, and cloud provider blocking</li> <li>Authentication decorators for HTTPS enforcement, auth requirements, and API key validation</li> <li>Rate limiting decorators with custom limits and geographic rate limiting</li> <li>Behavioral analysis decorators for usage monitoring, return pattern detection, and frequency analysis</li> <li>Content filtering decorators for content type validation, size limits, and user agent blocking</li> <li>Advanced decorators for time windows, suspicious detection, and honeypot detection</li> <li>Route-specific configuration that can override global middleware settings</li> <li>Seamless integration with existing SecurityMiddleware</li> <li>Behavior Manager: Added behavioral analysis and monitoring system</li> <li><code>BehaviorTracker</code> for tracking and analyzing user behavior patterns</li> <li><code>BehaviorRule</code> for defining behavioral analysis rules</li> <li>Support for endpoint usage tracking, return pattern analysis, and frequency detection</li> <li>Multiple pattern formats including JSON paths, regex, and status codes</li> <li>Automated actions (ban, alert, log, throttle) based on behavioral thresholds</li> <li>Redis integration for distributed behavioral tracking</li> </ul>"},{"location":"release-notes/#v213-2025-06-18","title":"v2.1.3 (2025-06-18)","text":""},{"location":"release-notes/#bug-fixes-v213","title":"Bug Fixes (v2.1.3)","text":"<ul> <li>Fixed IPv6 address support throughout the project - PR #51 - Issue #50</li> </ul>"},{"location":"release-notes/#v212-2025-05-26","title":"v2.1.2 (2025-05-26)","text":""},{"location":"release-notes/#improvements-v212","title":"Improvements (v2.1.2)","text":"<ul> <li>Switched from Poetry to uv for package management</li> </ul>"},{"location":"release-notes/#v211-2025-05-08","title":"v2.1.1 (2025-05-08)","text":""},{"location":"release-notes/#bug-fixes-v211","title":"Bug Fixes (v2.1.1)","text":"<ul> <li>Fixed <code>custom_response_modifier</code> implementation.</li> </ul>"},{"location":"release-notes/#v210-2025-05-08","title":"v2.1.0 (2025-05-08)","text":""},{"location":"release-notes/#improvements-v210","title":"Improvements (v2.1.0)","text":"<ul> <li>Rate Limiting: Replaced fixed window rate limiting with true sliding window algorithm</li> <li>Added atomic Redis Lua script for distributed rate limiting</li> <li>Improved timestamp tracking for more accurate request counting</li> <li>Fixed edge cases in rate limiting that could cause unexpected 429 errors</li> </ul>"},{"location":"release-notes/#v200-2025-05-05","title":"v2.0.0 (2025-05-05)","text":""},{"location":"release-notes/#security-fixes-v200","title":"Security Fixes (v2.0.0)","text":"<ul> <li>IMPORTANT: Fixed Remote Header Injection vulnerability via X-Forwarded-For manipulation (GHSA-77q8-qmj7-x7pp)</li> <li>CVE ID: CVE-2025-46814</li> <li>Added secure client IP extraction with trusted proxy validation</li> <li>Added new configuration parameters for proxy security:</li> <li><code>trusted_proxies</code>: List of trusted proxy IPs or CIDR ranges</li> <li><code>trusted_proxy_depth</code>: Configurable proxy chain depth</li> <li><code>trust_x_forwarded_proto</code>: Option to trust X-Forwarded-Proto header</li> </ul>"},{"location":"release-notes/#new-features-v200","title":"New Features (v2.0.0)","text":"<ul> <li>IPInfo is now completely optional, you can implement your own <code>GeoIPHandler</code></li> <li>Added protocol-based design for customizable geographical IP handling</li> <li>Introduced <code>GeoIPHandler</code> protocol allowing custom implementations</li> <li>Separated protocol definitions into dedicated modules</li> </ul>"},{"location":"release-notes/#improvements-v200","title":"Improvements (v2.0.0)","text":"<ul> <li>Deprecated <code>ipinfo_token</code> and <code>ipinfo_db_path</code> in favor of <code>geo_ip_handler</code></li> <li>Improved type safety and code readability</li> <li>Added runtime type checking for custom GeoIP handlers</li> </ul>"},{"location":"release-notes/#v150-2025-05-01","title":"v1.5.0 (2025-05-01)","text":""},{"location":"release-notes/#improvements-v150","title":"Improvements (v1.5.0)","text":"<ul> <li>IpInfo token is now only required when using country filtering or cloud blocking</li> <li>Performance: Selective loading of IP geolocation database and cloud IP ranges</li> <li>Only download/process IP geolocation data when country filtering is configured</li> <li>Only fetch cloud provider IP ranges when cloud blocking is enabled</li> <li>Reduced startup time and memory usage when not using all security features</li> </ul>"},{"location":"release-notes/#v140-2025-04-30","title":"v1.4.0 (2025-04-30)","text":""},{"location":"release-notes/#new-features-v140","title":"New Features (v1.4.0)","text":"<ul> <li>Added configurable logging levels for normal and suspicious requests</li> <li>Enhanced log_activity function to support all logging levels</li> <li>Added ability to completely disable request logging</li> </ul>"},{"location":"release-notes/#improvements-v140","title":"Improvements (v1.4.0)","text":"<ul> <li>Improved performance by allowing complete disabling of normal request logging</li> <li>Better log level control for different environments (dev/prod)</li> </ul>"},{"location":"release-notes/#v132-2025-04-27","title":"v1.3.2 (2025-04-27)","text":""},{"location":"release-notes/#new-features-v132","title":"New Features (v1.3.2)","text":"<ul> <li>Created an interactive FastAPI Guard Playground</li> <li>Added <code>passive_mode</code> option to log suspicious activity without blocking requests</li> <li>Enhanced <code>detect_penetration_attempt</code> function to return trigger information</li> </ul>"},{"location":"release-notes/#v122-2025-04-07","title":"v1.2.2 (2025-04-07)","text":""},{"location":"release-notes/#improvements-v122","title":"Improvements (v1.2.2)","text":"<ul> <li>Added an empty <code>py.typed</code></li> <li>Fixed the <code>package_data</code> configuration in <code>setup.py</code></li> <li>Added <code>mypy</code> configuration to <code>pyproject.toml</code></li> <li>Added <code>MANIFEST.in</code></li> </ul>"},{"location":"release-notes/#v121-2025-04-05","title":"v1.2.1 (2025-04-05)","text":""},{"location":"release-notes/#new-features-v121","title":"New Features (v1.2.1)","text":"<ul> <li>Added new pattern management methods to <code>SusPatternsManager</code>:</li> <li><code>get_default_patterns()</code> and <code>get_custom_patterns()</code> for separate pattern access</li> <li><code>get_default_compiled_patterns()</code> and <code>get_custom_compiled_patterns()</code> for separate compiled pattern access</li> <li>Enhanced <code>remove_pattern()</code> method to return success/failure status</li> </ul>"},{"location":"release-notes/#improvements-v121","title":"Improvements (v1.2.1)","text":"<ul> <li>Fixed issue with default pattern removal in <code>SusPatternsManager</code></li> <li>Improved pattern separation between default and custom patterns</li> </ul>"},{"location":"release-notes/#v120-2025-04-04","title":"v1.2.0 (2025-04-04)","text":""},{"location":"release-notes/#new-features-v120","title":"New Features (v1.2.0)","text":"<ul> <li>Added dedicated <code>RateLimitManager</code> for improved rate limiting functionality</li> <li>TTLCache-based in-memory rate limiting still available</li> <li>Extended Redis support for distributed rate limiting</li> </ul>"},{"location":"release-notes/#improvements-v120","title":"Improvements (v1.2.0)","text":"<ul> <li>Fixed rate limiting logic to properly handle rate limiting</li> <li>Standardized Singleton pattern across all handlers</li> <li>Added new <code>keys</code>and <code>delete_pattern</code> methods to <code>RedisManager</code> for easy key/pattern retrieval/cleanup</li> </ul>"},{"location":"release-notes/#v110-2025-03-21","title":"v1.1.0 (2025-03-21)","text":""},{"location":"release-notes/#new-features-v110","title":"New Features (v1.1.0)","text":"<ul> <li>Added proper typing throughout the codebase</li> <li>Added custom Docker container for example app</li> <li>Added better Docker Compose support</li> </ul>"},{"location":"release-notes/#improvements-v110","title":"Improvements (v1.1.0)","text":"<ul> <li>Fixed multiple typing issues across test files</li> <li>Improved documentation for Docker container usage</li> <li>Enhanced serialization of Redis data</li> </ul>"},{"location":"release-notes/#v100-2025-02-19","title":"v1.0.0 (2025-02-19)","text":""},{"location":"release-notes/#new-features-v100","title":"New Features (v1.0.0)","text":"<ul> <li>Added Redis integration for distributed state management</li> </ul>"},{"location":"release-notes/#improvements-v100","title":"Improvements (v1.0.0)","text":"<ul> <li>Improved tests &amp; testing coverage (100% coverage)</li> </ul>"},{"location":"release-notes/#v040-2025-02-16","title":"v0.4.0 (2025-02-16)","text":""},{"location":"release-notes/#new-features-v040","title":"New Features (v0.4.0)","text":"<ul> <li>Added <code>db_path</code> parameter to <code>IPInfoManager</code> for custom database locations</li> </ul>"},{"location":"release-notes/#improvements-v040","title":"Improvements (v0.4.0)","text":"<ul> <li>Improved IPInfo database handling with local caching</li> </ul>"},{"location":"release-notes/#bug-fixes-v034","title":"Bug Fixes (v0.3.4)","text":"<ul> <li>Fixed Azure IP ranges download by adding proper User-Agent headers (#19)</li> <li>Fixed cloud provider validation logic to properly filter invalid entries</li> <li>Resolved test coverage gaps on all test files</li> </ul>"},{"location":"release-notes/#v034-2025-01-26","title":"v0.3.4 (2025-01-26)","text":""},{"location":"release-notes/#bug-fixes-v033","title":"Bug Fixes (v0.3.3)","text":"<ul> <li>Fixed issue with accepted <code>Headers</code> on <code>Swagger UI</code> access/requests.</li> </ul>"},{"location":"release-notes/#v033-2024-12-14","title":"v0.3.3 (2024-12-14)","text":""},{"location":"release-notes/#bug-fixes-v032","title":"Bug Fixes (v0.3.2)","text":"<ul> <li>Fixed package structure to properly include all required modules</li> <li>Resolved import issues with handlers package</li> <li>Improved package installation reliability</li> </ul>"},{"location":"api/behavior-manager/","title":"Behavior Manager","text":"<p>The Behavior Manager handles behavioral analysis and monitoring for FastAPI Guard, providing advanced detection capabilities for suspicious usage patterns and automated response actions.</p>"},{"location":"api/behavior-manager/#overview","title":"Overview","text":"<p>The Behavior Manager system consists of:</p> <ul> <li>BehaviorTracker: Main tracking and analysis engine</li> <li>BehaviorRule: Rule definition for behavioral analysis</li> <li>Integration: Seamless integration with decorators and middleware</li> </ul>"},{"location":"api/behavior-manager/#behaviortracker","title":"BehaviorTracker","text":"<p>The main class responsible for tracking and analyzing user behavior patterns.</p>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker","title":"<code>guard.handlers.behavior_handler.BehaviorTracker(config)</code>","text":"<p>Advanced behavioral analysis tracker for detecting suspicious patterns.</p> <p>This class can track: - Per-endpoint usage patterns - Return value frequency analysis - Time-based behavioral anomalies</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>def __init__(self, config: SecurityConfig):\n    self.config = config\n    self.logger = logging.getLogger(\"fastapi_guard.handlers.behavior\")\n    self.usage_counts: dict[str, dict[str, list[float]]] = defaultdict(\n        lambda: defaultdict(list)\n    )\n    self.return_patterns: dict[str, dict[str, list[float]]] = defaultdict(\n        lambda: defaultdict(list)\n    )\n    self.redis_handler: Any | None = None\n    self.agent_handler: Any | None = None\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.agent_handler","title":"<code>agent_handler = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.config","title":"<code>config = config</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.logger","title":"<code>logger = logging.getLogger('fastapi_guard.handlers.behavior')</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.redis_handler","title":"<code>redis_handler = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.return_patterns","title":"<code>return_patterns = defaultdict(lambda: defaultdict(list))</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.usage_counts","title":"<code>usage_counts = defaultdict(lambda: defaultdict(list))</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.apply_action","title":"<code>apply_action(rule, client_ip, endpoint_id, details)</code>  <code>async</code>","text":"<p>Apply the configured action when a rule is violated.</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>async def apply_action(\n    self, rule: BehaviorRule, client_ip: str, endpoint_id: str, details: str\n) -&gt; None:\n    \"\"\"Apply the configured action when a rule is violated.\"\"\"\n\n    # Send behavioral violation event to agent\n    if self.agent_handler:\n        await self._send_behavior_event(\n            event_type=\"behavioral_violation\",\n            ip_address=client_ip,\n            action_taken=rule.action\n            if not self.config.passive_mode\n            else \"logged_only\",\n            reason=f\"Behavioral rule violated: {details}\",\n            endpoint=endpoint_id,\n            rule_type=rule.rule_type,\n            threshold=rule.threshold,\n            window=rule.window,\n        )\n\n    # In passive mode, only log, don't take blocking actions\n    if self.config.passive_mode:\n        prefix = \"[PASSIVE MODE] \"\n        if rule.action == \"ban\":\n            self.logger.warning(\n                f\"{prefix}Would ban IP {client_ip} for behavioral \"\n                f\"violation: {details}\"\n            )\n        elif rule.action == \"log\":\n            self.logger.warning(f\"{prefix}Behavioral anomaly detected: {details}\")\n        elif rule.action == \"throttle\":\n            self.logger.warning(f\"{prefix}Would throttle IP {client_ip}: {details}\")\n        elif rule.action == \"alert\":\n            self.logger.critical(f\"{prefix}ALERT - Behavioral anomaly: {details}\")\n        # Don't execute custom actions in passive mode\n        return\n\n    # Active mode - take actual actions\n    if rule.custom_action:\n        await rule.custom_action(client_ip, endpoint_id, details)\n        return\n\n    if rule.action == \"ban\":\n        # Import here to avoid circular imports\n        from guard.handlers.ipban_handler import ip_ban_manager\n\n        await ip_ban_manager.ban_ip(\n            client_ip, 3600, \"behavioral_violation\"\n        )  # 1 hour ban\n        self.logger.warning(\n            f\"IP {client_ip} banned for behavioral violation: {details}\"\n        )\n\n    elif rule.action == \"log\":\n        self.logger.warning(f\"Behavioral anomaly detected: {details}\")\n\n    elif rule.action == \"throttle\":\n        # Could implement stricter rate limiting here\n        self.logger.warning(f\"Throttling IP {client_ip}: {details}\")\n\n    elif rule.action == \"alert\":\n        # Could send webhook/notification here\n        self.logger.critical(f\"ALERT - Behavioral anomaly: {details}\")\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.initialize_agent","title":"<code>initialize_agent(agent_handler)</code>  <code>async</code>","text":"<p>Initialize agent integration.</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>async def initialize_agent(self, agent_handler: Any) -&gt; None:\n    \"\"\"Initialize agent integration.\"\"\"\n    self.agent_handler = agent_handler\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.initialize_redis","title":"<code>initialize_redis(redis_handler)</code>  <code>async</code>","text":"<p>Initialize Redis connection for distributed tracking.</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>async def initialize_redis(self, redis_handler: Any) -&gt; None:\n    \"\"\"Initialize Redis connection for distributed tracking.\"\"\"\n    self.redis_handler = redis_handler\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.track_endpoint_usage","title":"<code>track_endpoint_usage(endpoint_id, client_ip, rule)</code>  <code>async</code>","text":"<p>Track endpoint usage and return True if threshold exceeded.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_id</code> <code>str</code> <p>Unique identifier for the endpoint</p> required <code>client_ip</code> <code>str</code> <p>Client IP address</p> required <code>rule</code> <code>BehaviorRule</code> <p>Behavior rule to apply</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if threshold exceeded, False otherwise</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>async def track_endpoint_usage(\n    self, endpoint_id: str, client_ip: str, rule: BehaviorRule\n) -&gt; bool:\n    \"\"\"\n    Track endpoint usage and return True if threshold exceeded.\n\n    Args:\n        endpoint_id: Unique identifier for the endpoint\n        client_ip: Client IP address\n        rule: Behavior rule to apply\n\n    Returns:\n        bool: True if threshold exceeded, False otherwise\n    \"\"\"\n    current_time = time.time()\n    window_start = current_time - rule.window\n\n    # Redis implementation\n    if self.redis_handler:\n        key = f\"behavior:usage:{endpoint_id}:{client_ip}\"\n\n        # Add current timestamp\n        await self.redis_handler.set_key(\n            \"behavior_usage\", f\"{key}:{current_time}\", \"1\", ttl=rule.window\n        )\n\n        # Count entries in window\n        pattern = f\"behavior_usage:{key}:*\"\n        keys = await self.redis_handler.keys(pattern)\n\n        # Filter keys within time window\n        valid_count = 0\n        for key_name in keys:\n            try:\n                timestamp = float(key_name.split(\":\")[-1])\n                if timestamp &gt;= window_start:\n                    valid_count += 1\n            except (ValueError, IndexError):\n                continue\n\n        return valid_count &gt; rule.threshold\n\n    # In-memory fallback\n    timestamps = self.usage_counts[endpoint_id][client_ip]\n\n    # Clean old timestamps\n    timestamps[:] = [ts for ts in timestamps if ts &gt;= window_start]\n\n    # Add current timestamp\n    timestamps.append(current_time)\n\n    return len(timestamps) &gt; rule.threshold\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorTracker.track_return_pattern","title":"<code>track_return_pattern(endpoint_id, client_ip, response, rule)</code>  <code>async</code>","text":"<p>Track return value patterns and detect anomalies.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_id</code> <code>str</code> <p>Unique identifier for the endpoint</p> required <code>client_ip</code> <code>str</code> <p>Client IP address</p> required <code>response</code> <code>Response</code> <p>FastAPI Response object</p> required <code>rule</code> <code>BehaviorRule</code> <p>Behavior rule with pattern to match</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if suspicious pattern detected, False otherwise</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>async def track_return_pattern(\n    self, endpoint_id: str, client_ip: str, response: Response, rule: BehaviorRule\n) -&gt; bool:\n    \"\"\"\n    Track return value patterns and detect anomalies.\n\n    Args:\n        endpoint_id: Unique identifier for the endpoint\n        client_ip: Client IP address\n        response: FastAPI Response object\n        rule: Behavior rule with pattern to match\n\n    Returns:\n        bool: True if suspicious pattern detected, False otherwise\n    \"\"\"\n    if not rule.pattern:\n        return False\n\n    current_time = time.time()\n    window_start = current_time - rule.window\n\n    # Extract response content for analysis\n    pattern_matched = await self._check_response_pattern(response, rule.pattern)\n\n    if not pattern_matched:\n        return False\n\n    # Redis implementation\n    if self.redis_handler:\n        key = f\"behavior:return:{endpoint_id}:{client_ip}:{rule.pattern}\"\n\n        # Add timestamp for pattern match\n        await self.redis_handler.set_key(\n            \"behavior_returns\", f\"{key}:{current_time}\", \"1\", ttl=rule.window\n        )\n\n        # Count pattern matches in window\n        pattern_key = f\"behavior_returns:{key}:*\"\n        keys = await self.redis_handler.keys(pattern_key)\n\n        # Filter keys within time window\n        valid_count = 0\n        for key_name in keys:\n            try:\n                timestamp = float(key_name.split(\":\")[-1])\n                if timestamp &gt;= window_start:\n                    valid_count += 1\n            except (ValueError, IndexError):\n                continue\n\n        return valid_count &gt; rule.threshold\n\n    # In-memory fallback\n    pattern_key = f\"{endpoint_id}:{rule.pattern}\"\n    timestamps = self.return_patterns[pattern_key][client_ip]\n\n    # Clean old timestamps\n    timestamps[:] = [ts for ts in timestamps if ts &gt;= window_start]\n\n    # Add current timestamp\n    timestamps.append(current_time)\n\n    return len(timestamps) &gt; rule.threshold\n</code></pre>"},{"location":"api/behavior-manager/#key-features","title":". Key Features","text":"<ul> <li>Endpoint Usage Tracking: Monitor how frequently IPs access specific endpoints</li> <li>Return Pattern Analysis: Detect when IPs receive specific response patterns too often</li> <li>Frequency Detection: Identify suspiciously high request frequencies</li> <li>Automated Actions: Apply bans, logs, alerts, or throttling based on rules</li> </ul>"},{"location":"api/behavior-manager/#example-usage","title":". Example Usage","text":"<pre><code>from guard.handlers.behavior_handler import BehaviorTracker, BehaviorRule\n\n# Create tracker\ntracker = BehaviorTracker(config)\n\n# Define rules\nusage_rule = BehaviorRule(\n    rule_type=\"usage\",\n    threshold=10,\n    window=3600,\n    action=\"ban\"\n)\n\nreturn_rule = BehaviorRule(\n    rule_type=\"return_pattern\",\n    threshold=3,\n    pattern=\"win\",\n    window=86400,\n    action=\"alert\"\n)\n\n# Track usage\nawait tracker.track_endpoint_usage(endpoint_id, client_ip, usage_rule)\n\n# Track return patterns\nawait tracker.track_return_pattern(endpoint_id, client_ip, response, return_rule)\n</code></pre>"},{"location":"api/behavior-manager/#behaviorrule","title":"BehaviorRule","text":"<p>Configuration class that defines behavioral analysis rules.</p>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule","title":"<code>guard.handlers.behavior_handler.BehaviorRule(rule_type, threshold, window=3600, pattern=None, action='log', custom_action=None)</code>","text":"<p>Defines a behavioral analysis rule.</p> Source code in <code>guard/handlers/behavior_handler.py</code> <pre><code>def __init__(\n    self,\n    rule_type: Literal[\"usage\", \"return_pattern\", \"frequency\"],\n    threshold: int,\n    window: int = 3600,  # 1 hour default\n    pattern: str | None = None,\n    action: Literal[\"ban\", \"log\", \"throttle\", \"alert\"] = \"log\",\n    custom_action: Callable | None = None,\n):\n    self.rule_type = rule_type\n    self.threshold = threshold\n    self.window = window\n    self.pattern = pattern\n    self.action = action\n    self.custom_action = custom_action\n</code></pre>"},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.action","title":"<code>action = action</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.custom_action","title":"<code>custom_action = custom_action</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.pattern","title":"<code>pattern = pattern</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.rule_type","title":"<code>rule_type = rule_type</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.threshold","title":"<code>threshold = threshold</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#guard.handlers.behavior_handler.BehaviorRule.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/behavior-manager/#rule-types","title":". Rule Types","text":"<ul> <li>usage: Monitor endpoint usage frequency</li> <li>return_pattern: Analyze response patterns</li> <li>frequency: Detect suspicious request frequencies</li> </ul>"},{"location":"api/behavior-manager/#pattern-formats","title":". Pattern Formats","text":"<p>For <code>return_pattern</code> rules, the following pattern formats are supported:</p> <ul> <li>Simple string: <code>\"win\"</code>, <code>\"success\"</code>, <code>\"rare_item\"</code></li> <li>JSON path: <code>\"json:result.status==win\"</code></li> <li>Regex: <code>\"regex:win|victory|success\"</code></li> <li>Status code: <code>\"status:200\"</code></li> </ul>"},{"location":"api/behavior-manager/#actions","title":". Actions","text":"<ul> <li>ban: Ban the IP address</li> <li>log: Log the incident</li> <li>alert: Send an alert notification</li> <li>throttle: Apply rate limiting</li> </ul>"},{"location":"api/behavior-manager/#example-rules","title":". Example Rules","text":"<pre><code># Usage monitoring\nusage_rule = BehaviorRule(\n    rule_type=\"usage\",\n    threshold=50,\n    window=3600,\n    action=\"ban\"\n)\n\n# Return pattern monitoring\nwin_rule = BehaviorRule(\n    rule_type=\"return_pattern\",\n    threshold=3,\n    pattern=\"win\",\n    window=86400,\n    action=\"ban\"\n)\n\n# Frequency detection\nfreq_rule = BehaviorRule(\n    rule_type=\"frequency\",\n    threshold=30,  # 30 requests\n    window=300,    # in 5 minutes\n    action=\"alert\"\n)\n</code></pre>"},{"location":"api/behavior-manager/#integration-with-decorators","title":"Integration with Decorators","text":"<p>The Behavior Manager integrates seamlessly with the decorator system:</p> <pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/rewards\")\n@guard_deco.usage_monitor(max_calls=10, window=3600, action=\"ban\")\n@guard_deco.return_monitor(\"rare_item\", max_occurrences=3, window=86400, action=\"alert\")\ndef rewards_endpoint():\n    return {\"reward\": \"rare_item\", \"value\": 1000}\n</code></pre>"},{"location":"api/behavior-manager/#redis-integration","title":"Redis Integration","text":"<p>The Behavior Manager supports Redis for distributed tracking:</p> <pre><code># Initialize with Redis\nawait tracker.initialize_redis(redis_handler)\n\n# All tracking operations will use Redis for storage\n# This enables behavior tracking across multiple instances\n</code></pre>"},{"location":"api/behavior-manager/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/behavior-manager/#custom-pattern-matching","title":". Custom Pattern Matching","text":"<pre><code># JSON path pattern\njson_rule = BehaviorRule(\n    rule_type=\"return_pattern\",\n    threshold=5,\n    pattern=\"json:result.reward.rarity==legendary\",\n    window=86400,\n    action=\"ban\"\n)\n\n# Regex pattern\nregex_rule = BehaviorRule(\n    rule_type=\"return_pattern\",\n    threshold=10,\n    pattern=\"regex:(win|victory|success)\",\n    window=3600,\n    action=\"alert\"\n)\n\n# Status code pattern\nstatus_rule = BehaviorRule(\n    rule_type=\"return_pattern\",\n    threshold=100,\n    pattern=\"status:200\",\n    window=3600,\n    action=\"log\"\n)\n</code></pre>"},{"location":"api/behavior-manager/#multiple-rule-analysis","title":". Multiple Rule Analysis","text":"<pre><code># Apply multiple rules to an endpoint\nrules = [\n    BehaviorRule(\"usage\", threshold=20, window=3600, action=\"ban\"),\n    BehaviorRule(\"return_pattern\", threshold=5, pattern=\"win\", window=86400, action=\"alert\"),\n    BehaviorRule(\"frequency\", threshold=60, window=300, action=\"throttle\")\n]\n\n@guard_deco.behavior_analysis(rules)\ndef complex_endpoint():\n    return {\"data\": \"complex\"}\n</code></pre>"},{"location":"api/behavior-manager/#best-practices","title":"Best Practices","text":""},{"location":"api/behavior-manager/#set-appropriate-thresholds","title":". Set Appropriate Thresholds","text":"<p>Match thresholds to expected legitimate usage:</p> <pre><code># High-value endpoint - strict limits\n@guard_deco.usage_monitor(max_calls=5, window=3600, action=\"ban\")\n\n# Regular endpoint - moderate limits\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"alert\")\n</code></pre>"},{"location":"api/behavior-manager/#use-graduated-responses","title":". Use Graduated Responses","text":"<p>Start with logging, then alerts, then bans:</p> <pre><code># First violation - log\nBehaviorRule(\"usage\", threshold=10, window=3600, action=\"log\")\n\n# Second violation - alert\nBehaviorRule(\"usage\", threshold=20, window=3600, action=\"alert\")\n\n# Third violation - ban\nBehaviorRule(\"usage\", threshold=30, window=3600, action=\"ban\")\n</code></pre>"},{"location":"api/behavior-manager/#monitor-return-patterns-carefully","title":". Monitor Return Patterns Carefully","text":"<p>Focus on patterns that indicate abuse:</p> <pre><code># Gaming/gambling endpoints\n@guard_deco.return_monitor(\"jackpot\", max_occurrences=2, window=86400, action=\"ban\")\n\n# Reward systems\n@guard_deco.return_monitor(\"rare_item\", max_occurrences=3, window=86400, action=\"alert\")\n\n# Success patterns\n@guard_deco.return_monitor(\"regex:success|win|victory\", max_occurrences=10, window=3600, action=\"log\")\n</code></pre>"},{"location":"api/behavior-manager/#error-handling","title":"Error Handling","text":"<p>The Behavior Manager handles errors gracefully:</p> <ul> <li>Redis Connection Issues: Falls back to in-memory tracking</li> <li>Pattern Matching Errors: Logs errors and continues processing</li> <li>Action Failures: Logs failures but doesn't interrupt request flow</li> </ul>"},{"location":"api/behavior-manager/#monitoring-and-debugging","title":"Monitoring and Debugging","text":"<p>Enable detailed logging for behavioral analysis:</p> <pre><code>config = SecurityConfig(\n    log_suspicious_level=\"DEBUG\",\n    log_request_level=\"INFO\"\n)\n\n# Logs will include:\n# - Behavioral rule violations\n# - Pattern matching results\n# - Action execution results\n</code></pre>"},{"location":"api/behavior-manager/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Redis Usage: Reduces memory usage and enables distributed tracking</li> <li>Pattern Complexity: Simple string patterns are fastest, regex patterns are slowest</li> <li>Rule Count: More rules per endpoint increase processing time</li> <li>Window Sizes: Larger windows require more memory for tracking</li> </ul>"},{"location":"api/behavior-manager/#see-also","title":"See Also","text":"<ul> <li>Behavioral Decorators Tutorial - Learn how to use behavioral decorators</li> <li>Security Decorators Overview - Complete decorator system overview</li> <li>Redis Integration - Redis setup and configuration</li> </ul>"},{"location":"api/cloud-manager/","title":"CloudManager","text":"<p>The <code>CloudManager</code> class manages detection of IP addresses from major cloud providers. It uses a singleton pattern to ensure only one instance exists throughout the application.</p>"},{"location":"api/cloud-manager/#class-definition","title":"Class Definition","text":"<pre><code>class CloudManager:\n    _instance = None\n    ip_ranges: dict[str, set[ipaddress.IPv4Network]]\n    redis_handler: Any = None\n    logger: logging.Logger\n\n    def __new__(cls: type[\"CloudManager\"]) -&gt; \"CloudManager\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.ip_ranges = {\n                \"AWS\": set(),\n                \"GCP\": set(),\n                \"Azure\": set(),\n            }\n            cls._instance.redis_handler = None\n            cls._instance.logger = logging.getLogger(\"fastapi_guard.handlers.cloud\")\n            # IP ranges are loaded on-demand, not at initialization\n        return cls._instance\n</code></pre>"},{"location":"api/cloud-manager/#redis-integration","title":"Redis Integration","text":"<p>When Redis is enabled, CloudManager automatically:</p> <ul> <li>Caches cloud IP ranges in Redis with 1-hour TTL</li> <li>Uses cached ranges if available</li> <li>Synchronizes ranges across instances</li> </ul>"},{"location":"api/cloud-manager/#methods","title":"Methods","text":""},{"location":"api/cloud-manager/#refresh","title":"refresh","text":"<pre><code>def refresh(self):\n    \"\"\"\n    Refresh IP ranges from all cloud providers.\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#is_cloud_ip","title":"is_cloud_ip","text":"<pre><code>def is_cloud_ip(\n    self,\n    ip: str,\n    providers: set[str]\n) -&gt; bool:\n    \"\"\"\n    Check if an IP belongs to specified cloud providers.\n\n    Args:\n        ip: IP address to check\n        providers: Set of provider names ('AWS', 'GCP', 'Azure')\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# The singleton instance is already created\n\n# Check if IP is from AWS\nis_aws = cloud_handler.is_cloud_ip(\"54.239.28.85\", {\"AWS\"})\n\n# Check multiple providers\nis_cloud = cloud_handler.is_cloud_ip(\n    \"35.186.224.25\",\n    {\"AWS\", \"GCP\", \"Azure\"}\n)\n\n# Refresh IP ranges manually if needed\ncloud_handler.refresh()  # Synchronous refresh\nawait cloud_handler.refresh_async()  # Asynchronous with Redis\n</code></pre>"},{"location":"api/decorators/","title":"Security Decorators","text":"<p>The decorators module provides route-level security controls that can be applied to individual FastAPI endpoints. These decorators offer fine-grained control over security policies on a per-route basis, complementing the global middleware security features.</p>"},{"location":"api/decorators/#overview","title":"Overview","text":"<p>Security decorators allow you to:</p> <ul> <li>Apply specific security rules to individual routes</li> <li>Override global security settings for specific endpoints</li> <li>Combine multiple security measures in a clean, readable way</li> <li>Implement behavioral analysis and monitoring per endpoint</li> </ul>"},{"location":"api/decorators/#main-decorator-class","title":"Main Decorator Class","text":""},{"location":"api/decorators/#securitydecorator","title":". SecurityDecorator","text":"<p>The main decorator class that combines all security capabilities. This is the primary class you'll use in your application.</p> <p>Example Usage:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig\nfrom guard.decorators import SecurityDecorator\n\napp = FastAPI()\nconfig = SecurityConfig()\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/sensitive\")\n@guard_deco.rate_limit(requests=5, window=300)\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])\n@guard_deco.block_countries([\"CN\", \"RU\"])\ndef sensitive_endpoint():\n    return {\"data\": \"sensitive\"}\n</code></pre>"},{"location":"api/decorators/#guard.decorators.SecurityDecorator","title":"<code>guard.decorators.SecurityDecorator(config)</code>","text":"<p>               Bases: <code>BaseSecurityDecorator</code>, <code>AccessControlMixin</code>, <code>RateLimitingMixin</code>, <code>BehavioralMixin</code>, <code>AuthenticationMixin</code>, <code>ContentFilteringMixin</code>, <code>AdvancedMixin</code></p> <p>Main security decorator class that combines all security decorator capabilities.</p> <p>This class uses multiple inheritance to combine all decorator mixins, providing a single interface for all route-level security features.</p> Example <p>config = SecurityConfig() guard = SecurityDecorator(config)</p> <p>@app.get(\"/api/sensitive\") @guard.rate_limit(requests=5, window=300) @guard.require_ip(whitelist=[\"10.0.0.0/8\"]) @guard.block_countries([\"CN\", \"RU\"]) def sensitive_endpoint():     return {\"data\": \"sensitive\"}</p> Source code in <code>guard/decorators/base.py</code> <pre><code>def __init__(self, config: SecurityConfig) -&gt; None:\n    self.config = config\n    self._route_configs: dict[str, RouteConfig] = {}\n    self.behavior_tracker = BehaviorTracker(config)\n    self.agent_handler: Any = None\n</code></pre>"},{"location":"api/decorators/#base-classes","title":"Base Classes","text":""},{"location":"api/decorators/#basesecuritydecorator","title":". BaseSecurityDecorator","text":"<p>Base class providing core decorator functionality and route configuration management.</p>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator","title":"<code>guard.decorators.base.BaseSecurityDecorator(config)</code>","text":"<p>Base class for all security decorators with common functionality.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>def __init__(self, config: SecurityConfig) -&gt; None:\n    self.config = config\n    self._route_configs: dict[str, RouteConfig] = {}\n    self.behavior_tracker = BehaviorTracker(config)\n    self.agent_handler: Any = None\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.agent_handler","title":"<code>agent_handler = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.behavior_tracker","title":"<code>behavior_tracker = BehaviorTracker(config)</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.config","title":"<code>config = config</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.get_route_config","title":"<code>get_route_config(route_id)</code>","text":"<p>Get security config for a specific route.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>def get_route_config(self, route_id: str) -&gt; RouteConfig | None:\n    \"\"\"Get security config for a specific route.\"\"\"\n    return self._route_configs.get(route_id)\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.initialize_agent","title":"<code>initialize_agent(agent_handler)</code>  <code>async</code>","text":"<p>Initialize agent integration for decorator-based security.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def initialize_agent(self, agent_handler: Any) -&gt; None:\n    \"\"\"Initialize agent integration for decorator-based security.\"\"\"\n    self.agent_handler = agent_handler\n    # Initialize behavior tracker with agent\n    await self.behavior_tracker.initialize_agent(agent_handler)\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.initialize_behavior_tracking","title":"<code>initialize_behavior_tracking(redis_handler=None)</code>  <code>async</code>","text":"<p>Initialize behavioral tracking with optional Redis backend.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def initialize_behavior_tracking(self, redis_handler: Any = None) -&gt; None:\n    \"\"\"Initialize behavioral tracking with optional Redis backend.\"\"\"\n    if redis_handler:\n        await self.behavior_tracker.initialize_redis(redis_handler)\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.send_access_denied_event","title":"<code>send_access_denied_event(request, reason, decorator_type, **metadata)</code>  <code>async</code>","text":"<p>Helper method for access denied events.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def send_access_denied_event(\n    self,\n    request: Request,\n    reason: str,\n    decorator_type: str,\n    **metadata: Any,\n) -&gt; None:\n    \"\"\"Helper method for access denied events.\"\"\"\n    await self.send_decorator_event(\n        event_type=\"access_denied\",\n        request=request,\n        action_taken=\"blocked\",\n        reason=reason,\n        decorator_type=decorator_type,\n        **metadata,\n    )\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.send_authentication_failed_event","title":"<code>send_authentication_failed_event(request, reason, auth_type, **metadata)</code>  <code>async</code>","text":"<p>Helper method for authentication failure events.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def send_authentication_failed_event(\n    self,\n    request: Request,\n    reason: str,\n    auth_type: str,\n    **metadata: Any,\n) -&gt; None:\n    \"\"\"Helper method for authentication failure events.\"\"\"\n    await self.send_decorator_event(\n        event_type=\"authentication_failed\",\n        request=request,\n        action_taken=\"blocked\",\n        reason=reason,\n        decorator_type=\"authentication\",\n        auth_type=auth_type,\n        **metadata,\n    )\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.send_decorator_event","title":"<code>send_decorator_event(event_type, request, action_taken, reason, decorator_type, **kwargs)</code>  <code>async</code>","text":"<p>Send decorator-specific security events to agent.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def send_decorator_event(\n    self,\n    event_type: str,\n    request: Request,\n    action_taken: str,\n    reason: str,\n    decorator_type: str,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Send decorator-specific security events to agent.\"\"\"\n    if not self.agent_handler:\n        return\n\n    try:\n        # Extract client IP using existing utility\n        from guard.utils import extract_client_ip\n\n        client_ip = await extract_client_ip(\n            request, self.config, self.agent_handler\n        )\n\n        from guard_agent import SecurityEvent\n\n        event = SecurityEvent(\n            timestamp=datetime.now(timezone.utc),\n            event_type=event_type,\n            ip_address=client_ip,\n            country=None,  # Will be enriched by geo handler if available\n            user_agent=request.headers.get(\"User-Agent\"),\n            action_taken=action_taken,\n            reason=reason,\n            endpoint=str(request.url.path),\n            method=request.method,\n            decorator_type=decorator_type,\n            metadata=kwargs,\n        )\n\n        await self.agent_handler.send_event(event)\n\n    except Exception as e:\n        # Don't let agent errors break decorator functionality\n        import logging\n\n        logging.getLogger(\"fastapi_guard.decorators.base\").error(\n            f\"Failed to send decorator event to agent: {e}\"\n        )\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.send_decorator_violation_event","title":"<code>send_decorator_violation_event(request, violation_type, reason, **metadata)</code>  <code>async</code>","text":"<p>Helper method for general decorator violations.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def send_decorator_violation_event(\n    self,\n    request: Request,\n    violation_type: str,\n    reason: str,\n    **metadata: Any,\n) -&gt; None:\n    \"\"\"Helper method for general decorator violations.\"\"\"\n    await self.send_decorator_event(\n        event_type=\"decorator_violation\",\n        request=request,\n        action_taken=\"blocked\",\n        reason=reason,\n        decorator_type=violation_type,\n        **metadata,\n    )\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.BaseSecurityDecorator.send_rate_limit_event","title":"<code>send_rate_limit_event(request, limit, window, **metadata)</code>  <code>async</code>","text":"<p>Helper method for rate limit events.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>async def send_rate_limit_event(\n    self,\n    request: Request,\n    limit: int,\n    window: int,\n    **metadata: Any,\n) -&gt; None:\n    \"\"\"Helper method for rate limit events.\"\"\"\n    await self.send_decorator_event(\n        event_type=\"rate_limited\",\n        request=request,\n        action_taken=\"blocked\",\n        reason=f\"Rate limit exceeded: {limit} requests per {window}s\",\n        decorator_type=\"rate_limiting\",\n        limit=limit,\n        window=window,\n        **metadata,\n    )\n</code></pre>"},{"location":"api/decorators/#routeconfig","title":". RouteConfig","text":"<p>Configuration class that stores security settings for individual routes.</p>"},{"location":"api/decorators/#guard.decorators.base.RouteConfig","title":"<code>guard.decorators.base.RouteConfig()</code>","text":"<p>Per-route security configuration that can override global settings.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.rate_limit: int | None = None\n    self.rate_limit_window: int | None = None\n    self.ip_whitelist: list[str] | None = None\n    self.ip_blacklist: list[str] | None = None\n    self.blocked_countries: list[str] | None = None\n    self.whitelist_countries: list[str] | None = None\n    self.bypassed_checks: set[str] = set()\n    self.require_https: bool = False\n    self.auth_required: str | None = None\n    self.custom_validators: list[Callable] = []\n    self.blocked_user_agents: list[str] = []\n    self.required_headers: dict[str, str] = {}\n    # Behavioral analysis fields\n    self.behavior_rules: list[BehaviorRule] = []\n    # Additional security fields\n    self.block_cloud_providers: set[str] = set()\n    self.max_request_size: int | None = None\n    self.allowed_content_types: list[str] | None = None\n    self.time_restrictions: dict[str, str] | None = None\n    self.enable_suspicious_detection: bool = True\n    self.require_referrer: list[str] | None = None\n    self.api_key_required: bool = False\n    self.session_limits: dict[str, int] | None = None\n</code></pre>"},{"location":"api/decorators/#guard.decorators.base.RouteConfig.allowed_content_types","title":"<code>allowed_content_types = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.api_key_required","title":"<code>api_key_required = False</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.auth_required","title":"<code>auth_required = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.behavior_rules","title":"<code>behavior_rules = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.block_cloud_providers","title":"<code>block_cloud_providers = set()</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.blocked_countries","title":"<code>blocked_countries = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.blocked_user_agents","title":"<code>blocked_user_agents = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.bypassed_checks","title":"<code>bypassed_checks = set()</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.custom_validators","title":"<code>custom_validators = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.enable_suspicious_detection","title":"<code>enable_suspicious_detection = True</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.ip_blacklist","title":"<code>ip_blacklist = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.ip_whitelist","title":"<code>ip_whitelist = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.max_request_size","title":"<code>max_request_size = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.rate_limit","title":"<code>rate_limit = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.rate_limit_window","title":"<code>rate_limit_window = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.require_https","title":"<code>require_https = False</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.require_referrer","title":"<code>require_referrer = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.required_headers","title":"<code>required_headers = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.session_limits","title":"<code>session_limits = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.time_restrictions","title":"<code>time_restrictions = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#guard.decorators.base.RouteConfig.whitelist_countries","title":"<code>whitelist_countries = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/decorators/#mixin-classes","title":"Mixin Classes","text":"<p>The decorator system uses mixins to organize different types of security features:</p>"},{"location":"api/decorators/#accesscontrolmixin","title":". AccessControlMixin","text":"<p>Provides IP-based and geographic access control decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.require_ip(whitelist=[], blacklist=[])</code> - IP address filtering</li> <li><code>@guard_deco.block_countries(countries=[])</code> - Block specific countries</li> <li><code>@guard_deco.allow_countries(countries=[])</code> - Allow only specific countries</li> <li><code>@guard_deco.block_clouds(providers=[])</code> - Block cloud provider IPs</li> <li><code>@guard_deco.bypass(checks=[])</code> - Bypass specific security checks</li> </ul>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin","title":"<code>guard.decorators.access_control.AccessControlMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for access control decorators.</p>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin.allow_countries","title":"<code>allow_countries(countries)</code>","text":"<p>Only allow access from specific countries.</p> Source code in <code>guard/decorators/access_control.py</code> <pre><code>def allow_countries(\n    self, countries: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Only allow access from specific countries.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.whitelist_countries = countries\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin.block_clouds","title":"<code>block_clouds(providers=None)</code>","text":"<p>Block requests from cloud providers (leverages existing cloud_handler).</p> <p>Parameters:</p> Name Type Description Default <code>providers</code> <code>list[str] | None</code> <p>List of cloud providers to block [\"AWS\", \"GCP\", \"Azure\"]       If None, blocks all supported providers</p> <code>None</code> Example <p>@guard_decorator.block_clouds([\"AWS\", \"GCP\"])  # Block AWS and GCP def sensitive_api():     return {\"data\": \"no clouds allowed\"}</p> Source code in <code>guard/decorators/access_control.py</code> <pre><code>def block_clouds(\n    self, providers: list[str] | None = None\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Block requests from cloud providers (leverages existing cloud_handler).\n\n    Args:\n        providers: List of cloud providers to block [\"AWS\", \"GCP\", \"Azure\"]\n                  If None, blocks all supported providers\n\n    Example:\n        @guard_decorator.block_clouds([\"AWS\", \"GCP\"])  # Block AWS and GCP\n        def sensitive_api():\n            return {\"data\": \"no clouds allowed\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        if providers is None:\n            route_config.block_cloud_providers = {\"AWS\", \"GCP\", \"Azure\"}\n        else:\n            route_config.block_cloud_providers = set(providers)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin.block_countries","title":"<code>block_countries(countries)</code>","text":"<p>Block access from specific countries.</p> Source code in <code>guard/decorators/access_control.py</code> <pre><code>def block_countries(\n    self, countries: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Block access from specific countries.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.blocked_countries = countries\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin.bypass","title":"<code>bypass(checks)</code>","text":"<p>Bypass specific security checks for this route.</p> Source code in <code>guard/decorators/access_control.py</code> <pre><code>def bypass(\n    self, checks: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Bypass specific security checks for this route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.bypassed_checks.update(checks)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.access_control.AccessControlMixin.require_ip","title":"<code>require_ip(whitelist=None, blacklist=None)</code>","text":"<p>Require specific IP addresses or ranges.</p> Source code in <code>guard/decorators/access_control.py</code> <pre><code>def require_ip(\n    self,\n    whitelist: list[str] | None = None,\n    blacklist: list[str] | None = None,\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Require specific IP addresses or ranges.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        if whitelist:\n            route_config.ip_whitelist = whitelist\n        if blacklist:\n            route_config.ip_blacklist = blacklist\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#authenticationmixin","title":". AuthenticationMixin","text":"<p>Provides authentication and authorization decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.require_https()</code> - Force HTTPS</li> <li><code>@guard_deco.require_auth(type=\"bearer\")</code> - Require authentication</li> <li><code>@guard_deco.api_key_auth(header_name=\"X-API-Key\")</code> - API key authentication</li> <li><code>@guard_deco.require_headers(headers={})</code> - Require specific headers</li> </ul>"},{"location":"api/decorators/#guard.decorators.authentication.AuthenticationMixin","title":"<code>guard.decorators.authentication.AuthenticationMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for authentication decorators.</p>"},{"location":"api/decorators/#guard.decorators.authentication.AuthenticationMixin.api_key_auth","title":"<code>api_key_auth(header_name='X-API-Key')</code>","text":"<p>Require API key authentication for this endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>header_name</code> <code>str</code> <p>Name of the header containing the API key</p> <code>'X-API-Key'</code> Example <p>@guard_decorator.api_key_auth(\"X-API-Key\") def protected_endpoint():     return {\"data\": \"api key required\"}</p> Source code in <code>guard/decorators/authentication.py</code> <pre><code>def api_key_auth(\n    self, header_name: str = \"X-API-Key\"\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Require API key authentication for this endpoint.\n\n    Args:\n        header_name: Name of the header containing the API key\n\n    Example:\n        @guard_decorator.api_key_auth(\"X-API-Key\")\n        def protected_endpoint():\n            return {\"data\": \"api key required\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.api_key_required = True\n        route_config.required_headers[header_name] = \"required\"\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.authentication.AuthenticationMixin.require_auth","title":"<code>require_auth(type='bearer')</code>","text":"<p>Require authentication for this route.</p> Source code in <code>guard/decorators/authentication.py</code> <pre><code>def require_auth(\n    self, type: str = \"bearer\"\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Require authentication for this route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.auth_required = type\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.authentication.AuthenticationMixin.require_headers","title":"<code>require_headers(headers)</code>","text":"<p>Require specific headers to be present.</p> Source code in <code>guard/decorators/authentication.py</code> <pre><code>def require_headers(\n    self, headers: dict[str, str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Require specific headers to be present.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.required_headers.update(headers)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.authentication.AuthenticationMixin.require_https","title":"<code>require_https()</code>","text":"<p>Force HTTPS for this specific route.</p> Source code in <code>guard/decorators/authentication.py</code> <pre><code>def require_https(self) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Force HTTPS for this specific route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.require_https = True\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#ratelimitingmixin","title":". RateLimitingMixin","text":"<p>Provides rate limiting decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.rate_limit(requests=10, window=60)</code> - Basic rate limiting</li> <li><code>@guard_deco.geo_rate_limit(limits={})</code> - Geographic rate limiting</li> </ul>"},{"location":"api/decorators/#guard.decorators.rate_limiting.RateLimitingMixin","title":"<code>guard.decorators.rate_limiting.RateLimitingMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for rate limiting decorators.</p>"},{"location":"api/decorators/#guard.decorators.rate_limiting.RateLimitingMixin.geo_rate_limit","title":"<code>geo_rate_limit(limits)</code>","text":"<p>Apply different rate limits based on country.</p> <p>Parameters:</p> Name Type Description Default <code>limits</code> <code>dict[str, tuple[int, int]]</code> <p>Dict mapping country codes to (requests, window) tuples</p> required Example <p>@guard_decorator.geo_rate_limit({     \"US\": (100, 3600),  # 100 requests/hour for US     \"CN\": (10, 3600),   # 10 requests/hour for China     \"*\": (50, 3600)     # 50 requests/hour for others }) def api_endpoint():     return {\"data\": \"geo-limited\"}</p> Source code in <code>guard/decorators/rate_limiting.py</code> <pre><code>def geo_rate_limit(\n    self, limits: dict[str, tuple[int, int]]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Apply different rate limits based on country.\n\n    Args:\n        limits: Dict mapping country codes to (requests, window) tuples\n\n    Example:\n        @guard_decorator.geo_rate_limit({\n            \"US\": (100, 3600),  # 100 requests/hour for US\n            \"CN\": (10, 3600),   # 10 requests/hour for China\n            \"*\": (50, 3600)     # 50 requests/hour for others\n        })\n        def api_endpoint():\n            return {\"data\": \"geo-limited\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        # TODO: This would need integration with existing geo IP handler\n        # For now, store the configuration\n        route_config = self._ensure_route_config(func)\n        route_config.required_headers[\"geo_rate_limits\"] = str(limits)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.rate_limiting.RateLimitingMixin.rate_limit","title":"<code>rate_limit(requests, window=60)</code>","text":"<p>Apply custom rate limiting to a specific route.</p> Source code in <code>guard/decorators/rate_limiting.py</code> <pre><code>def rate_limit(\n    self, requests: int, window: int = 60\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Apply custom rate limiting to a specific route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.rate_limit = requests\n        route_config.rate_limit_window = window\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#behavioralmixin","title":". BehavioralMixin","text":"<p>Provides behavioral analysis and monitoring decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.usage_monitor(max_calls, window, action)</code> - Monitor endpoint usage</li> <li><code>@guard_deco.return_monitor(pattern, max_occurrences, window, action)</code> - Monitor return patterns</li> <li><code>@guard_deco.behavior_analysis(rules=[])</code> - Apply multiple behavioral rules</li> <li><code>@guard_deco.suspicious_frequency(max_frequency, window, action)</code> - Detect suspicious frequency</li> </ul>"},{"location":"api/decorators/#guard.decorators.behavioral.BehavioralMixin","title":"<code>guard.decorators.behavioral.BehavioralMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for behavioral analysis decorators.</p>"},{"location":"api/decorators/#guard.decorators.behavioral.BehavioralMixin.behavior_analysis","title":"<code>behavior_analysis(rules)</code>","text":"<p>Apply multiple behavioral analysis rules to an endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>list[BehaviorRule]</code> <p>List of BehaviorRule objects defining analysis rules</p> required Example <p>rules = [     BehaviorRule(\"usage\", threshold=10, window=3600),     BehaviorRule(         \"return_pattern\",         threshold=3,         pattern=\"win\",         window=86400,     ) ] @guard_decorator.behavior_analysis(rules) def complex_endpoint():     return {\"result\": \"data\"}</p> Source code in <code>guard/decorators/behavioral.py</code> <pre><code>def behavior_analysis(\n    self, rules: list[BehaviorRule]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Apply multiple behavioral analysis rules to an endpoint.\n\n    Args:\n        rules: List of BehaviorRule objects defining analysis rules\n\n    Example:\n        rules = [\n            BehaviorRule(\"usage\", threshold=10, window=3600),\n            BehaviorRule(\n                \"return_pattern\",\n                threshold=3,\n                pattern=\"win\",\n                window=86400,\n            )\n        ]\n        @guard_decorator.behavior_analysis(rules)\n        def complex_endpoint():\n            return {\"result\": \"data\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.behavior_rules.extend(rules)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.behavioral.BehavioralMixin.return_monitor","title":"<code>return_monitor(pattern, max_occurrences, window=86400, action='ban')</code>","text":"<p>Monitor return values and detect if same IP gets specific results too often.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Pattern to match in response (supports various formats)</p> required <code>max_occurrences</code> <code>int</code> <p>Maximum times pattern can occur for same IP</p> required <code>window</code> <code>int</code> <p>Time window in seconds (default: 24 hours)</p> <code>86400</code> <code>action</code> <code>Literal['ban', 'log', 'throttle', 'alert']</code> <p>Action to take when threshold exceeded</p> <code>'ban'</code> Pattern formats <ul> <li>Simple string: \"win\", \"success\", \"rare_item\"</li> <li>JSON path: \"json:result.status==win\"</li> <li>Regex: \"regex:win|victory|success\"</li> <li>Status code: \"status:200\"</li> </ul> Example <p>@guard_decorator.return_monitor(     \"win\",     max_occurrences=3,     window=86400,     action=\"ban\", ) def lootbox_endpoint():     return {\"result\": {\"status\": \"win\", \"item\": \"rare_sword\"}}</p> Source code in <code>guard/decorators/behavioral.py</code> <pre><code>def return_monitor(\n    self,\n    pattern: str,\n    max_occurrences: int,\n    window: int = 86400,  # 24 hours default\n    action: Literal[\"ban\", \"log\", \"throttle\", \"alert\"] = \"ban\",\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Monitor return values and detect if same IP gets specific results too often.\n\n    Args:\n        pattern: Pattern to match in response (supports various formats)\n        max_occurrences: Maximum times pattern can occur for same IP\n        window: Time window in seconds (default: 24 hours)\n        action: Action to take when threshold exceeded\n\n    Pattern formats:\n        - Simple string: \"win\", \"success\", \"rare_item\"\n        - JSON path: \"json:result.status==win\"\n        - Regex: \"regex:win|victory|success\"\n        - Status code: \"status:200\"\n\n    Example:\n        @guard_decorator.return_monitor(\n            \"win\",\n            max_occurrences=3,\n            window=86400,\n            action=\"ban\",\n        )\n        def lootbox_endpoint():\n            return {\"result\": {\"status\": \"win\", \"item\": \"rare_sword\"}}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n\n        rule = BehaviorRule(\n            rule_type=\"return_pattern\",\n            threshold=max_occurrences,\n            window=window,\n            pattern=pattern,\n            action=action,\n        )\n        route_config.behavior_rules.append(rule)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.behavioral.BehavioralMixin.suspicious_frequency","title":"<code>suspicious_frequency(max_frequency, window=300, action='ban')</code>","text":"<p>Detect suspiciously high frequency of requests to specific endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>max_frequency</code> <code>float</code> <p>Maximum requests per second allowed</p> required <code>window</code> <code>int</code> <p>Time window to analyze</p> <code>300</code> <code>action</code> <code>Literal['ban', 'log', 'throttle', 'alert']</code> <p>Action to take when exceeded</p> <code>'ban'</code> Example <p>@guard_decorator.suspicious_frequency(     max_frequency=0.1,     window=300, )  # Max 1 request per 10 seconds def expensive_operation():     return {\"result\": \"computed\"}</p> Source code in <code>guard/decorators/behavioral.py</code> <pre><code>def suspicious_frequency(\n    self,\n    max_frequency: float,  # requests per second\n    window: int = 300,  # 5 minutes\n    action: Literal[\"ban\", \"log\", \"throttle\", \"alert\"] = \"ban\",\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Detect suspiciously high frequency of requests to specific endpoint.\n\n    Args:\n        max_frequency: Maximum requests per second allowed\n        window: Time window to analyze\n        action: Action to take when exceeded\n\n    Example:\n        @guard_decorator.suspicious_frequency(\n            max_frequency=0.1,\n            window=300,\n        )  # Max 1 request per 10 seconds\n        def expensive_operation():\n            return {\"result\": \"computed\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        max_calls = int(max_frequency * window)\n\n        rule = BehaviorRule(\n            rule_type=\"frequency\",\n            threshold=max_calls,\n            window=window,\n            action=action,\n        )\n        route_config.behavior_rules.append(rule)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.behavioral.BehavioralMixin.usage_monitor","title":"<code>usage_monitor(max_calls, window=3600, action='ban')</code>","text":"<p>Monitor endpoint usage per IP and take action if threshold exceeded.</p> <p>Parameters:</p> Name Type Description Default <code>max_calls</code> <code>int</code> <p>Maximum number of calls allowed from same IP</p> required <code>window</code> <code>int</code> <p>Time window in seconds (default: 1 hour)</p> <code>3600</code> <code>action</code> <code>Literal['ban', 'log', 'throttle', 'alert']</code> <p>Action to take (\"ban\", \"log\", \"throttle\", \"alert\")</p> <code>'ban'</code> Example <p>@guard_decorator.usage_monitor(     max_calls=8,     window=3600,     action=\"ban\", ) def sensitive_endpoint():     return {\"data\": \"sensitive\"}</p> Source code in <code>guard/decorators/behavioral.py</code> <pre><code>def usage_monitor(\n    self,\n    max_calls: int,\n    window: int = 3600,  # 1 hour default\n    action: Literal[\"ban\", \"log\", \"throttle\", \"alert\"] = \"ban\",\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Monitor endpoint usage per IP and take action if threshold exceeded.\n\n    Args:\n        max_calls: Maximum number of calls allowed from same IP\n        window: Time window in seconds (default: 1 hour)\n        action: Action to take (\"ban\", \"log\", \"throttle\", \"alert\")\n\n    Example:\n        @guard_decorator.usage_monitor(\n            max_calls=8,\n            window=3600,\n            action=\"ban\",\n        )\n        def sensitive_endpoint():\n            return {\"data\": \"sensitive\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n\n        rule = BehaviorRule(\n            rule_type=\"usage\", threshold=max_calls, window=window, action=action\n        )\n        route_config.behavior_rules.append(rule)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#contentfilteringmixin","title":". ContentFilteringMixin","text":"<p>Provides content and request filtering decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.block_user_agents(patterns=[])</code> - Block user agent patterns</li> <li><code>@guard_deco.content_type_filter(allowed_types=[])</code> - Filter content types</li> <li><code>@guard_deco.max_request_size(size_bytes)</code> - Limit request size</li> <li><code>@guard_deco.require_referrer(allowed_domains=[])</code> - Require specific referrers</li> <li><code>@guard_deco.custom_validation(validator)</code> - Add custom validation logic</li> </ul>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin","title":"<code>guard.decorators.content_filtering.ContentFilteringMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for content and request filtering decorators.</p>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin.block_user_agents","title":"<code>block_user_agents(patterns)</code>","text":"<p>Block specific user agent patterns for this route.</p> Source code in <code>guard/decorators/content_filtering.py</code> <pre><code>def block_user_agents(\n    self, patterns: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Block specific user agent patterns for this route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.blocked_user_agents.extend(patterns)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin.content_type_filter","title":"<code>content_type_filter(allowed_types)</code>","text":"<p>Restrict allowed content types for this endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>allowed_types</code> <code>list[str]</code> <p>List of allowed MIME types</p> required Example <p>@guard_decorator.content_type_filter([\"application/json\", \"text/plain\"]) def api_endpoint():     return {\"message\": \"json or text only\"}</p> Source code in <code>guard/decorators/content_filtering.py</code> <pre><code>def content_type_filter(\n    self, allowed_types: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Restrict allowed content types for this endpoint.\n\n    Args:\n        allowed_types: List of allowed MIME types\n\n    Example:\n        @guard_decorator.content_type_filter([\"application/json\", \"text/plain\"])\n        def api_endpoint():\n            return {\"message\": \"json or text only\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.allowed_content_types = allowed_types\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin.custom_validation","title":"<code>custom_validation(validator)</code>","text":"<p>Add custom validation logic to this route.</p> Source code in <code>guard/decorators/content_filtering.py</code> <pre><code>def custom_validation(\n    self,\n    validator: Callable[[Request], Awaitable[Response | None]],\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"Add custom validation logic to this route.\"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.custom_validators.append(validator)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin.max_request_size","title":"<code>max_request_size(size_bytes)</code>","text":"<p>Limit request body size for this endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>size_bytes</code> <code>int</code> <p>Maximum request size in bytes</p> required Example <p>@guard_decorator.max_request_size(1024 * 1024)  # 1MB limit def upload_endpoint():     return {\"status\": \"uploaded\"}</p> Source code in <code>guard/decorators/content_filtering.py</code> <pre><code>def max_request_size(\n    self, size_bytes: int\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Limit request body size for this endpoint.\n\n    Args:\n        size_bytes: Maximum request size in bytes\n\n    Example:\n        @guard_decorator.max_request_size(1024 * 1024)  # 1MB limit\n        def upload_endpoint():\n            return {\"status\": \"uploaded\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.max_request_size = size_bytes\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.content_filtering.ContentFilteringMixin.require_referrer","title":"<code>require_referrer(allowed_domains)</code>","text":"<p>Require requests to come from specific referrer domains.</p> <p>Parameters:</p> Name Type Description Default <code>allowed_domains</code> <code>list[str]</code> <p>List of allowed referrer domains</p> required Example <p>@guard_decorator.require_referrer([\"example.com\", \"app.example.com\"]) def api_endpoint():     return {\"message\": \"referrer validated\"}</p> Source code in <code>guard/decorators/content_filtering.py</code> <pre><code>def require_referrer(\n    self, allowed_domains: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Require requests to come from specific referrer domains.\n\n    Args:\n        allowed_domains: List of allowed referrer domains\n\n    Example:\n        @guard_decorator.require_referrer([\"example.com\", \"app.example.com\"])\n        def api_endpoint():\n            return {\"message\": \"referrer validated\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.require_referrer = allowed_domains\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#advancedmixin","title":". AdvancedMixin","text":"<p>Provides advanced detection and time-based decorators.</p> <p>Available Decorators:</p> <ul> <li><code>@guard_deco.time_window(start_time, end_time, timezone)</code> - Time-based access control</li> <li><code>@guard_deco.suspicious_detection(enabled=True)</code> - Toggle suspicious pattern detection</li> <li><code>@guard_deco.honeypot_detection(trap_fields=[])</code> - Detect bots using honeypot fields</li> </ul>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin","title":"<code>guard.decorators.advanced.AdvancedMixin</code>","text":"<p>               Bases: <code>BaseSecurityMixin</code></p> <p>Mixin for advanced detection decorators.</p>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin.honeypot_detection","title":"<code>honeypot_detection(trap_fields)</code>","text":"<p>Detect bots using honeypot fields that humans shouldn't fill.</p> <p>Parameters:</p> Name Type Description Default <code>trap_fields</code> <code>list[str]</code> <p>List of field names that should remain empty</p> required Example <p>@guard_decorator.honeypot_detection([\"bot_trap\", \"hidden_field\"]) def form_endpoint():     return {\"message\": \"human verified\"}</p> Source code in <code>guard/decorators/advanced.py</code> <pre><code>def honeypot_detection(\n    self, trap_fields: list[str]\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Detect bots using honeypot fields that humans shouldn't fill.\n\n    Args:\n        trap_fields: List of field names that should remain empty\n\n    Example:\n        @guard_decorator.honeypot_detection([\"bot_trap\", \"hidden_field\"])\n        def form_endpoint():\n            return {\"message\": \"human verified\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        async def honeypot_validator(request: Request) -&gt; Response | None:\n            try:\n                if request.method in [\"POST\", \"PUT\", \"PATCH\"]:\n                    # Check form data\n                    if \"application/x-www-form-urlencoded\" in request.headers.get(\n                        \"content-type\", \"\"\n                    ):\n                        form = await request.form()\n                        for field in trap_fields:\n                            if field in form and form[field]:\n                                return Response(\"Forbidden\", status_code=403)\n\n                    # Check JSON data\n                    elif \"application/json\" in request.headers.get(\n                        \"content-type\", \"\"\n                    ):\n                        try:\n                            json_data = await request.json()\n                            for field in trap_fields:\n                                if field in json_data and json_data[field]:\n                                    return Response(\"Forbidden\", status_code=403)\n                        except Exception:\n                            pass\n            except Exception:\n                pass\n            return None\n\n        route_config = self._ensure_route_config(func)\n        route_config.custom_validators.append(honeypot_validator)\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin.suspicious_detection","title":"<code>suspicious_detection(enabled=True)</code>","text":"<p>Enable/disable suspicious pattern detection (leverages sus_patterns_handler).</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable suspicious pattern detection</p> <code>True</code> Example Source code in <code>guard/decorators/advanced.py</code> <pre><code>def suspicious_detection(\n    self, enabled: bool = True\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Enable/disable suspicious pattern detection (leverages sus_patterns_handler).\n\n    Args:\n        enabled: Whether to enable suspicious pattern detection\n\n    Example:\n        # NOTE: Disable for this endpoint\n        @guard_decorator.suspicious_detection(enabled=False)\n        def upload_endpoint():\n            return {\"status\": \"upload safe\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.enable_suspicious_detection = enabled\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin.suspicious_detection--note-disable-for-this-endpoint","title":"NOTE: Disable for this endpoint","text":"<p>@guard_decorator.suspicious_detection(enabled=False) def upload_endpoint():     return {\"status\": \"upload safe\"}</p>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin.time_window","title":"<code>time_window(start_time, end_time, timezone='UTC')</code>","text":"<p>Restrict access to specific time windows.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>str</code> <p>Start time in HH:MM format</p> required <code>end_time</code> <code>str</code> <p>End time in HH:MM format</p> required <code>timezone</code> <code>str</code> <p>Timezone (default: UTC)</p> <code>'UTC'</code> Example Source code in <code>guard/decorators/advanced.py</code> <pre><code>def time_window(\n    self, start_time: str, end_time: str, timezone: str = \"UTC\"\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Restrict access to specific time windows.\n\n    Args:\n        start_time: Start time in HH:MM format\n        end_time: End time in HH:MM format\n        timezone: Timezone (default: UTC)\n\n    Example:\n        # NOTE: Business hours only\n        @guard_decorator.time_window(\"09:00\", \"17:00\", \"UTC\")\n        def business_api():\n            return {\"message\": \"business hours only\"}\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        route_config = self._ensure_route_config(func)\n        route_config.time_restrictions = {\n            \"start\": start_time,\n            \"end\": end_time,\n            \"timezone\": timezone,\n        }\n        return self._apply_route_config(func)\n\n    return decorator\n</code></pre>"},{"location":"api/decorators/#guard.decorators.advanced.AdvancedMixin.time_window--note-business-hours-only","title":"NOTE: Business hours only","text":"<p>@guard_decorator.time_window(\"09:00\", \"17:00\", \"UTC\") def business_api():     return {\"message\": \"business hours only\"}</p>"},{"location":"api/decorators/#utility-functions","title":"Utility Functions","text":""},{"location":"api/decorators/#get_route_decorator_config","title":". get_route_decorator_config","text":"<p>Extract route security configuration from the current FastAPI request.</p>"},{"location":"api/decorators/#guard.decorators.base.get_route_decorator_config","title":"<code>guard.decorators.base.get_route_decorator_config(request, decorator_handler)</code>","text":"<p>Extract route security configuration from the current request.</p> Source code in <code>guard/decorators/base.py</code> <pre><code>def get_route_decorator_config(\n    request: Request, decorator_handler: BaseSecurityDecorator\n) -&gt; RouteConfig | None:\n    \"\"\"Extract route security configuration from the current request.\"\"\"\n    if hasattr(request, \"scope\") and \"route\" in request.scope:\n        route = request.scope[\"route\"]\n        if hasattr(route, \"endpoint\") and hasattr(route.endpoint, \"_guard_route_id\"):\n            route_id = route.endpoint._guard_route_id\n            return decorator_handler.get_route_config(route_id)\n    return None\n</code></pre>"},{"location":"api/decorators/#integration-with-middleware","title":"Integration with Middleware","text":"<p>The decorators work in conjunction with the SecurityMiddleware to provide comprehensive protection:</p> <ol> <li>Route Configuration: Decorators configure route-specific settings</li> <li>Middleware Processing: SecurityMiddleware reads decorator configurations and applies them</li> <li>Override Behavior: Route-specific settings can override global middleware settings</li> </ol> <p>Example Integration:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\nfrom guard.decorators import SecurityDecorator\n\napp = FastAPI()\nconfig = SecurityConfig(\n    enable_ip_banning=True,\n    enable_rate_limiting=True,\n    rate_limit_requests=100,\n    rate_limit_window=3600\n)\n\n# Create decorator instance\nguard_deco = SecurityDecorator(config)\n\n# Apply decorators to routes\n@guard_deco.rate_limit(requests=10, window=300)  # Override: 10 requests/5min\n@app.get(\"/api/limited\")\ndef limited_endpoint():\n    # Uses decorator-specific rate limiting\n    return {\"data\": \"limited\"}\n\n@app.get(\"/api/public\")\ndef public_endpoint():\n    # Uses global rate limiting (100 requests/hour)\n    return {\"data\": \"public\"}\n\n# Add global middleware\napp.add_middleware(SecurityMiddleware, config=config)\n\n# Set decorator handler on app state (required for integration)\napp.state.guard_decorator = guard_deco\n</code></pre>"},{"location":"api/decorators/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/#decorator-order","title":". Decorator Order","text":"<p>Apply decorators in logical order, with more specific restrictions first:</p> <pre><code>@app.post(\"/api/admin/sensitive\")\n@guard_deco.require_https()                        # Security requirement\n@guard_deco.require_auth(type=\"bearer\")            # Authentication\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])   # Access control\n@guard_deco.rate_limit(requests=5, window=3600)    # Rate limiting\n@guard_deco.suspicious_detection(enabled=True)     # Monitoring\ndef admin_endpoint():\n    return {\"status\": \"admin action\"}\n</code></pre>"},{"location":"api/decorators/#combining-behavioral-analysis","title":". Combining Behavioral Analysis","text":"<p>Use multiple behavioral decorators for comprehensive monitoring:</p> <pre><code>@app.get(\"/api/rewards\")\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"ban\")\n@guard_deco.return_monitor(\"rare_item\", max_occurrences=3, window=86400, action=\"ban\")\n@guard_deco.suspicious_frequency(max_frequency=0.1, window=300, action=\"alert\")\ndef rewards_endpoint():\n    return {\"reward\": \"rare_item\", \"value\": 1000}\n</code></pre>"},{"location":"api/decorators/#geographic-and-cloud-controls","title":". Geographic and Cloud Controls","text":"<p>Combine geographic and cloud provider controls:</p> <pre><code>@app.get(\"/api/restricted\")\n@guard_deco.allow_countries([\"US\", \"CA\", \"GB\"])  # Allow specific countries\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])         # Block cloud providers\ndef restricted_endpoint():\n    return {\"data\": \"geo-restricted\"}\n</code></pre>"},{"location":"api/decorators/#content-filtering","title":". Content Filtering","text":"<p>Apply content filtering for upload endpoints:</p> <pre><code>@app.post(\"/api/upload\")\n@guard_deco.content_type_filter([\"image/jpeg\", \"image/png\"])\n@guard_deco.max_request_size(5 * 1024 * 1024)  # 5MB limit\n@guard_deco.require_referrer([\"myapp.com\"])\ndef upload_endpoint():\n    return {\"status\": \"uploaded\"}\n</code></pre>"},{"location":"api/decorators/#error-handling","title":"Error Handling","text":"<p>Decorators integrate with the middleware's error handling system. When decorator conditions are not met, appropriate HTTP responses are returned:</p>"},{"location":"api/decorators/#403-forbidden","title":". 403 Forbidden","text":"<p>IP restrictions, country blocks, authentication failures</p>"},{"location":"api/decorators/#429-too-many-requests","title":". 429 Too Many Requests","text":"<p>Rate limiting violations</p>"},{"location":"api/decorators/#400-bad-request","title":". 400 Bad Request","text":"<p>Content type mismatches, missing headers</p>"},{"location":"api/decorators/#413-payload-too-large","title":". 413 Payload Too Large","text":"<p>Request size limits exceeded</p>"},{"location":"api/decorators/#configuration-priority","title":"Configuration Priority","text":"<p>Security settings are applied in the following priority order:</p> <ol> <li>Decorator Settings (highest priority)</li> <li>Global Middleware Settings</li> <li>Default Settings (lowest priority)</li> </ol> <p>This allows for flexible override behavior where routes can customize their security requirements while maintaining global defaults.</p>"},{"location":"api/ipban-manager/","title":"IPBanManager","text":"<p>The <code>IPBanManager</code> class handles temporary IP bans in your FastAPI application.</p>"},{"location":"api/ipban-manager/#overview","title":"Overview","text":"<pre><code>from guard.handlers.ipban_handler import IPBanManager\n\nip_ban_manager = IPBanManager()\n</code></pre> <p>The <code>IPBanManager</code> uses an in-memory cache to track banned IPs and their ban durations.</p>"},{"location":"api/ipban-manager/#distributed-banning","title":"Distributed Banning","text":"<p>When Redis is enabled:</p> <ul> <li>Bans are shared across instances</li> <li>Ban expiration is handled automatically</li> <li>Supports atomic ban operations</li> </ul> <pre><code># Cluster-wide ban\nawait ip_ban_manager.ban_ip(\"192.168.1.1\", 3600, distributed=True)\n\n# Check ban status across cluster\nis_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\", check_redis=True)\n</code></pre>"},{"location":"api/ipban-manager/#methods","title":"Methods","text":""},{"location":"api/ipban-manager/#ban_ip","title":"ban_ip","text":"<p>Ban an IP address for a specified duration.</p> <pre><code>async def ban_ip(ip: str, duration: int) -&gt; None\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to ban - <code>duration</code>: Ban duration in seconds</p> <p>Example:</p> <pre><code>await ip_ban_manager.ban_ip(\"192.168.1.1\", 3600)  # Ban for 1 hour\n</code></pre>"},{"location":"api/ipban-manager/#is_ip_banned","title":"is_ip_banned","text":"<p>Check if an IP address is currently banned.</p> <pre><code>async def is_ip_banned(ip: str) -&gt; bool\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to check</p> <p>Returns: - <code>bool</code>: True if the IP is banned, False otherwise</p> <p>Example:</p> <pre><code>is_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\")\n</code></pre>"},{"location":"api/ipban-manager/#reset","title":"reset","text":"<p>Reset all banned IPs.</p> <pre><code>async def reset() -&gt; None\n</code></pre> <p>Example:</p> <pre><code>await ip_ban_manager.reset()\n</code></pre>"},{"location":"api/ipban-manager/#usage-with-securitymiddleware","title":"Usage with SecurityMiddleware","text":"<p>The <code>IPBanManager</code> is automatically integrated when you use the <code>SecurityMiddleware</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600  # Ban for 1 hour\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ipinfo-manager/","title":"IPInfoManager","text":"<p>The <code>IPInfoManager</code> class handles IP geolocation using IPInfo's database. It uses a singleton pattern to ensure only one instance exists throughout the application.</p> <p>Performance Note: The IPInfo database is only downloaded and initialized when country-based filtering is configured in your application, improving startup time and reducing resource usage when these features aren't needed.</p>"},{"location":"api/ipinfo-manager/#class-definition","title":"Class Definition","text":"<pre><code>class IPInfoManager:\n    _instance = None\n    token: str\n    db_path: Path\n    reader: Reader | None = None\n    redis_handler: Any = None\n\n    def __new__(cls: type[\"IPInfoManager\"], token: str, db_path: Path | None = None) -&gt; \"IPInfoManager\":\n        if not token:\n            raise ValueError(\"IPInfo token is required!\")\n\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.token = token\n            cls._instance.db_path = db_path or Path(\"data/ipinfo/country_asn.mmdb\")\n            cls._instance.reader = None\n            cls._instance.redis_handler = None\n        # Update token\n        elif token:\n            cls._instance.token = token\n            # Update db_path\n            if db_path is not None:\n                cls._instance.db_path = db_path\n        return cls._instance\n</code></pre>"},{"location":"api/ipinfo-manager/#methods","title":"Methods","text":""},{"location":"api/ipinfo-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"\n    Initialize and download the database if needed.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#get_country","title":"get_country","text":"<pre><code>def get_country(self, ip: str) -&gt; str | None:\n    \"\"\"\n    Get country code for an IP address.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#close","title":"close","text":"<pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#redis-caching","title":"Redis Caching","text":"<p>The database is cached in Redis with 24-hour TTL when enabled:</p> <pre><code># Get cached database\ndb_content = await redis.get_key(\"ipinfo\", \"database\")\n\n# Force refresh cache\nawait ipinfo_db.initialize()  # Will update Redis cache\n</code></pre>"},{"location":"api/ipinfo-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\nfrom pathlib import Path\n\n# Initialize with custom database location\nipinfo_db = IPInfoManager(\n    token=\"your_token\",\n    db_path=Path(\"/custom/path/ipinfo.db\") # default is ./data/ipinfo/country_asn.mmdb\n)\nawait ipinfo_db.initialize()\n\n# Get country for IP\ncountry = ipinfo_db.get_country(\"8.8.8.8\")\nprint(f\"Country: {country}\")  # Output: \"US\"\n\n# Clean up\nipinfo_db.close()\n\n# Get the same instance\nsame_db = IPInfoManager(token=\"your_token\")  # Same instance returned\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":""},{"location":"api/overview/#core-components","title":"Core Components","text":""},{"location":"api/overview/#middleware-configuration","title":"Middleware &amp; Configuration","text":"<ul> <li>SecurityMiddleware: The main middleware that handles all security features</li> <li>SecurityConfig: Configuration class for all security settings</li> <li>SecurityDecorator: Route-level security decorator system</li> </ul>"},{"location":"api/overview/#handler-components","title":"Handler Components","text":"<ul> <li>IPBanManager: Manages IP banning functionality</li> <li>IPInfoManager: Handles IP geolocation using IPInfo's database</li> <li>SusPatternsManager: Manages suspicious patterns for threat detection</li> <li>CloudManager: Handles cloud provider IP range detection</li> <li>RateLimitManager: Handles rate limiting functionality</li> <li>RedisManager: Handles Redis connections and atomic operations</li> <li>BehaviorTracker: Handles behavioral analysis and monitoring</li> </ul>"},{"location":"api/overview/#utilities","title":"Utilities","text":"<ul> <li>Utilities: Helper functions for logging and request analysis</li> </ul>"},{"location":"api/overview/#key-classes-and-instances","title":"Key Classes and Instances","text":"<pre><code># Core middleware and configuration\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Security decorators\nfrom guard.decorators import SecurityDecorator, RouteConfig\nfrom guard.decorators.base import get_route_decorator_config\n\n# Handler classes and their pre-initialized instances\nfrom guard.handlers.cloud_handler import CloudManager, cloud_handler\nfrom guard.handlers.ipban_handler import IPBanManager, ip_ban_manager\nfrom guard.handlers.ratelimit_handler import RateLimitManager, rate_limit_handler\nfrom guard.handlers.redis_handler import RedisManager, redis_handler\nfrom guard.handlers.suspatterns_handler import SusPatternsManager, sus_patterns_handler\nfrom guard.handlers.behavior_handler import BehaviorTracker, BehaviorRule\n\n# Special case - requires parameters\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n</code></pre>"},{"location":"api/overview/#singleton-pattern","title":"Singleton Pattern","text":"<p>Most handler classes use a singleton pattern with <code>__new__</code> to ensure only one instance:</p> <pre><code>class ExampleHandler:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs) -&gt; \"ExampleHandler\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            # Initialize instance attributes\n        return cls._instance\n</code></pre>"},{"location":"api/overview/#configuration-model","title":"Configuration Model","text":"<p>The <code>SecurityConfig</code> class is the central configuration point:</p> <pre><code>class SecurityConfig:\n    def __init__(\n        self,\n        geo_ip_handler: GeoIPHandler | None = None,\n        whitelist: list[str] | None = None,\n        blacklist: list[str] = [],\n        blocked_countries: list[str] = [],\n        whitelist_countries: list[str] = [],\n        blocked_user_agents: list[str] = [],\n        auto_ban_threshold: int = 5,\n        auto_ban_duration: int = 3600,\n        rate_limit: int = 100,\n        rate_limit_window: int = 60,\n        enable_cors: bool = False,\n        # ... other parameters\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/overview/#optimized-loading","title":"Optimized Loading","text":"<p>FastAPI Guard uses a smart loading strategy to improve performance:</p> <ul> <li>IPInfoManager: Only downloaded and initialized when country filtering is configured</li> <li>CloudManager: Only fetches cloud provider IP ranges when cloud blocking is enabled</li> <li>Handlers Initialization: Middleware conditionally initializes components based on configuration</li> </ul> <p>This approach reduces startup time and memory usage when not all security features are needed.</p> <pre><code># Conditional loading example from middleware\nasync def initialize(self) -&gt; None:\n    if self.config.enable_redis and self.redis_handler:\n        await self.redis_handler.initialize()\n        # Only initialize when needed\n        if self.config.block_cloud_providers:\n            await cloud_handler.initialize_redis(\n                self.redis_handler, self.config.block_cloud_providers\n            )\n        await ip_ban_manager.initialize_redis(self.redis_handler)\n        # Only initialize if country filtering is enabled\n        if self.geo_ip_handler is not None:\n            await self.geo_ip_handler.initialize_redis(self.redis_handler)\n</code></pre>"},{"location":"api/overview/#security-decorators","title":"Security Decorators","text":"<p>FastAPI Guard provides a comprehensive decorator system for route-level security controls:</p>"},{"location":"api/overview/#securitydecorator-class","title":"SecurityDecorator Class","text":"<p>The main decorator class combines all security capabilities:</p> <pre><code>from guard.decorators import SecurityDecorator\n\nconfig = SecurityConfig()\nguard_deco = SecurityDecorator(config)\n\n# Apply to routes\n@app.get(\"/api/sensitive\")\n@guard_deco.rate_limit(requests=5, window=300)\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])\n@guard_deco.block_countries([\"CN\", \"RU\"])\ndef sensitive_endpoint():\n    return {\"data\": \"sensitive\"}\n</code></pre>"},{"location":"api/overview/#decorator-categories","title":"Decorator Categories","text":"<ul> <li>AccessControlMixin: IP filtering, geographic restrictions, cloud provider blocking</li> <li>AuthenticationMixin: HTTPS enforcement, auth requirements, API key validation</li> <li>RateLimitingMixin: Custom rate limits, geographic rate limiting</li> <li>BehavioralMixin: Usage monitoring, return pattern analysis, frequency detection</li> <li>ContentFilteringMixin: Content type filtering, size limits, user agent blocking</li> <li>AdvancedMixin: Time windows, suspicious detection, honeypot detection</li> </ul>"},{"location":"api/overview/#integration-with-middleware","title":"Integration with Middleware","text":"<p>Decorators work seamlessly with SecurityMiddleware:</p> <pre><code># Set up middleware and decorators\napp.add_middleware(SecurityMiddleware, config=config)\napp.state.guard_decorator = guard_deco  # Required for integration\n</code></pre>"},{"location":"api/overview/#route-configuration-priority","title":"Route Configuration Priority","text":"<p>Configuration is applied in the following order of precedence:</p> <ol> <li>Decorator Settings (highest priority)</li> <li>Global Middleware Settings</li> <li>Default Settings (lowest priority)</li> </ol> <p>This allows route-specific overrides while maintaining global defaults.</p>"},{"location":"api/ratelimit-manager/","title":"RateLimitManager","text":"<p>The <code>RateLimitManager</code> is responsible for managing rate limiting functionality in FastAPI Guard. It supports both in-memory rate limiting using timestamp tracking and distributed rate limiting using Redis.</p>"},{"location":"api/ratelimit-manager/#overview","title":"Overview","text":"<p>Rate limiting is an essential security feature that protects your API from abuse by limiting the number of requests a client can make within a specific time window. The <code>RateLimitManager</code> implements this functionality with the following features:</p> <ul> <li>True sliding window algorithm: Tracks individual request timestamps rather than simple counters</li> <li>In-memory timestamp tracking: Uses deques for efficient, chronological storage</li> <li>Redis-based distributed rate limiting: Optional support for distributed environments</li> <li>Atomic Redis operations: Uses Lua scripts for consistent counting across instances</li> <li>Configurable limits and windows: Set your own thresholds and time periods</li> <li>Singleton pattern: Ensures consistent state across requests</li> <li>Automatic cleanup: Expired timestamps are automatically removed</li> </ul>"},{"location":"api/ratelimit-manager/#example-usage","title":"Example Usage","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\n# Configure rate limiting\nconfig = SecurityConfig(\n    rate_limit=100,               # Max 100 requests\n    rate_limit_window=60,         # Per minute\n    enable_rate_limiting=True,    # Enable rate limiting (true by default)\n    enable_redis=True,            # Use Redis for distributed setup (true by default)\n    redis_url=\"redis://localhost:6379/0\"\n)\n\n# Add middleware with rate limiting\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ratelimit-manager/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/ratelimit-manager/#redis-integration","title":"Redis Integration","text":"<p>When using Redis for distributed rate limiting, the handler creates sorted sets with the following pattern:</p> <pre><code>{redis_prefix}rate_limit:rate:{client_ip}\n</code></pre> <p>Each entry in the sorted set represents a request timestamp. The keys automatically expire after twice the configured window duration.</p>"},{"location":"api/ratelimit-manager/#redis-lua-script","title":"Redis Lua Script","text":"<p>The rate limiter uses a Redis Lua script for atomic operations in distributed environments:</p> <ol> <li>Add the current timestamp to the sorted set</li> <li>Remove timestamps outside the current window</li> <li>Count the number of timestamps within the window</li> <li>Set expiry for the key</li> </ol> <p>This ensures that rate limiting is consistent even in high-concurrency environments.</p>"},{"location":"api/ratelimit-manager/#direct-access","title":"Direct Access","text":"<p>You can also access the handler directly if needed:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nhandler = rate_limit_handler(config)\n\n# Reset all rate limits\nawait handler.reset()\n</code></pre>"},{"location":"api/ratelimit-manager/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>In-memory rate limiting has lower latency but doesn't work in distributed environments</li> <li>Redis-based rate limiting works across multiple instances but adds network overhead</li> <li>The sliding window algorithm ensures accurate rate limiting without traffic spikes at window boundaries</li> <li>Automatic cleanup of old timestamps prevents memory leaks</li> </ul>"},{"location":"api/ratelimit-manager/#see-also","title":"See Also","text":"<ul> <li>Rate Limiting Tutorial</li> <li>Redis Integration</li> <li>SecurityMiddleware</li> </ul>"},{"location":"api/redis-manager/","title":"RedisManager","text":"<p>The <code>RedisManager</code> class handles Redis connections and atomic operations with automatic retries.</p>"},{"location":"api/redis-manager/#class-definition","title":"Class Definition","text":"<pre><code>class RedisManager:\n    \"\"\"\n    Robust Redis handler with connection pooling and automatic reconnection.\n    \"\"\"\n</code></pre>"},{"location":"api/redis-manager/#key-methods","title":"Key Methods","text":""},{"location":"api/redis-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"Initialize Redis connection with retry logic\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#get_connection","title":"get_connection","text":"<pre><code>@asynccontextmanager\nasync def get_connection(self):\n    \"\"\"Context manager for safe Redis operations\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#safe_operation","title":"safe_operation","text":"<pre><code>async def safe_operation(self, func, *args, **kwargs):\n    \"\"\"Execute Redis operation with error handling\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#atomic-operations","title":"Atomic Operations","text":""},{"location":"api/redis-manager/#get_key","title":"get_key","text":"<pre><code>async def get_key(self, namespace: str, key: str) -&gt; Any:\n    \"\"\"Get namespaced key with prefix\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#set_key","title":"set_key","text":"<pre><code>async def set_key(self, namespace: str, key: str, value: Any, ttl: int | None = None) -&gt; bool:\n    \"\"\"Set namespaced key with optional TTL\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#incr","title":"incr","text":"<pre><code>async def incr(self, namespace: str, key: str, ttl: int | None = None) -&gt; int:\n    \"\"\"Atomic increment with expiration\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.redis_handler import RedisManager\nfrom guard.models import SecurityConfig\n\nconfig = SecurityConfig(redis_url=\"redis://localhost:6379\")\nredis = RedisManager(config)\n\nasync def example():\n    await redis.initialize()\n    async with redis.get_connection() as conn:\n        await conn.set(\"test_key\", \"value\")\n\n    # Atomic operation\n    await redis.set_key(\"namespace\", \"key\", \"value\", ttl=3600)\n</code></pre>"},{"location":"api/security-headers/","title":"Security Headers Manager","text":"<p>The Security Headers Manager provides comprehensive HTTP security header management following OWASP best practices.</p>"},{"location":"api/security-headers/#overview","title":"Overview","text":"<p>The <code>SecurityHeadersManager</code> is a singleton class that manages security headers for HTTP responses, including Content Security Policy (CSP), HTTP Strict Transport Security (HSTS), and other essential security headers.</p>"},{"location":"api/security-headers/#class-reference","title":"Class Reference","text":""},{"location":"api/security-headers/#securityheadersmanager","title":"SecurityHeadersManager","text":"<pre><code>from guard.handlers.security_headers_handler import SecurityHeadersManager\n\nsecurity_headers_manager = SecurityHeadersManager()\n</code></pre>"},{"location":"api/security-headers/#methods","title":"Methods","text":""},{"location":"api/security-headers/#configure","title":"configure","text":"<p>Configure security headers settings.</p> <pre><code>security_headers_manager.configure(\n    enabled=True,\n    csp={\n        \"default-src\": [\"'self'\"],\n        \"script-src\": [\"'self'\", \"https://trusted.cdn.com\"],\n        \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n        \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n        \"font-src\": [\"'self'\", \"https://fonts.gstatic.com\"],\n        \"connect-src\": [\"'self'\"],\n        \"frame-ancestors\": [\"'none'\"],\n        \"base-uri\": [\"'self'\"],\n        \"form-action\": [\"'self'\"]\n    },\n    hsts_max_age=31536000,  # 1 year\n    hsts_include_subdomains=True,\n    hsts_preload=False,\n    frame_options=\"SAMEORIGIN\",\n    content_type_options=\"nosniff\",\n    xss_protection=\"1; mode=block\",\n    referrer_policy=\"strict-origin-when-cross-origin\",\n    permissions_policy=\"geolocation=(), microphone=(), camera=()\",\n    custom_headers={\n        \"X-Custom-Header\": \"CustomValue\"\n    },\n    cors_origins=[\"https://app.example.com\"],\n    cors_allow_credentials=True,\n    cors_allow_methods=[\"GET\", \"POST\"],\n    cors_allow_headers=[\"*\"]\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>enabled</code> (bool): Enable/disable security headers. Default: <code>True</code></li> <li><code>csp</code> (dict[str, list[str]] | None): Content Security Policy directives</li> <li><code>hsts_max_age</code> (int | None): HSTS max-age in seconds (e.g., 31536000 for 1 year)</li> <li><code>hsts_include_subdomains</code> (bool): Include subdomains in HSTS. Default: <code>True</code></li> <li><code>hsts_preload</code> (bool): Enable HSTS preload. Default: <code>False</code></li> <li><code>frame_options</code> (str | None): X-Frame-Options value (<code>DENY</code>, <code>SAMEORIGIN</code>)</li> <li><code>content_type_options</code> (str | None): X-Content-Type-Options value</li> <li><code>xss_protection</code> (str | None): X-XSS-Protection value</li> <li><code>referrer_policy</code> (str | None): Referrer-Policy value</li> <li><code>permissions_policy</code> (str | None): Permissions-Policy value</li> <li><code>custom_headers</code> (dict[str, str] | None): Additional custom security headers</li> <li><code>cors_origins</code> (list[str] | None): Allowed CORS origins</li> <li><code>cors_allow_credentials</code> (bool): Allow credentials in CORS. Default: <code>False</code></li> <li><code>cors_allow_methods</code> (list[str] | None): Allowed CORS methods</li> <li><code>cors_allow_headers</code> (list[str] | None): Allowed CORS headers</li> </ul>"},{"location":"api/security-headers/#get_headers","title":"get_headers","text":"<p>Get security headers for a response.</p> <pre><code>headers = await security_headers_manager.get_headers(\n    request_path=\"/api/endpoint\"\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>request_path</code> (str | None): Optional request path for path-specific headers</li> </ul> <p>Returns:</p> <ul> <li><code>dict[str, str]</code>: Dictionary of security headers</li> </ul>"},{"location":"api/security-headers/#get_cors_headers","title":"get_cors_headers","text":"<p>Get CORS headers if origin is allowed.</p> <pre><code>cors_headers = await security_headers_manager.get_cors_headers(\n    origin=\"https://app.example.com\"\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>origin</code> (str): Request origin</li> </ul> <p>Returns:</p> <ul> <li><code>dict[str, str]</code>: Dictionary of CORS headers</li> </ul>"},{"location":"api/security-headers/#validate_csp_report","title":"validate_csp_report","text":"<p>Validate and process CSP violation reports.</p> <pre><code>is_valid = await security_headers_manager.validate_csp_report(\n    report={\n        \"csp-report\": {\n            \"document-uri\": \"https://example.com/page\",\n            \"violated-directive\": \"script-src\",\n            \"blocked-uri\": \"https://evil.com/script.js\",\n            \"source-file\": \"https://example.com/app.js\",\n            \"line-number\": 10\n        }\n    }\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>report</code> (dict[str, Any]): CSP violation report</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if report is valid</li> </ul>"},{"location":"api/security-headers/#initialize_redis","title":"initialize_redis","text":"<p>Initialize Redis connection for caching header configurations.</p> <pre><code>await security_headers_manager.initialize_redis(redis_handler)\n</code></pre> <p>Parameters:</p> <ul> <li><code>redis_handler</code> (Any): Redis handler instance</li> </ul>"},{"location":"api/security-headers/#initialize_agent","title":"initialize_agent","text":"<p>Initialize agent integration for security event tracking.</p> <pre><code>await security_headers_manager.initialize_agent(agent_handler)\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_handler</code> (Any): Agent handler instance</li> </ul>"},{"location":"api/security-headers/#reset","title":"reset","text":"<p>Reset all security headers configuration.</p> <pre><code>await security_headers_manager.reset()\n</code></pre>"},{"location":"api/security-headers/#default-headers","title":"Default Headers","text":"<p>The following headers are configured by default:</p> Header Default Value Description <code>X-Content-Type-Options</code> <code>nosniff</code> Prevents MIME type sniffing <code>X-Frame-Options</code> <code>SAMEORIGIN</code> Prevents clickjacking attacks <code>X-XSS-Protection</code> <code>1; mode=block</code> Enables XSS filtering <code>Referrer-Policy</code> <code>strict-origin-when-cross-origin</code> Controls referrer information <code>Permissions-Policy</code> <code>geolocation=(), microphone=(), camera=()</code> Restricts browser features <code>X-Permitted-Cross-Domain-Policies</code> <code>none</code> Restricts Adobe Flash cross-domain access <code>X-Download-Options</code> <code>noopen</code> Prevents file download execution in IE <code>Cross-Origin-Embedder-Policy</code> <code>require-corp</code> Controls cross-origin resource embedding <code>Cross-Origin-Opener-Policy</code> <code>same-origin</code> Controls cross-origin window interactions <code>Cross-Origin-Resource-Policy</code> <code>same-origin</code> Controls cross-origin resource access"},{"location":"api/security-headers/#content-security-policy-csp","title":"Content Security Policy (CSP)","text":"<p>CSP helps prevent XSS attacks by specifying which sources are allowed for various content types.</p>"},{"location":"api/security-headers/#common-csp-directives","title":"Common CSP Directives","text":"<ul> <li><code>default-src</code>: Default policy for all resource types</li> <li><code>script-src</code>: Valid sources for JavaScript</li> <li><code>style-src</code>: Valid sources for stylesheets</li> <li><code>img-src</code>: Valid sources for images</li> <li><code>font-src</code>: Valid sources for fonts</li> <li><code>connect-src</code>: Valid sources for fetch, XMLHttpRequest, WebSocket</li> <li><code>frame-src</code>: Valid sources for frames</li> <li><code>frame-ancestors</code>: Valid parents that may embed a page</li> <li><code>base-uri</code>: Restricts URLs for <code>&lt;base&gt;</code> element</li> <li><code>form-action</code>: Valid endpoints for form submissions</li> <li><code>report-uri</code>: URL to send CSP violation reports</li> </ul>"},{"location":"api/security-headers/#csp-source-values","title":"CSP Source Values","text":"<ul> <li><code>'self'</code>: Same origin</li> <li><code>'none'</code>: No sources allowed</li> <li><code>'unsafe-inline'</code>: Allow inline scripts/styles (use with caution)</li> <li><code>'unsafe-eval'</code>: Allow eval() (use with caution)</li> <li><code>https:</code>: Any HTTPS source</li> <li><code>data:</code>: Data URIs</li> <li>Specific domains: <code>https://trusted.cdn.com</code></li> </ul>"},{"location":"api/security-headers/#http-strict-transport-security-hsts","title":"HTTP Strict Transport Security (HSTS)","text":"<p>HSTS forces browsers to use HTTPS connections.</p>"},{"location":"api/security-headers/#hsts-configuration","title":"HSTS Configuration","text":"<pre><code>hsts_config = {\n    \"max_age\": 31536000,        # 1 year in seconds\n    \"include_subdomains\": True,  # Apply to all subdomains\n    \"preload\": False            # Submit to HSTS preload list\n}\n</code></pre>"},{"location":"api/security-headers/#hsts-preload-requirements","title":"HSTS Preload Requirements","text":"<p>To enable HSTS preload:</p> <ol> <li>Serve a valid certificate</li> <li>Redirect all HTTP to HTTPS</li> <li>Serve all subdomains over HTTPS</li> <li>Set <code>max_age</code> to at least 31536000 (1 year)</li> <li>Include <code>includeSubDomains</code></li> <li>Include <code>preload</code></li> </ol>"},{"location":"api/security-headers/#cors-integration","title":"CORS Integration","text":"<p>The Security Headers Manager integrates with CORS configuration:</p> <pre><code># CORS headers are automatically added when:\n# 1. An origin header is present in the request\n# 2. The origin is in the allowed list\ncors_config = {\n    \"origins\": [\"https://app.example.com\", \"https://admin.example.com\"],\n    \"allow_credentials\": True,\n    \"allow_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    \"allow_headers\": [\"*\"]\n}\n</code></pre>"},{"location":"api/security-headers/#redis-caching","title":"Redis Caching","text":"<p>Header configurations are cached in Redis for performance:</p> <ul> <li>CSP configuration: Cached with key <code>security_headers:csp_config</code></li> <li>HSTS configuration: Cached with key <code>security_headers:hsts_config</code></li> <li>Custom headers: Cached with key <code>security_headers:custom_headers</code></li> <li>TTL: 86400 seconds (24 hours)</li> </ul>"},{"location":"api/security-headers/#agent-integration","title":"Agent Integration","text":"<p>When agent is configured, the following events are sent:</p> <ul> <li><code>security_headers_applied</code>: When headers are added to a response</li> <li><code>csp_violation</code>: When a CSP violation report is received</li> </ul>"},{"location":"api/security-headers/#example-usage","title":"Example Usage","text":""},{"location":"api/security-headers/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    security_headers={\n        \"enabled\": True,\n        \"hsts\": {\n            \"max_age\": 31536000,\n            \"include_subdomains\": True,\n            \"preload\": False\n        },\n        \"frame_options\": \"DENY\",\n        \"content_type_options\": \"nosniff\",\n        \"xss_protection\": \"1; mode=block\",\n        \"referrer_policy\": \"no-referrer\",\n        \"permissions_policy\": \"geolocation=(), microphone=(), camera=()\"\n    }\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/security-headers/#advanced-csp-configuration","title":"Advanced CSP Configuration","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"enabled\": True,\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\", \"'unsafe-inline'\", \"https://cdn.jsdelivr.net\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\n            \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n            \"font-src\": [\"'self'\", \"https://fonts.gstatic.com\"],\n            \"connect-src\": [\"'self'\", \"https://api.example.com\"],\n            \"frame-ancestors\": [\"'none'\"],\n            \"base-uri\": [\"'self'\"],\n            \"form-action\": [\"'self'\"],\n            \"report-uri\": [\"/api/csp-report\"]\n        }\n    }\n)\n</code></pre>"},{"location":"api/security-headers/#csp-report-endpoint","title":"CSP Report Endpoint","text":"<pre><code>from fastapi import Request\n\n@app.post(\"/api/csp-report\")\nasync def handle_csp_report(request: Request):\n    report = await request.json()\n    is_valid = await security_headers_manager.validate_csp_report(report)\n\n    if is_valid:\n        # Report is logged automatically by the manager\n        return {\"status\": \"received\"}\n\n    return {\"status\": \"invalid\"}\n</code></pre>"},{"location":"api/security-headers/#disabling-specific-headers","title":"Disabling Specific Headers","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"enabled\": True,\n        \"frame_options\": None,  # Disable X-Frame-Options\n        \"permissions_policy\": None,  # Disable Permissions-Policy\n        # Other headers remain at defaults\n    }\n)\n</code></pre>"},{"location":"api/security-headers/#best-practices","title":"Best Practices","text":"<ol> <li>Gradual HSTS Rollout: Start with a small <code>max_age</code> and gradually increase</li> <li>Test Thoroughly: Security headers can break functionality if too restrictive</li> <li>Monitor CSP Reports: Set up monitoring for CSP violations</li> <li>Use HTTPS: Many security headers require HTTPS to be effective</li> <li>Browser Compatibility: Check browser support for specific headers</li> </ol>"},{"location":"api/security-headers/#security-considerations","title":"Security Considerations","text":"<ul> <li>Header Injection Prevention: All header values are validated against injection attacks, newlines, and excessive length</li> <li>CORS Security: Wildcard origins (<code>*</code>) cannot be used with credentials to prevent security vulnerabilities</li> <li>Thread Safety: SecurityHeadersManager uses thread-safe singleton pattern with double-checked locking</li> <li>Cache Security: Cache keys are generated using SHA256 hashing to prevent cache poisoning attacks</li> <li>CSP Validation: Unsafe directives like <code>'unsafe-inline'</code> and <code>'unsafe-eval'</code> trigger security warnings</li> <li>HSTS Preload: Strict validation ensures preload requirements (max_age \u2265 1 year, includeSubDomains)</li> <li>CSP Bypasses: Be aware of potential CSP bypasses with <code>'unsafe-inline'</code> and <code>'unsafe-eval'</code></li> <li>HSTS Commitment: Once HSTS is enabled with a long <code>max_age</code>, it cannot be easily undone</li> <li>Frame Options: Consider using CSP's <code>frame-ancestors</code> instead of <code>X-Frame-Options</code></li> <li>Legacy Headers: Some headers like <code>X-XSS-Protection</code> are being phased out in modern browsers</li> <li>Performance: Complex CSP policies can impact page load performance</li> </ul>"},{"location":"api/security-headers/#see-also","title":"See Also","text":"<ul> <li>HTTP Security Headers Tutorial - Comprehensive guide</li> <li>Security Configuration - Configuration options</li> <li>Security Middleware - Middleware integration</li> </ul>"},{"location":"api/security-middleware/","title":"SecurityMiddleware","text":"<p>The <code>SecurityMiddleware</code> class is the core component of FastAPI Guard that handles all security features.</p>"},{"location":"api/security-middleware/#class-definition","title":"Class Definition","text":"<pre><code>class SecurityMiddleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app: Callable[[Request], Awaitable[Response]],\n        config: SecurityConfig\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/security-middleware/#methods","title":"Methods","text":""},{"location":"api/security-middleware/#dispatch","title":"dispatch","text":"<pre><code>async def dispatch(\n    self,\n    request: Request,\n    call_next: Callable[[Request], Awaitable[Response]]\n) -&gt; Response:\n    \"\"\"\n    Main method that processes each request through\n    the security pipeline.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#create_error_response","title":"create_error_response","text":"<pre><code>async def create_error_response(\n    self,\n    status_code: int,\n    default_message: str\n) -&gt; Response:\n    \"\"\"\n    Creates standardized error responses.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#handler-integration","title":"Handler Integration","text":"<p>The middleware works with singleton handler instances:</p> <ul> <li>All handler classes (IPBanManager, CloudManager, etc.) use the singleton pattern</li> <li>The middleware initializes these existing instances conditionally based on configuration</li> <li>IPInfoManager is only initialized when country filtering is enabled</li> <li>CloudManager is only loaded when cloud provider blocking is configured</li> <li>This selective loading improves performance when not all features are used</li> </ul>"},{"location":"api/security-middleware/#redis-configuration","title":"Redis Configuration","text":"<p>Enable Redis in SecurityConfig:</p> <pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod:6379/0\",\n    redis_prefix=\"prod_security:\"\n)\n</code></pre> <p>The middleware automatically initializes: - CloudManager cloud provider ip ranges - IPBanManager distributed banning - IPInfoManager IP geolocation - RateLimitManager rate limiting - RedisManager Redis caching - SusPatternsManager suspicious patterns</p>"},{"location":"api/security-middleware/#proxy-security-configuration","title":"Proxy Security Configuration","text":"<p>The middleware supports secure handling of proxy headers:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # List of trusted proxy IPs/ranges\n    trusted_proxy_depth=1,  # Number of proxies in the chain\n    trust_x_forwarded_proto=True,  # Trust X-Forwarded-Proto header from trusted proxies\n)\n</code></pre> <p>This prevents IP spoofing attacks through header manipulation.</p>"},{"location":"api/security-middleware/#usage-example","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geographical_ip_manager=IPInfoManager(\"your_token\"),  # NOTE: Required when using country blocking\n    rate_limit=100\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/sus-patterns/","title":"SusPatternsManager","text":"<p>The <code>SusPatternsManager</code> class manages suspicious patterns for security threat detection using a singleton pattern with enhanced detection capabilities.</p>"},{"location":"api/sus-patterns/#class-definition","title":"Class Definition","text":"<pre><code>class SusPatternsManager:\n    \"\"\"\n    Singleton pattern manager with enhanced detection capabilities.\n\n    Manages both default patterns (loaded from YAML files) and custom patterns,\n    with optional detection engine components for advanced threat analysis.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#pattern-management-methods","title":"Pattern Management Methods","text":""},{"location":"api/sus-patterns/#add_pattern","title":"add_pattern","text":"<pre><code>@classmethod\nasync def add_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; None:\n    \"\"\"\n    Add a new pattern to the detection system.\n\n    Args:\n        pattern: Regular expression pattern to add\n        custom: Whether this is a custom pattern (default: False)\n\n    Note:\n        - Custom patterns are stored separately and persist across restarts if Redis is enabled\n        - Patterns are compiled and validated before being added\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#remove_pattern","title":"remove_pattern","text":"<pre><code>@classmethod\nasync def remove_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; bool:\n    \"\"\"\n    Remove a pattern from the detection system.\n\n    Args:\n        pattern: Pattern to remove\n        custom: Whether to remove from custom patterns\n\n    Returns:\n        bool: True if pattern was successfully removed, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#clear_custom_patterns","title":"clear_custom_patterns","text":"<pre><code>@classmethod\nasync def clear_custom_patterns(cls) -&gt; None:\n    \"\"\"\n    Clear all custom patterns.\n\n    Note: This does not affect default patterns loaded from YAML files.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#pattern-retrieval-methods","title":"Pattern Retrieval Methods","text":"<pre><code>@classmethod\nasync def get_default_patterns(cls) -&gt; list[str]:\n    \"\"\"Get only the default patterns loaded from YAML files.\"\"\"\n\n@classmethod\nasync def get_custom_patterns(cls) -&gt; list[str]:\n    \"\"\"Get only the custom patterns added at runtime.\"\"\"\n\n@classmethod\nasync def get_all_patterns(cls) -&gt; list[str]:\n    \"\"\"Get all registered patterns (default + custom).\"\"\"\n\n@classmethod\nasync def get_all_compiled_patterns(cls) -&gt; list[re.Pattern]:\n    \"\"\"Get all compiled regex patterns.\"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#detection-methods","title":"Detection Methods","text":""},{"location":"api/sus-patterns/#detect-enhanced-detection","title":"detect (Enhanced Detection)","text":"<pre><code>async def detect(\n    self,\n    content: str,\n    ip_address: str,\n    context: str = \"unknown\",\n    correlation_id: str | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Perform comprehensive threat detection with detection engine.\n\n    Args:\n        content: Content to analyze\n        ip_address: IP address of the request\n        context: Where content came from (e.g., \"query_param\", \"body\")\n        correlation_id: Optional ID for request correlation\n\n    Returns:\n        Comprehensive detection results including:\n        - is_threat: Whether a threat was detected\n        - threat_score: Score from 0.0 to 1.0\n        - threats: List of detected threats with details\n        - execution metrics and context\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#detect_pattern_match-legacy","title":"detect_pattern_match (Legacy)","text":"<pre><code>async def detect_pattern_match(\n    self,\n    content: str,\n    ip_address: str,\n    context: str = \"unknown\",\n    correlation_id: str | None = None\n) -&gt; tuple[bool, str | None]:\n    \"\"\"\n    Legacy detection method for backward compatibility.\n\n    Returns:\n        Tuple of (pattern_detected, matched_pattern_string)\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#performance-and-monitoring","title":"Performance and Monitoring","text":""},{"location":"api/sus-patterns/#get_performance_stats","title":"get_performance_stats","text":"<pre><code>@classmethod\nasync def get_performance_stats(cls) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get comprehensive performance statistics.\n\n    Returns:\n        Dictionary containing:\n        - slow_patterns: Patterns exceeding slow threshold\n        - problematic_patterns: Patterns with timeouts or anomalies\n        - summary: Overall performance metrics\n\n    Returns None if performance monitoring is not configured.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_component_status","title":"get_component_status","text":"<pre><code>@classmethod\nasync def get_component_status(cls) -&gt; dict[str, bool]:\n    \"\"\"\n    Check which detection engine components are active.\n\n    Returns:\n        Dictionary with component status:\n        - compiler: Whether PatternCompiler is active\n        - preprocessor: Whether ContentPreprocessor is active\n        - semantic_analyzer: Whether SemanticAnalyzer is active\n        - performance_monitor: Whether PerformanceMonitor is active\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#configure_semantic_threshold","title":"configure_semantic_threshold","text":"<pre><code>async def configure_semantic_threshold(self, threshold: float) -&gt; None:\n    \"\"\"\n    Dynamically adjust semantic analysis threshold.\n\n    Args:\n        threshold: New threshold value (0.0 to 1.0)\n                  0 = disabled, higher values = stricter detection\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#detection-result-structure","title":"Detection Result Structure","text":"<p>The <code>detect()</code> method returns a comprehensive result dictionary:</p> <pre><code>{\n    \"is_threat\": bool,              # True if any threat detected\n    \"threat_score\": float,          # 0.0-1.0, highest threat score\n    \"threats\": [                    # List of detected threats\n        {\n            \"type\": \"regex\",        # Detection type\n            \"pattern\": str,         # Pattern that matched\n            \"execution_time\": float # Time to execute pattern\n        },\n        {\n            \"type\": \"semantic\",     # Heuristic detection\n            \"score\": float,         # Threat score\n            \"attack_types\": dict,   # Attack type probabilities\n            \"confidence\": str       # low/medium/high\n        }\n    ],\n    \"context\": str,                 # Where content came from\n    \"original_length\": int,         # Original content length\n    \"processed_length\": int,        # After preprocessing\n    \"execution_time\": float,        # Total detection time\n    \"detection_method\": str,        # \"enhanced\" or \"legacy\"\n    \"timeouts\": list[str],         # Patterns that timed out\n    \"correlation_id\": str | None    # Request correlation ID\n}\n</code></pre>"},{"location":"api/sus-patterns/#usage-examples","title":"Usage Examples","text":""},{"location":"api/sus-patterns/#basic-pattern-management","title":"Basic Pattern Management","text":"<pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Add custom pattern\nawait sus_patterns_handler.add_pattern(\n    r\"(?i)malicious.*pattern\",\n    custom=True\n)\n\n# Remove pattern\nsuccess = await sus_patterns_handler.remove_pattern(\n    r\"(?i)malicious.*pattern\",\n    custom=True\n)\n\n# Get all patterns\npatterns = await sus_patterns_handler.get_all_patterns()\n</code></pre>"},{"location":"api/sus-patterns/#enhanced-threat-detection","title":"Enhanced Threat Detection","text":"<pre><code># Perform detection with full context\nresult = await sus_patterns_handler.detect(\n    content=\"SELECT * FROM users WHERE id=1 OR 1=1\",\n    ip_address=\"192.168.1.100\",\n    context=\"query_param:search\",\n    correlation_id=\"req-123\"\n)\n\nif result[\"is_threat\"]:\n    print(f\"Threat score: {result['threat_score']}\")\n\n    for threat in result[\"threats\"]:\n        if threat[\"type\"] == \"regex\":\n            print(f\"Pattern matched: {threat['pattern']}\")\n        elif threat[\"type\"] == \"semantic\":\n            print(f\"Attack type: {threat.get('attack_types')}\")\n</code></pre>"},{"location":"api/sus-patterns/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># Get performance statistics\nstats = await sus_patterns_handler.get_performance_stats()\nif stats:\n    print(f\"Average execution time: {stats['summary']['average_time']}\")\n    print(f\"Timeout rate: {stats['summary']['timeout_rate']}\")\n\n    # Check for slow patterns\n    for pattern in stats[\"slow_patterns\"]:\n        print(f\"Slow pattern: {pattern['pattern']}\")\n        print(f\"Average time: {pattern['average_time']}\")\n\n# Check component status\nstatus = await sus_patterns_handler.get_component_status()\nprint(f\"Semantic analyzer active: {status['semantic_analyzer']}\")\nprint(f\"Performance monitor active: {status['performance_monitor']}\")\n</code></pre>"},{"location":"api/sus-patterns/#configuration-adjustment","title":"Configuration Adjustment","text":"<pre><code># Adjust semantic threshold dynamically\nawait sus_patterns_handler.configure_semantic_threshold(0.8)\n\n# Disable semantic analysis\nawait sus_patterns_handler.configure_semantic_threshold(0.0)\n</code></pre>"},{"location":"api/sus-patterns/#pattern-storage","title":"Pattern Storage","text":""},{"location":"api/sus-patterns/#default-patterns","title":"Default Patterns","text":"<p>Default patterns are loaded from YAML files in the package:</p> <ul> <li>Common attack patterns</li> <li>SQL injection patterns</li> <li>XSS patterns</li> <li>Path traversal patterns</li> <li>Command injection patterns</li> </ul>"},{"location":"api/sus-patterns/#custom-patterns","title":"Custom Patterns","text":"<p>Custom patterns are:</p> <ul> <li>Added at runtime via <code>add_pattern()</code></li> <li>Stored in memory and optionally in Redis</li> <li>Preserved across restarts when Redis is enabled</li> <li>Managed separately from default patterns</li> </ul>"},{"location":"api/sus-patterns/#redis-integration","title":"Redis Integration","text":"<p>When Redis is enabled:</p> <pre><code># Patterns are automatically synced to Redis\nawait sus_patterns_handler.add_pattern(r\"custom.*\", custom=True)\n\n# Retrieved on startup\npatterns = await redis_handler.get(\"custom_patterns\")\n</code></pre>"},{"location":"api/sus-patterns/#best-practices","title":"Best Practices","text":"<ol> <li>Pattern Design: Keep patterns specific to avoid false positives</li> <li>Performance: Monitor pattern execution times regularly</li> <li>Semantic Threshold: Start with default (0.7) and adjust based on false positives</li> <li>Custom Patterns: Test thoroughly before adding to production</li> <li>Monitoring: Use <code>get_performance_stats()</code> to identify problematic patterns</li> </ol>"},{"location":"api/sus-patterns/#error-handling","title":"Error Handling","text":"<p>The manager handles various error conditions gracefully: - Invalid regex patterns are logged and skipped - Component initialization failures fall back to basic detection - Pattern timeouts are logged and don't stop detection - Redis connection failures don't prevent operation</p>"},{"location":"api/sus-patterns/#thread-safety","title":"Thread Safety","text":"<p>The SusPatternsManager uses: - Thread-safe singleton pattern - Async-safe operations - Thread pool for pattern execution - Proper locking for pattern modifications</p>"},{"location":"api/utilities/","title":"Utilities","text":"<p>The <code>utils</code> module provides various helper functions for security operations.</p>"},{"location":"api/utilities/#logging-functions","title":"Logging Functions","text":""},{"location":"api/utilities/#setup_custom_logging","title":"setup_custom_logging","text":"<pre><code>def setup_custom_logging(\n    log_file: str | None = None\n) -&gt; logging.Logger:\n    \"\"\"\n    Setup custom logging for FastAPI Guard.\n\n    Configures a hierarchical logger that outputs to both console and file.\n    Console output is ALWAYS enabled for visibility.\n    File output is optional for persistence.\n\n    Args:\n        log_file: Optional path to log file. If None, only console output is enabled.\n                  If provided, creates the directory if it doesn't exist.\n\n    Returns:\n        logging.Logger: Configured logger with namespace \"fastapi_guard\"\n\n    Note: This function is synchronous (not async).\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#log_activity","title":"log_activity","text":"<pre><code>async def log_activity(\n    request: Request,\n    logger: logging.Logger,\n    log_type: str = \"request\",\n    reason: str = \"\",\n    passive_mode: bool = False,\n    trigger_info: str = \"\",\n    level: Literal[\"INFO\", \"DEBUG\", \"WARNING\", \"ERROR\", \"CRITICAL\"] | None = \"WARNING\"\n):\n    \"\"\"\n    Universal logging function for all types of requests and activities.\n    \"\"\"\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code>: The FastAPI request object</li> <li><code>logger</code>: The logger instance</li> <li><code>log_type</code>: Type of log entry (default: \"request\", can also be \"suspicious\")</li> <li><code>reason</code>: Reason for flagging an activity</li> <li><code>passive_mode</code>: Whether to enable passive mode logging format</li> <li><code>trigger_info</code>: Details about what triggered detection</li> <li><code>level</code>: The logging level to use. If <code>None</code>, logging is disabled. Defaults to \"WARNING\".</li> </ul> <p>This is a unified logging function that handles regular requests, suspicious activities, and passive mode logging.</p>"},{"location":"api/utilities/#security-check-functions","title":"Security Check Functions","text":""},{"location":"api/utilities/#is_user_agent_allowed","title":"is_user_agent_allowed","text":"<pre><code>async def is_user_agent_allowed(\n    user_agent: str,\n    config: SecurityConfig\n) -&gt; bool:\n    \"\"\"\n    Check if user agent is allowed.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#check_ip_country","title":"check_ip_country","text":"<pre><code>async def check_ip_country(\n    request: str | Request,\n    config: SecurityConfig,\n    ipinfo_db: IPInfoManager\n) -&gt; bool:\n    \"\"\"\n    Check if IP is from a blocked country.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#is_ip_allowed","title":"is_ip_allowed","text":"<pre><code>async def is_ip_allowed(\n    ip: str,\n    config: SecurityConfig,\n    ipinfo_db: IPInfoManager | None = None\n) -&gt; bool:\n    \"\"\"\n    Check if IP address is allowed.\n    \"\"\"\n</code></pre> <p>The <code>ipinfo_db</code> parameter is now properly optional - it's only needed when country filtering is configured. If it's not provided when country filtering is configured, the function will work correctly but won't apply country filtering rules rules.</p> <p>This function intelligently handles:</p> <ul> <li>Whitelist/blacklist checking</li> <li>Country filtering (only when IPInfoManager is provided)</li> <li>Cloud provider detection (only when cloud blocking is configured)</li> </ul> <p>This selective processing aligns with FastAPI Guard's smart resource loading to optimize performance.</p>"},{"location":"api/utilities/#detect_penetration_attempt","title":"detect_penetration_attempt","text":"<pre><code>async def detect_penetration_attempt(\n    request: Request,\n) -&gt; tuple[bool, str]\n</code></pre> <p>Detect potential penetration attempts in the request using the enhanced Detection Engine.</p> <p>This function analyzes various parts of the request (query params, body, path, headers) using the Detection Engine's components including pattern matching, semantic analysis, and performance monitoring.</p> <p>Parameters:</p> <ul> <li><code>request</code>: The FastAPI request object to analyze</li> </ul> <p>Returns a tuple where:</p> <ul> <li>First element is a boolean: <code>True</code> if a potential attack is detected, <code>False</code> otherwise</li> <li>Second element is a string with details about what triggered the detection, or empty string if no attack detected</li> </ul> <p>The Detection Engine provides: - Timeout-protected pattern matching (configured via <code>detection_compiler_timeout</code> in SecurityConfig) - Intelligent content preprocessing that preserves attack patterns - Semantic analysis for obfuscated attacks (when enabled) - Performance monitoring for pattern effectiveness</p> <p>Example usage:</p> <pre><code>from fastapi import Request\nfrom guard.utils import detect_penetration_attempt\n\n@app.post(\"/api/submit\")\nasync def submit_data(request: Request):\n    # Detection uses configuration from SecurityConfig\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    if is_suspicious:\n        # Log the detection with details\n        logger.warning(f\"Attack detected: {trigger_info}\")\n        return {\"error\": \"Suspicious activity detected\"}\n    return {\"success\": True}\n\n@app.post(\"/api/critical\")\nasync def critical_endpoint(request: Request):\n    # Timeout protection is configured via SecurityConfig.detection_compiler_timeout\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    if is_suspicious:\n        return {\"error\": \"Security check failed\"}\n    return {\"success\": True}\n</code></pre>"},{"location":"api/utilities/#extract_client_ip","title":"extract_client_ip","text":"<pre><code>def extract_client_ip(request: Request, config: SecurityConfig) -&gt; str:\n    \"\"\"\n    Securely extract the client IP address from the request, considering trusted proxies.\n\n    This function implements a secure approach to IP extraction that protects against\n    X-Forwarded-For header injection attacks.\n    \"\"\"\n</code></pre> <p>This function provides a secure way to extract client IPs by:</p> <ol> <li>Only trusting X-Forwarded-For headers from configured trusted proxies</li> <li>Using the connecting IP when not from a trusted proxy</li> <li>Properly handling proxy chains based on configured depth</li> </ol>"},{"location":"api/utilities/#usage-examples","title":"Usage Examples","text":"<pre><code>from guard.utils import (\n    setup_custom_logging,\n    log_activity,\n    detect_penetration_attempt\n)\n\n# Setup logging (synchronous function)\n# Console only\nlogger = setup_custom_logging()  # or setup_custom_logging(None)\n\n# Console + file\nlogger = setup_custom_logging(\"security.log\")\n\n# Log regular request\nawait log_activity(request, logger)\n\n# Log suspicious activity\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"Suspicious pattern detected\"\n)\n\n# Check for penetration attempts\nis_suspicious, trigger_info = await detect_penetration_attempt(request)\n</code></pre>"},{"location":"tutorial/advanced-customizations/","title":"Advanced Customization","text":"<p>FastAPI Guard uses a protocol-based architecture that makes it highly extensible. This guide explains how the protocol system works and how to create custom implementations.</p>"},{"location":"tutorial/advanced-customizations/#protocol-based-architecture","title":"Protocol-Based Architecture","text":"<p>FastAPI Guard uses Python's Protocol system to define interfaces that components must implement. This allows you to:</p> <ol> <li>Replace built-in handlers with custom implementations</li> <li>Extend functionality without modifying the core library</li> <li>Better separate concerns in your codebase</li> </ol>"},{"location":"tutorial/advanced-customizations/#why-protocols","title":"Why Protocols?","text":"<p>The protocol system solves several important problems:</p> <ol> <li>Avoiding dependency on third-party services: You can replace the built-in IPInfo geo-location with your own service</li> <li>Preventing circular imports: The protocols help break dependency cycles in the codebase</li> <li>Enabling extension points: Clear interfaces for adding custom functionality</li> </ol>"},{"location":"tutorial/advanced-customizations/#available-protocols","title":"Available Protocols","text":""},{"location":"tutorial/advanced-customizations/#geoiphandler-protocol","title":"GeoIPHandler Protocol","text":"<p>The <code>GeoIPHandler</code> protocol defines the interface for any geographical IP handler:</p> <pre><code>@runtime_checkable\nclass GeoIPHandler(Protocol):\n    \"\"\"Protocol for geographical IP handler.\"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool: ...\n\n    async def initialize(self) -&gt; None: ...\n\n    async def initialize_redis(self, redis_handler: RedisHandlerProtocol) -&gt; None: ...\n\n    def get_country(self, ip: str) -&gt; str | None: ...\n</code></pre>"},{"location":"tutorial/advanced-customizations/#method-details","title":"Method Details","text":"<ul> <li><code>is_initialized</code>: Should return whether the handler is ready to use</li> <li><code>initialize()</code>: Should set up the handler (load databases, connect to APIs, etc.)</li> <li><code>initialize_redis()</code>: Should store the redis handler for optional caching</li> <li><code>get_country()</code>: Should return the ISO 3166-1 alpha-2 country code for the IP</li> </ul>"},{"location":"tutorial/advanced-customizations/#redishandlerprotocol","title":"RedisHandlerProtocol","text":"<p>IMPORTANT: Users do NOT need to implement this protocol. It exists purely for internal use to break dependency cycles and define what the Redis handler must support for the custom GeoIP handlers.</p> <pre><code>@runtime_checkable\nclass RedisHandlerProtocol(Protocol):\n    \"\"\"Protocol for Redis handlers.\"\"\"\n\n    async def get_key(self, namespace: str, key: str) -&gt; Any: ...\n\n    async def set_key(\n        self, namespace: str, key: str, value: Any, ttl: int | None = None\n    ) -&gt; bool | None: ...\n\n    def get_connection(self) -&gt; AsyncContextManager[Redis]: ...\n\n    async def initialize(self) -&gt; None: ...\n</code></pre>"},{"location":"tutorial/advanced-customizations/#how-protocols-are-used","title":"How Protocols Are Used","text":"<p>The FastAPI Guard initialization flow works like this:</p> <ol> <li>You create a <code>SecurityConfig</code> with your custom <code>geo_ip_handler</code></li> <li>You add the <code>SecurityMiddleware</code> with this config</li> <li>When the middleware initializes, it:</li> <li>Checks if you provided a <code>geo_ip_handler</code> that implements the protocol</li> <li>If Redis is enabled, it passes its internal <code>RedisManager</code> to your handler</li> <li>Your handler can use this Redis connection for caching or whatever you need</li> </ol> <p>This makes your custom geo IP handler fully integrated with the middleware's Redis infrastructure.</p>"},{"location":"tutorial/advanced-customizations/#implementation-examples","title":"Implementation Examples","text":""},{"location":"tutorial/advanced-customizations/#example-custom-geo-ip-service","title":"Example: Custom Geo IP Service","text":"<p>Here's a complete example of a custom GeoIPHandler implementation that uses a different service:</p> <pre><code>from guard.protocols.geo_ip_protocol import GeoIPHandler\nfrom guard.protocols.redis_protocol import RedisHandlerProtocol\n\nclass CustomGeoIPHandler:\n    \"\"\"Custom handler using Custom GeoIP database\"\"\"\n\n    def __init__(self, license_key: str, db_path: str = \"CustomGeoIP.mmdb\"):\n        self._initialized = False\n        self.license_key = license_key\n        self.db_path = db_path\n        self.reader = None\n        self.redis = None  # Will store the FastAPI Guard's Redis handler\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        return self.reader is not None\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Initialize by downloading or loading the Custom GeoIP database\"\"\"\n        import os\n        import somelibrary\n\n        # Check if we have a cached copy in Redis\n        if self.redis:\n            cached_db = await self.redis.get_key(\"custom\", \"database\")\n            if cached_db:\n                with open(self.db_path, \"wb\") as f:\n                    f.write(cached_db if isinstance(cached_db, bytes)\n                            else cached_db.encode(\"latin-1\"))\n                self.reader = somelibrary.Reader(self.db_path)\n                self._initialized = True\n                return\n\n        # Download if needed (simplified - in a real app, use your API)\n        if not os.path.exists(self.db_path):\n            # Custom code to download database using license_key\n            pass\n\n        # Open the database\n        if os.path.exists(self.db_path):\n            self.reader = somelibrary.Reader(self.db_path)\n            self._initialized = True\n\n    async def initialize_redis(self, redis_handler: RedisHandlerProtocol) -&gt; None:\n        \"\"\"Store Redis handler and initialize\"\"\"\n        self.redis = redis_handler  # Store the Redis handler provided by FastAPI Guard\n        await self.initialize()\n\n    def get_country(self, ip: str) -&gt; str | None:\n        \"\"\"Get country code from IP using Custom GeoIP database\"\"\"\n        if not self.reader:\n            raise RuntimeError(\"Database not initialized\")\n\n        try:\n            response = self.reader.country(ip)\n            return response.country.iso_code\n        except Exception:\n            return None\n</code></pre>"},{"location":"tutorial/advanced-customizations/#usage-in-application","title":"Usage in Application","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom your_custom_module import CustomGeoIPHandler\n\napp = FastAPI()\n\n# Use custom handler instead of default IPInfoManager\nconfig = SecurityConfig(\n    geo_ip_handler=CustomGeoIPHandler(args),\n    blocked_countries=[\"CN\", \"RU\"],\n    # Other configuration...\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/advanced-customizations/#technical-details-how-redis-integration-works","title":"Technical Details: How Redis Integration Works","text":"<p>When you create a custom GeoIPHandler:</p> <ol> <li>FastAPI Guard's middleware will call your handler's <code>initialize_redis()</code> method</li> <li>It passes its internal <code>RedisManager</code> to your handler</li> <li>Your handler can store this manager and use it for caching</li> </ol> <p>You don't need to: - Create your own Redis connection - Implement RedisHandlerProtocol - Manage Redis connection pools</p> <p>The built-in RedisManager handles all of this for you.</p> <p>When a GeoIPHandler implementation receives a Redis handler in <code>initialize_redis()</code>, it can use it to:</p> <ol> <li>Cache lookup results to improve performance</li> <li>Store database files across application restarts</li> <li>Share state across multiple application instances</li> </ol> <p>The Redis handler provides these key methods:</p> <pre><code># Store a value with optional TTL\nawait redis_handler.set_key(\"namespace\", \"key\", \"value\", ttl=3600)\n\n# Retrieve a value\nvalue = await redis_handler.get_key(\"namespace\", \"key\")\n\n# Use the connection directly (advanced)\nasync with redis_handler.get_connection() as conn:\n    # Direct Redis operations\n    pass\n</code></pre> <p>Remember: You don't implement the RedisHandlerProtocol yourself - FastAPI Guard provides its built-in RedisManager which meets this protocol and is automatically passed to your custom GeoIPHandler.</p>"},{"location":"tutorial/first-steps/","title":"First Steps","text":"<p>Let's start with a simple example that shows how to add FastAPI Guard to your application.</p>"},{"location":"tutorial/first-steps/#create-a-fastapi-application","title":"Create a FastAPI application","text":"<p>First, create a new FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n</code></pre>"},{"location":"tutorial/first-steps/#configure-security-settings","title":"Configure Security Settings","text":"<p>Create a <code>SecurityConfig</code> instance with your desired settings:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required for geolocation\n    db_path=\"data/ipinfo/country_asn.mmdb\",  # Optional, default: ./data/ipinfo/country_asn.mmdb\n    enable_redis=True,  # Enable Redis integration\n    redis_url=\"redis://localhost:6379\",  # Redis URL\n    rate_limit=100,  # Max requests per minute\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    custom_log_file=\"security.log\"  # Custom log file\n)\n</code></pre> <p>Note: FastAPI Guard only loads resources as needed. The IPInfo database is only downloaded when country filtering is configured, and cloud IP ranges are only fetched when cloud provider blocking is enabled.</p>"},{"location":"tutorial/first-steps/#add-the-middleware","title":"Add the Middleware","text":"<p>Add the security middleware to your application:</p> <pre><code>app.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/first-steps/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing basic usage:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),\n    enable_redis=True,  # Redis enabled\n    redis_url=\"redis://localhost:6379\",\n    whitelist=[\"192.168.1.1\", \"2001:db8::1\"],\n    blacklist=[\"10.0.0.1\", \"2001:db8::2\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    rate_limit=100,\n    custom_log_file=\"security.log\"\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"tutorial/first-steps/#run-the-application","title":"Run the Application","text":"<p>Run your application using uvicorn:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Your API is now protected by FastAPI Guard! \ud83d\udee1\ufe0f</p>"},{"location":"tutorial/first-steps/#whats-next","title":"What's Next","text":"<ul> <li>Learn about IP Management</li> <li>Configure Rate Limiting</li> <li>Set up Penetration Detection</li> <li>Learn about Redis Integration</li> </ul>"},{"location":"tutorial/configuration/cors/","title":"CORS Configuration","text":"<p>FastAPI Guard provides comprehensive CORS (Cross-Origin Resource Sharing) configuration options.</p>"},{"location":"tutorial/configuration/cors/#basic-cors-setup","title":"Basic CORS Setup","text":"<p>Enable CORS with default settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\"*\"]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#advanced-configuration","title":"Advanced Configuration","text":"<p>Configure specific CORS settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://example.com\",\n        \"https://api.example.com\"\n    ],\n    cors_allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    cors_allow_headers=[\"*\"],\n    cors_allow_credentials=True,\n    cors_expose_headers=[\"X-Custom-Header\"],\n    cors_max_age=600\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#origin-patterns","title":"Origin Patterns","text":"<p>Use patterns to match multiple origins:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://*.example.com\",\n        \"https://*.api.example.com\"\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#credentials-support","title":"Credentials Support","text":"<p>Enable credentials support for authenticated requests:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_credentials=True,\n    cors_allow_origins=[\n        \"https://app.example.com\"  # Must be specific origin when using credentials\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#custom-headers","title":"Custom Headers","text":"<p>Configure custom headers for CORS:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_headers=[\n        \"Authorization\",\n        \"Content-Type\",\n        \"X-Custom-Header\"\n    ],\n    cors_expose_headers=[\n        \"X-Custom-Response-Header\"\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/logging/","title":"Logging Configuration","text":"<p>FastAPI Guard includes powerful logging capabilities to help you monitor and track security-related events in your application.</p>"},{"location":"tutorial/configuration/logging/#basic-logging-setup","title":"Basic Logging Setup","text":"<p>FastAPI Guard uses a hierarchical logging namespace (<code>fastapi_guard</code>) with automatic console output and optional file logging:</p> <pre><code>config = SecurityConfig(\n    # Optional: Enable file logging by providing a path\n    custom_log_file=\"security.log\"  # Creates file + console output\n    # OR\n    # custom_log_file=None  # Console output only (default)\n)\n</code></pre> <p>Key Features:</p> <ul> <li>Console output is always enabled for visibility</li> <li>File logging is optional and only enabled when <code>custom_log_file</code> is set</li> <li>All FastAPI Guard components use the <code>fastapi_guard.*</code> namespace</li> </ul>"},{"location":"tutorial/configuration/logging/#configurable-log-levels","title":"Configurable Log Levels","text":"<p>FastAPI Guard supports different log levels for normal and suspicious requests:</p> <pre><code>config = SecurityConfig(\n    # Log normal requests as INFO (or set to None to disable)\n    log_request_level=\"INFO\",\n    # Log suspicious activity as WARNING\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre> <p>Available log levels:</p> <ul> <li><code>\"INFO\"</code>: Informational messages</li> <li><code>\"DEBUG\"</code>: Detailed debug information</li> <li><code>\"WARNING\"</code>: Warning messages (default for suspicious activity)</li> <li><code>\"ERROR\"</code>: Error conditions</li> <li><code>\"CRITICAL\"</code>: Critical errors</li> <li><code>None</code>: Disable logging completely</li> </ul>"},{"location":"tutorial/configuration/logging/#performance-optimization","title":"Performance Optimization","text":"<p>For high-traffic production environments, consider disabling normal request logging:</p> <pre><code>config = SecurityConfig(\n    # Disable normal request logging (default)\n    log_request_level=None,\n    # Keep security event logging enabled\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#custom-logger","title":"Custom Logger","text":"<p>The <code>setup_custom_logging</code> function is automatically called by the middleware during initialization:</p> <pre><code>from guard.utils import setup_custom_logging\n\n# Manual setup (if needed outside of middleware)\n# Console only (no file)\nlogger = setup_custom_logging(None)\n\n# Console + file logging\nlogger = setup_custom_logging(\"security.log\")\n\n# The logger uses the \"fastapi_guard\" namespace\n# All handlers automatically use sub-namespaces like:\n# - \"fastapi_guard.handlers.redis\"\n# - \"fastapi_guard.handlers.cloud\"\n# - \"fastapi_guard.handlers.ipban\"\n</code></pre> <p>Note: The function is synchronous (not async) and handles directory creation automatically.</p>"},{"location":"tutorial/configuration/logging/#logging","title":"Logging","text":"<p>FastAPI Guard uses a unified logging approach with the <code>log_activity</code> function that handles different types of log events:</p> <pre><code>from guard.utils import log_activity\n\n# Log a regular request\nawait log_activity(request, logger)\n\n# Log suspicious activity\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"Suspicious IP address detected\"\n)\n\n# Log penetration attempt in passive mode\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"SQL injection attempt detected\",\n    passive_mode=True,\n    trigger_info=\"Detected pattern: ' OR 1=1 --\"\n)\n\n# Log with specific level\nawait log_activity(\n    request,\n    logger,\n    level=\"ERROR\",\n    reason=\"Authentication failure\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#logging-parameters","title":"Logging Parameters","text":"<p>The <code>log_activity</code> function accepts the following parameters:</p> <ul> <li><code>request</code>: The FastAPI request object</li> <li><code>logger</code>: The logger instance to use</li> <li><code>log_type</code>: Type of log entry (default: \"request\", can also be \"suspicious\")</li> <li><code>reason</code>: Reason for flagging an activity</li> <li><code>passive_mode</code>: Whether to format log as passive mode detection</li> <li><code>trigger_info</code>: Details about what triggered detection</li> <li><code>level</code>: The logging level to use. If <code>None</code>, logging is disabled. Defaults to \"WARNING\".</li> </ul>"},{"location":"tutorial/configuration/logging/#logger-namespace-hierarchy","title":"Logger Namespace Hierarchy","text":"<p>FastAPI Guard uses a hierarchical namespace structure for organized logging:</p> <pre><code>fastapi_guard                    # Root logger for all FastAPI Guard components\n\u251c\u2500\u2500 fastapi_guard.handlers       # Handler components\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.redis\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.cloud\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.ipinfo\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.ipban\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.ratelimit\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.behavior\n\u2502   \u251c\u2500\u2500 fastapi_guard.handlers.suspatterns\n\u2502   \u2514\u2500\u2500 fastapi_guard.handlers.dynamic_rule\n\u251c\u2500\u2500 fastapi_guard.decorators     # Decorator components\n\u2502   \u2514\u2500\u2500 fastapi_guard.decorators.base\n\u2514\u2500\u2500 fastapi_guard.detection_engine  # Detection engine components\n</code></pre> <p>This namespace isolation ensures: - FastAPI Guard logs are separate from your application logs - You can configure log levels for specific components - Test frameworks can capture logs via propagation - No interference with user-defined loggers</p>"},{"location":"tutorial/configuration/logging/#log-format","title":"Log Format","text":"<p>By default, logs include the following information:</p> <ul> <li>Timestamp</li> <li>Logger name (showing the component namespace)</li> <li>Log level</li> <li>Client IP address</li> <li>HTTP method</li> <li>Request path</li> <li>Request headers</li> <li>Request body (if available)</li> <li>Reason for logging (for suspicious activities)</li> <li>Detection trigger details (for penetration attempts)</li> </ul>"},{"location":"tutorial/configuration/logging/#complete-examples","title":"Complete Examples","text":""},{"location":"tutorial/configuration/logging/#example-1-production-setup-with-file-logging","title":"Example 1: Production Setup with File Logging","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Production configuration\nconfig = SecurityConfig(\n    # File + console logging for audit trail\n    custom_log_file=\"/var/log/fastapi-guard/security.log\",\n\n    # Disable normal request logging to reduce noise\n    log_request_level=None,\n\n    # Keep security events at WARNING level\n    log_suspicious_level=\"WARNING\",\n\n    # Other security settings...\n    enable_redis=True,\n    enable_penetration_detection=True,\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/configuration/logging/#example-2-development-setup-with-console-only","title":"Example 2: Development Setup with Console Only","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\napp = FastAPI()\n\n# Development configuration\nconfig = SecurityConfig(\n    # Console-only output for development\n    custom_log_file=None,  # No file logging\n\n    # Enable all logging for debugging\n    log_request_level=\"INFO\",\n    log_suspicious_level=\"WARNING\",\n\n    # Other settings...\n    passive_mode=True,  # Log-only mode for testing\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/configuration/logging/#example-3-custom-component-level-configuration","title":"Example 3: Custom Component-Level Configuration","text":"<pre><code>import logging\nfrom guard import SecurityConfig\n\n# Configure specific component log levels\nlogging.getLogger(\"fastapi_guard.handlers.redis\").setLevel(logging.DEBUG)\nlogging.getLogger(\"fastapi_guard.handlers.ipban\").setLevel(logging.INFO)\nlogging.getLogger(\"fastapi_guard.detection_engine\").setLevel(logging.WARNING)\n\n# This works because FastAPI Guard uses hierarchical namespaces\nconfig = SecurityConfig(\n    custom_log_file=\"security.log\",\n    # ... other settings\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#example-4-integration-with-application-logging","title":"Example 4: Integration with Application Logging","text":"<pre><code>import logging\nfrom fastapi import FastAPI\nfrom guard import SecurityConfig, SecurityMiddleware\n\n# Configure your application logging\napp_logger = logging.getLogger(\"myapp\")\napp_logger.setLevel(logging.INFO)\n\n# FastAPI Guard logs are isolated under \"fastapi_guard\" namespace\n# No interference with your app logs\napp = FastAPI()\n\nconfig = SecurityConfig(\n    custom_log_file=\"security.log\",  # Separate security log file\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n# Your app logs and FastAPI Guard logs remain separate\napp_logger.info(\"Application started\")  # Goes to \"myapp\" logger\n# Security events go to \"fastapi_guard\" logger\n</code></pre>"},{"location":"tutorial/configuration/security-config/","title":"Security Configuration","text":"<p>FastAPI Guard uses Pydantic models for configuration and data structures.</p>"},{"location":"tutorial/configuration/security-config/#securityconfig","title":"SecurityConfig","text":"<p>The main configuration model for FastAPI Guard middleware.</p> <pre><code>class SecurityConfig(BaseSettings):\n    \"\"\"\n    Main configuration model for FastAPI Guard.\n    All settings can be configured via environment variables with FASTAPI_GUARD_ prefix.\n    \"\"\"\n</code></pre>"},{"location":"tutorial/configuration/security-config/#core-security-settings","title":"Core Security Settings","text":"Field Type Default Description <code>enabled</code> bool True Enable/disable the middleware <code>passive_mode</code> bool False If True, only log without blocking <code>enable_penetration_detection</code> bool True Enable penetration attempt detection <code>auto_ban_threshold</code> int 5 Number of suspicious requests before auto-ban <code>auto_ban_duration</code> int 3600 Auto-ban duration in seconds"},{"location":"tutorial/configuration/security-config/#detection-engine-settings","title":"Detection Engine Settings","text":"<p>New configuration fields for the enhanced Detection Engine:</p> Field Type Default Description <code>detection_compiler_timeout</code> float 2.0 Timeout for pattern compilation and execution (seconds) <code>detection_max_content_length</code> int 10000 Maximum content length to analyze <code>detection_preserve_attack_patterns</code> bool True Preserve attack patterns during content truncation <code>detection_semantic_threshold</code> float 0.7 Minimum threat score for semantic detection (0.0-1.0) <code>detection_anomaly_threshold</code> float 3.0 Standard deviations to consider performance anomaly <code>detection_slow_pattern_threshold</code> float 0.1 Execution time to consider pattern slow (seconds) <code>detection_monitor_history_size</code> int 1000 Number of performance metrics to keep in history <code>detection_max_tracked_patterns</code> int 1000 Maximum patterns to track for performance"},{"location":"tutorial/configuration/security-config/#ip-management-settings","title":"IP Management Settings","text":"Field Type Default Description <code>trusted_ips</code> list[str] [] List of always-allowed IP addresses <code>blocked_ips</code> list[str] [] List of always-blocked IP addresses <code>blocked_countries</code> list[str] [] List of blocked country codes <code>blocked_user_agents</code> list[str] [] List of blocked user agent patterns <code>trusted_hosts</code> list[str] [\"*\"] List of allowed host headers <code>real_ip_header</code> str None Header containing real IP (e.g., 'X-Forwarded-For') <code>global_rate_limit</code> str \"5000/hour\" Global rate limit for all requests"},{"location":"tutorial/configuration/security-config/#redis-settings","title":"Redis Settings","text":"Field Type Default Description <code>use_redis</code> bool False Enable Redis integration <code>redis_host</code> str \"localhost\" Redis server hostname <code>redis_port</code> int 6379 Redis server port <code>redis_password</code> str None Redis password <code>redis_db</code> int 0 Redis database number <code>redis_ssl</code> bool False Use SSL for Redis connection <code>redis_pool_size</code> int 10 Connection pool size <code>redis_ttl</code> int 86400 Default TTL for Redis keys (seconds)"},{"location":"tutorial/configuration/security-config/#agent-settings","title":"Agent Settings","text":"Field Type Default Description <code>enable_agent</code> bool False Enable FastAPI Guard Agent integration <code>agent_api_key</code> str None API key for agent authentication <code>agent_api_base_url</code> str \"https://api.fastapiguard.com/v1/agent\" Agent API endpoint <code>agent_enable_events</code> bool True Send events to agent <code>agent_enable_metrics</code> bool True Send metrics to agent <code>agent_send_interval</code> int 60 Metric sending interval (seconds)"},{"location":"tutorial/configuration/security-config/#cloud-provider-settings","title":"Cloud Provider Settings","text":"Field Type Default Description <code>ipinfo_token</code> str None IPInfo API token for geolocation <code>block_cloud_providers</code> dict {} Cloud providers to block <code>cloud_provider_cache_ttl</code> int 86400 Cache TTL for cloud provider data"},{"location":"tutorial/configuration/security-config/#security-headers-settings","title":"Security Headers Settings","text":"Field Type Default Description <code>security_headers</code> dict[str, Any] See below Security headers configuration <p>Default security_headers configuration:</p> <pre><code>{\n    \"enabled\": True,\n    \"hsts\": {\n        \"max_age\": 31536000,  # 1 year\n        \"include_subdomains\": True,\n        \"preload\": False\n    },\n    \"csp\": None,  # Content Security Policy directives\n    \"frame_options\": \"SAMEORIGIN\",\n    \"content_type_options\": \"nosniff\",\n    \"xss_protection\": \"1; mode=block\",\n    \"referrer_policy\": \"strict-origin-when-cross-origin\",\n    \"permissions_policy\": \"geolocation=(), microphone=(), camera=()\",\n    \"custom\": None  # Additional custom headers\n}\n</code></pre> <p>The following additional security headers are now included by default:</p> <ul> <li><code>X-Permitted-Cross-Domain-Policies: none</code></li> <li><code>X-Download-Options: noopen</code></li> <li><code>Cross-Origin-Embedder-Policy: require-corp</code></li> <li><code>Cross-Origin-Opener-Policy: same-origin</code></li> <li><code>Cross-Origin-Resource-Policy: same-origin</code></li> </ul>"},{"location":"tutorial/configuration/security-config/#security-headers-sub-fields","title":"Security Headers Sub-fields","text":"Field Type Default Description <code>enabled</code> bool True Enable security headers <code>hsts.max_age</code> int 31536000 HSTS max-age in seconds <code>hsts.include_subdomains</code> bool True Include subdomains in HSTS <code>hsts.preload</code> bool False Enable HSTS preload <code>csp</code> dict[str, list[str]] None Content Security Policy directives <code>frame_options</code> str \"SAMEORIGIN\" X-Frame-Options value (DENY, SAMEORIGIN) <code>content_type_options</code> str \"nosniff\" X-Content-Type-Options value <code>xss_protection</code> str \"1; mode=block\" X-XSS-Protection value <code>referrer_policy</code> str \"strict-origin-when-cross-origin\" Referrer-Policy value <code>permissions_policy</code> str See default Permissions-Policy value <code>custom</code> dict[str, str] None Additional custom headers"},{"location":"tutorial/configuration/security-config/#cors-settings","title":"CORS Settings","text":"Field Type Default Description <code>cors_enabled</code> bool True Enable CORS handling <code>cors_origins</code> list[str] [\"*\"] Allowed origins <code>cors_methods</code> list[str] [\"*\"] Allowed methods <code>cors_headers</code> list[str] [\"*\"] Allowed headers <code>cors_credentials</code> bool False Allow credentials <code>cors_max_age</code> int 600 Preflight cache duration"},{"location":"tutorial/configuration/security-config/#logging-settings","title":"Logging Settings","text":"Field Type Default Description <code>log_enabled</code> bool True Enable request logging <code>log_level</code> str \"INFO\" Logging level <code>custom_log_file</code> str None Custom log file path <code>log_format</code> str \"default\" Log format (default, json) <code>mask_sensitive_data</code> bool True Mask sensitive data in logs"},{"location":"tutorial/configuration/security-config/#usage-example","title":"Usage Example","text":"<pre><code>from guard import SecurityConfig\n\n# Basic configuration\nconfig = SecurityConfig(\n    enable_penetration_detection=True,\n    auto_ban_threshold=5,\n    detection_semantic_threshold=0.7\n)\n\n# Full configuration\nconfig = SecurityConfig(\n    # Core settings\n    enabled=True,\n    passive_mode=False,\n\n    # Detection engine\n    enable_penetration_detection=True,\n    detection_compiler_timeout=2.0,\n    detection_max_content_length=10000,\n    detection_preserve_attack_patterns=True,\n    detection_semantic_threshold=0.7,\n    detection_anomaly_threshold=3.0,\n    detection_slow_pattern_threshold=0.1,\n    detection_monitor_history_size=1000,\n    detection_max_tracked_patterns=1000,\n\n    # Security headers\n    security_headers={\n        \"enabled\": True,\n        \"hsts\": {\n            \"max_age\": 31536000,  # 1 year\n            \"include_subdomains\": True,\n            \"preload\": False\n        },\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\", \"https://cdn.example.com\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n            \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n            \"connect-src\": [\"'self'\", \"https://api.example.com\"],\n            \"frame-ancestors\": [\"'none'\"],\n            \"base-uri\": [\"'self'\"],\n            \"form-action\": [\"'self'\"]\n        },\n        \"frame_options\": \"DENY\",\n        \"content_type_options\": \"nosniff\",\n        \"xss_protection\": \"1; mode=block\",\n        \"referrer_policy\": \"no-referrer\",\n        \"permissions_policy\": \"geolocation=(), microphone=(), camera=()\",\n        \"custom\": {\n            \"X-Custom-Header\": \"CustomValue\"\n        }\n    },\n\n    # Redis\n    use_redis=True,\n    redis_host=\"localhost\",\n    redis_port=6379,\n\n    # Agent\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n\n    # Logging\n    custom_log_file=\"security.log\",\n    log_level=\"WARNING\"\n)\n</code></pre>"},{"location":"tutorial/configuration/security-config/#environment-variables","title":"Environment Variables","text":"<p>All settings can be configured using environment variables with the <code>FASTAPI_GUARD_</code> prefix:</p> <pre><code>export FASTAPI_GUARD_ENABLED=true\nexport FASTAPI_GUARD_DETECTION_SEMANTIC_THRESHOLD=0.8\nexport FASTAPI_GUARD_REDIS_HOST=redis.example.com\nexport FASTAPI_GUARD_AGENT_API_KEY=your-api-key\n</code></pre>"},{"location":"tutorial/configuration/security-config/#other-models","title":"Other Models","text":""},{"location":"tutorial/configuration/security-config/#ipinfo","title":"IPInfo","text":"<pre><code>class IPInfo(BaseModel):\n    \"\"\"IP address information from geolocation service\"\"\"\n    ip: str\n    country: str | None = None\n    region: str | None = None\n    city: str | None = None\n    is_cloud: bool = False\n    cloud_provider: str | None = None\n</code></pre>"},{"location":"tutorial/configuration/security-config/#ratelimitstatus","title":"RateLimitStatus","text":"<pre><code>class RateLimitStatus(BaseModel):\n    \"\"\"Rate limit status for a client\"\"\"\n    allowed: bool\n    current_requests: int\n    limit: int\n    window_seconds: int\n    reset_time: datetime\n</code></pre>"},{"location":"tutorial/configuration/security-config/#threatdetectionresult","title":"ThreatDetectionResult","text":"<pre><code>class ThreatDetectionResult(TypedDict):\n    \"\"\"Result from detection engine analysis\"\"\"\n    is_threat: bool\n    threat_score: float\n    threats: list[dict[str, Any]]\n    context: str\n    original_length: int\n    processed_length: int\n    execution_time: float\n    detection_method: str\n    timeouts: list[str]\n    correlation_id: str | None\n</code></pre>"},{"location":"tutorial/configuration/security-config/#behaviorprofile","title":"BehaviorProfile","text":"<pre><code>class BehaviorProfile(BaseModel):\n    \"\"\"Client behavior profile for analysis\"\"\"\n    ip_address: str\n    request_count: int\n    suspicious_count: int\n    last_seen: datetime\n    user_agents: list[str]\n    paths_accessed: list[str]\n    methods_used: list[str]\n    risk_score: float\n</code></pre>"},{"location":"tutorial/configuration/security-config/#configuration-validation","title":"Configuration Validation","text":"<p>The SecurityConfig model validates settings on initialization:</p> <pre><code># Validation examples\ntry:\n    config = SecurityConfig(\n        detection_compiler_timeout=0.05  # Too low\n    )\nexcept ValidationError as e:\n    print(f\"Configuration error: {e}\")\n\n# Valid ranges\nconfig = SecurityConfig(\n    detection_compiler_timeout=2.0,      # 0.1 - 30.0\n    detection_semantic_threshold=0.7,    # 0.0 - 1.0\n    detection_anomaly_threshold=3.0,     # 1.0 - 10.0\n    auto_ban_threshold=5,                # 1 - 1000\n    auto_ban_duration=3600,              # 60 - 86400\n)\n</code></pre>"},{"location":"tutorial/configuration/security-config/#model-serialization","title":"Model Serialization","text":"<p>All models support standard Pydantic serialization:</p> <pre><code># Export configuration\nconfig_dict = config.dict(exclude_unset=True)\nconfig_json = config.json(indent=2)\n\n# Import configuration\nconfig = SecurityConfig.parse_obj(config_dict)\nconfig = SecurityConfig.parse_raw(config_json)\n\n# Schema generation\nschema = SecurityConfig.schema()\n</code></pre>"},{"location":"tutorial/configuration/security-config/#custom-validators","title":"Custom Validators","text":"<p>The models include custom validators for complex fields:</p> <pre><code>@validator(\"detection_semantic_threshold\")\ndef validate_threshold(cls, v):\n    if not 0.0 &lt;= v &lt;= 1.0:\n        raise ValueError(\"Threshold must be between 0.0 and 1.0\")\n    return v\n\n@validator(\"redis_host\")\ndef validate_redis_host(cls, v, values):\n    if values.get(\"use_redis\") and not v:\n        raise ValueError(\"Redis host required when use_redis is True\")\n    return v\n</code></pre>"},{"location":"tutorial/configuration/security-config/#see-also","title":"See Also","text":"<ul> <li>Security Middleware - Using SecurityConfig with middleware</li> <li>Detection Engine Configuration - Detailed configuration guide</li> <li>Logging Configuration - Logging configuration</li> <li>CORS Configuration - CORS configuration</li> </ul>"},{"location":"tutorial/decorators/access-control/","title":"Access Control Decorators","text":"<p>Access control decorators allow you to restrict access to specific endpoints based on IP addresses, geographic location, and cloud providers. These decorators provide fine-grained control over who can access your routes.</p>"},{"location":"tutorial/decorators/access-control/#ip-address-filtering","title":"IP Address Filtering","text":"<p>Control access based on specific IP addresses or CIDR ranges:</p>"},{"location":"tutorial/decorators/access-control/#ip-whitelist","title":". IP Whitelist","text":"<p>Only allow access from specific IP addresses:</p> <pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/internal\")\n@guard_deco.require_ip(whitelist=[\"192.168.1.0/24\", \"10.0.0.1\"])\ndef internal_endpoint():\n    return {\"message\": \"Internal network access only\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#ip-blacklist","title":". IP Blacklist","text":"<p>Block specific IP addresses while allowing others:</p> <pre><code>@app.get(\"/api/public\")\n@guard_deco.require_ip(blacklist=[\"203.0.113.0/24\", \"198.51.100.1\"])\ndef public_endpoint():\n    return {\"message\": \"Public access except blocked IPs\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#combined-ip-rules","title":". Combined IP Rules","text":"<p>Use both whitelist and blacklist together:</p> <pre><code>@app.get(\"/api/restricted\")\n@guard_deco.require_ip(\n    whitelist=[\"192.168.0.0/16\"],  # Allow internal network\n    blacklist=[\"192.168.1.100\"]    # Except this specific IP\n)\ndef restricted_endpoint():\n    return {\"data\": \"Carefully controlled access\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#geographic-restrictions","title":"Geographic Restrictions","text":"<p>Control access based on user's country location:</p>"},{"location":"tutorial/decorators/access-control/#block-specific-countries","title":". Block Specific Countries","text":"<p>Prevent access from certain countries:</p> <pre><code>@app.get(\"/api/compliance-sensitive\")\n@guard_deco.block_countries([\"CN\", \"RU\", \"IR\", \"KP\"])\ndef compliance_endpoint():\n    return {\"data\": \"Compliance-restricted content\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#allow-only-specific-countries","title":". Allow Only Specific Countries","text":"<p>Restrict access to certain countries only:</p> <pre><code>@app.get(\"/api/us-only\")\n@guard_deco.allow_countries([\"US\"])\ndef us_only_endpoint():\n    return {\"data\": \"US-only content\"}\n\n@app.get(\"/api/eu-only\")\n@guard_deco.allow_countries([\"GB\", \"DE\", \"FR\", \"IT\", \"ES\", \"NL\"])\ndef eu_only_endpoint():\n    return {\"data\": \"EU-only content\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#regional-access","title":". Regional Access","text":"<p>Create region-specific endpoints:</p> <pre><code>@app.get(\"/api/north-america\")\n@guard_deco.allow_countries([\"US\", \"CA\", \"MX\"])\ndef north_america_endpoint():\n    return {\"data\": \"North America region\"}\n\n@app.get(\"/api/asia-pacific\")\n@guard_deco.allow_countries([\"JP\", \"KR\", \"AU\", \"SG\", \"IN\"])\ndef asia_pacific_endpoint():\n    return {\"data\": \"Asia-Pacific region\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#cloud-provider-blocking","title":"Cloud Provider Blocking","text":"<p>Block requests originating from cloud provider IP ranges:</p>"},{"location":"tutorial/decorators/access-control/#block-specific-cloud-providers","title":". Block Specific Cloud Providers","text":"<pre><code>@app.get(\"/api/no-clouds\")\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])\ndef no_clouds_endpoint():\n    return {\"data\": \"No cloud provider access\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#block-all-major-cloud-providers","title":". Block All Major Cloud Providers","text":"<pre><code>@app.get(\"/api/residential-only\")\n@guard_deco.block_clouds([\"AWS\", \"GCP\", \"Azure\", \"DigitalOcean\", \"Cloudflare\"])\ndef residential_only_endpoint():\n    return {\"data\": \"Residential IP addresses only\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#block-all-supported-clouds","title":". Block All Supported Clouds","text":"<pre><code>@app.get(\"/api/anti-automation\")\n@guard_deco.block_clouds()  # Blocks all supported cloud providers\ndef anti_automation_endpoint():\n    return {\"data\": \"No automated/cloud access\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#bypassing-security-checks","title":"Bypassing Security Checks","text":"<p>Selectively disable specific security checks for certain routes:</p>"},{"location":"tutorial/decorators/access-control/#bypass-specific-checks","title":". Bypass Specific Checks","text":"<pre><code>@app.get(\"/api/health\")\n@guard_deco.bypass([\"rate_limit\", \"ip\"])  # Bypass rate limiting and IP checks\ndef health_check():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#bypass-all-security","title":". Bypass All Security","text":"<pre><code>@app.get(\"/api/public-health\")\n@guard_deco.bypass([\"all\"])  # Bypass all security checks\ndef public_health_check():\n    return {\"status\": \"public health endpoint\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#common-bypass-scenarios","title":". Common Bypass Scenarios","text":"<pre><code># Monitoring endpoint - bypass rate limits\n@app.get(\"/metrics\")\n@guard_deco.bypass([\"rate_limit\"])\ndef metrics():\n    return {\"metrics\": \"data\"}\n\n# Public API documentation - bypass geographic restrictions\n@app.get(\"/docs-public\")\n@guard_deco.bypass([\"countries\", \"clouds\"])\ndef public_docs():\n    return {\"docs\": \"public documentation\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#combining-access-controls","title":"Combining Access Controls","text":"<p>Stack multiple access control decorators for comprehensive protection:</p>"},{"location":"tutorial/decorators/access-control/#multi-layer-protection","title":". Multi-Layer Protection","text":"<pre><code>@app.post(\"/api/admin/sensitive\")\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])       # Internal network only\n@guard_deco.allow_countries([\"US\", \"CA\"])              # North America only\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])               # No cloud providers\ndef ultra_secure_endpoint():\n    return {\"data\": \"Maximum security endpoint\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#tiered-access-control","title":". Tiered Access Control","text":"<pre><code># High-security financial endpoint\n@app.post(\"/api/financial/transfer\")\n@guard_deco.require_ip(whitelist=[\"192.168.1.0/24\"])   # Company network only\n@guard_deco.allow_countries([\"US\"])                    # US jurisdiction only\n@guard_deco.block_clouds()                             # No cloud/automation\ndef financial_transfer():\n    return {\"status\": \"transfer initiated\"}\n\n# Medium-security user data\n@app.get(\"/api/user/profile\")\n@guard_deco.block_countries([\"CN\", \"RU\", \"IR\"])       # Block certain countries\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])              # Block major clouds\ndef user_profile():\n    return {\"profile\": \"user data\"}\n\n# Low-security public content\n@app.get(\"/api/public/content\")\n@guard_deco.block_clouds([\"DigitalOcean\"])            # Block only specific providers\ndef public_content():\n    return {\"content\": \"public information\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"tutorial/decorators/access-control/#geographic-failover","title":". Geographic Failover","text":"<p>Allow broader access if primary regions fail:</p> <pre><code>@app.get(\"/api/primary\")\n@guard_deco.allow_countries([\"US\", \"CA\"])\ndef primary_endpoint():\n    return {\"region\": \"primary\"}\n\n@app.get(\"/api/fallback\")\n@guard_deco.allow_countries([\"GB\", \"DE\", \"AU\"])\ndef fallback_endpoint():\n    return {\"region\": \"fallback\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#time-based-geographic-access","title":". Time-Based Geographic Access","text":"<p>Different geographic rules for different times:</p> <pre><code>from datetime import datetime\n\n# Business hours: strict geographic controls\n@app.get(\"/api/business-hours\")\n@guard_deco.allow_countries([\"US\"])\n@guard_deco.time_window(\"09:00\", \"17:00\", \"EST\")\ndef business_hours_endpoint():\n    return {\"data\": \"business hours access\"}\n\n# After hours: more lenient\n@app.get(\"/api/after-hours\")\n@guard_deco.allow_countries([\"US\", \"CA\", \"GB\"])\ndef after_hours_endpoint():\n    return {\"data\": \"after hours access\"}\n</code></pre>"},{"location":"tutorial/decorators/access-control/#error-handling","title":"Error Handling","text":"<p>Access control decorators return specific HTTP status codes:</p> <ul> <li>403 Forbidden: IP not in whitelist, IP in blacklist</li> <li>403 Forbidden: Country blocked or not in allowed list</li> <li>403 Forbidden: Cloud provider IP detected and blocked</li> </ul>"},{"location":"tutorial/decorators/access-control/#custom-error-messages","title":". Custom Error Messages","text":"<pre><code># The middleware will use custom error messages if configured\nconfig = SecurityConfig(\n    custom_error_responses={\n        403: \"Access denied: Geographic restrictions apply\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/access-control/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/access-control/#start-restrictive-then-open-up","title":". Start Restrictive, Then Open Up","text":"<p>Begin with strict controls and gradually relax as needed:</p> <pre><code># Start with company network only\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])\n\n# Then add specific external IPs\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\", \"203.0.113.100\"])\n\n# Finally add geographic controls\n@guard_deco.allow_countries([\"US\", \"CA\"])\n</code></pre>"},{"location":"tutorial/decorators/access-control/#layer-different-types-of-controls","title":". Layer Different Types of Controls","text":"<p>Combine IP, geographic, and cloud controls for defense in depth:</p> <pre><code>@guard_deco.require_ip(whitelist=[\"192.168.0.0/16\"])   # Internal network\n@guard_deco.allow_countries([\"US\"])                    # US only\n@guard_deco.block_clouds()                             # No automation\n</code></pre>"},{"location":"tutorial/decorators/access-control/#use-bypass-strategically","title":". Use Bypass Strategically","text":"<p>Only bypass security for truly public endpoints:</p> <pre><code># Good: Health checks need to work from monitoring systems\n@guard_deco.bypass([\"rate_limit\"])\n\n# Bad: Don't bypass security for sensitive data\n# @guard_deco.bypass([\"all\"])  # Avoid this for sensitive endpoints\n</code></pre>"},{"location":"tutorial/decorators/access-control/#test-geographic-controls","title":". Test Geographic Controls","text":"<p>Test with VPN connections from different countries to verify behavior:</p> <pre><code># Ensure your geographic controls work as expected\n@guard_deco.allow_countries([\"US\", \"CA\"])\n# Test: Connect via VPN from blocked country, should get 403\n</code></pre>"},{"location":"tutorial/decorators/access-control/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorial/decorators/access-control/#common-issues","title":". Common Issues","text":"<ol> <li>VPN/Proxy Detection: Users behind VPNs may be incorrectly geo-located</li> <li>Cloud Provider Classification: Some legitimate users may come from cloud IPs</li> <li>IP Range Conflicts: Overlapping whitelist/blacklist rules</li> </ol>"},{"location":"tutorial/decorators/access-control/#debugging-tips","title":". Debugging Tips","text":"<pre><code># Enable detailed logging to see why access was denied\nconfig = SecurityConfig(\n    log_suspicious_level=\"DEBUG\",\n    log_request_level=\"INFO\"\n)\n\n# Check logs for messages like:\n# \"IP not allowed by route config: 203.0.113.1\"\n# \"Blocked cloud provider IP: 54.239.28.85\"\n</code></pre>"},{"location":"tutorial/decorators/access-control/#next-steps","title":"Next Steps","text":"<p>Now that you understand access control decorators, explore other security features:</p> <ul> <li>Authentication Decorators - HTTPS and auth requirements</li> <li>Rate Limiting Decorators - Custom rate controls</li> <li>Behavioral Analysis - Monitor usage patterns</li> <li>Content Filtering - Request validation</li> </ul> <p>For complete API reference, see the Access Control API Documentation.</p>"},{"location":"tutorial/decorators/advanced/","title":"Advanced Security Decorators","text":"<p>Advanced security decorators offer sophisticated controls for fine-tuning your application's security posture. These decorators allow you to implement time-based access rules, set up honeypots to trap malicious bots, and control suspicious pattern detection on a per-route basis.</p>"},{"location":"tutorial/decorators/advanced/#time-based-access-control","title":"Time-Based Access Control","text":"<p>Restrict access to endpoints based on specific time windows. This is useful for APIs that should only be available during business hours or maintenance periods.</p>"},{"location":"tutorial/decorators/advanced/#restrict-to-business-hours","title":". Restrict to Business Hours","text":"<pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/reports\")\n@guard_deco.time_window(\"09:00\", \"17:00\", \"EST\")\ndef generate_reports():\n    return {\"message\": \"Reports are only available during business hours (9 AM - 5 PM EST)\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#maintenance-window","title":". Maintenance Window","text":"<p>Only allow access during a specific maintenance window.</p> <pre><code>@app.post(\"/api/maintenance\")\n@guard_deco.time_window(\"01:00\", \"03:00\", \"UTC\")\ndef perform_maintenance():\n    return {\"status\": \"Maintenance operations running\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#honeypot-protection","title":"Honeypot Protection","text":"<p>Set up \"honeypot\" fields in your forms or JSON payloads to detect and block bots. These fields are hidden from human users but are often filled out by automated scripts.</p>"},{"location":"tutorial/decorators/advanced/#basic-honeypot","title":". Basic Honeypot","text":"<p>Add a honeypot field to a registration form. If a bot fills it, access is denied.</p> <pre><code>@app.post(\"/register\")\n@guard_deco.honeypot_detection(trap_fields=[\"website_url\"])\ndef register_user(form_data: dict):\n    # This field should be hidden via CSS for real users\n    return {\"message\": \"User registered successfully\"}\n</code></pre> <p>In your frontend, you would hide the <code>website_url</code> field, for example, with <code>style=\"display:none\"</code>.</p>"},{"location":"tutorial/decorators/advanced/#multiple-honeypot-fields","title":". Multiple Honeypot Fields","text":"<p>Use multiple fields to increase the chances of trapping a bot.</p> <pre><code>@app.post(\"/contact\")\n@guard_deco.honeypot_detection(trap_fields=[\"comments\", \"phone_number_alt\"])\ndef contact_form(form_data: dict):\n    return {\"status\": \"Message sent\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#json-payload-honeypot","title":". JSON Payload Honeypot","text":"<p>Honeypots also work with JSON request bodies.</p> <pre><code>@app.post(\"/api/subscribe\")\n@guard_deco.honeypot_detection(trap_fields=[\"user_nickname\"])\ndef subscribe_newsletter(payload: dict):\n    return {\"message\": \"Subscribed successfully\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#suspicious-pattern-detection-control","title":"Suspicious Pattern Detection Control","text":"<p>Globally, FastAPI Guard may be configured to detect suspicious patterns in requests. This decorator allows you to override that setting for specific endpoints where the global rules may not be appropriate.</p>"},{"location":"tutorial/decorators/advanced/#disable-detection-for-a-specific-route","title":". Disable Detection for a Specific Route","text":"<p>If an endpoint accepts data that might trigger false positives (e.g., code snippets, complex user-generated content), you can disable suspicious pattern detection for it.</p> <pre><code>@app.post(\"/api/code-submission\")\n@guard_deco.suspicious_detection(enabled=False)\ndef submit_code(code: str):\n    # This endpoint is safe from pattern detection false positives\n    return {\"status\": \"Code submitted for review\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#explicitly-enable-detection","title":". Explicitly Enable Detection","text":"<p>While detection is often enabled by default, you can use this decorator to make it explicit, improving code readability.</p> <pre><code>@app.get(\"/api/search\")\n@guard_deco.suspicious_detection(enabled=True)\ndef search(query: str):\n    return {\"results\": \"Search results for your query\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#combining-advanced-decorators","title":"Combining Advanced Decorators","text":"<p>You can stack advanced decorators with each other and with other security decorators for robust, layered security.</p>"},{"location":"tutorial/decorators/advanced/#high-security-endpoint","title":". High-Security Endpoint","text":"<p>This endpoint is only accessible during specific hours and is protected by a honeypot.</p> <pre><code>@app.post(\"/api/admin/config\")\n@guard_deco.time_window(\"10:00\", \"16:00\", \"UTC\")\n@guard_deco.honeypot_detection(trap_fields=[\"admin_email_confirm\"])\n@guard_deco.require_auth(type=\"bearer\") # From authentication decorators\ndef update_admin_config(config_data: dict):\n    return {\"status\": \"Configuration updated\"}\n</code></pre>"},{"location":"tutorial/decorators/advanced/#error-handling","title":"Error Handling","text":"<p>Advanced decorators integrate with the middleware's error handling:</p> <ul> <li>403 Forbidden:</li> <li>When a request is outside the allowed <code>time_window</code>.</li> <li>When a <code>honeypot_detection</code> field is filled.</li> </ul>"},{"location":"tutorial/decorators/advanced/#custom-error-messages","title":". Custom Error Messages","text":"<p>You can configure custom error messages in the <code>SecurityConfig</code>.</p> <pre><code>config = SecurityConfig(\n    custom_error_responses={\n        403: \"Access denied. Please check access times and ensure you are not a bot.\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/advanced/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/advanced/#use-timezones-explicitly","title":". Use Timezones Explicitly","text":"<p>Always specify the timezone in <code>time_window</code> to avoid ambiguity, especially for applications serving a global user base.</p> <pre><code># Good: Explicit timezone\n@guard_deco.time_window(\"09:00\", \"17:00\", \"America/New_York\")\n\n# Avoid: Relying on default UTC if your users are in different timezones\n# @guard_deco.time_window(\"09:00\", \"17:00\")\n</code></pre>"},{"location":"tutorial/decorators/advanced/#hide-honeypot-fields-effectively","title":". Hide Honeypot Fields Effectively","text":"<p>Ensure honeypot fields are truly hidden from human users using CSS or other frontend techniques. A visible honeypot field can confuse users and defeat its purpose.</p>"},{"location":"tutorial/decorators/advanced/#be-strategic-with-detection-control","title":". Be Strategic with Detection Control","text":"<p>Only disable <code>suspicious_detection</code> when necessary. Disabling it globally or on many endpoints can weaken your application's defenses against penetration attempts.</p>"},{"location":"tutorial/decorators/advanced/#next-steps","title":"Next Steps","text":"<p>Now that you've learned about advanced decorators, you can explore other decorators to build a comprehensive security strategy:</p> <ul> <li>Behavioral Analysis Decorators - Monitor usage patterns and detect anomalies.</li> <li>Content Filtering - Validate and sanitize request data.</li> <li>Rate Limiting Decorators - Protect against brute-force and denial-of-service attacks.</li> </ul> <p>For complete API reference, see the Advanced Decorators API Documentation.</p>"},{"location":"tutorial/decorators/authentication/","title":"Authentication Decorators","text":"<p>Authentication decorators provide route-level authentication and authorization controls. These decorators help ensure secure communication and proper authentication for sensitive endpoints.</p>"},{"location":"tutorial/decorators/authentication/#https-enforcement","title":"HTTPS Enforcement","text":"<p>Force secure connections for specific routes:</p>"},{"location":"tutorial/decorators/authentication/#basic-https-requirement","title":". Basic HTTPS Requirement","text":"<pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.post(\"/api/login\")\n@guard_deco.require_https()\ndef login(credentials: dict):\n    return {\"token\": \"secure_jwt_token\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#combined-with-global-https","title":". Combined with Global HTTPS","text":"<pre><code># Global HTTPS enforcement\nconfig = SecurityConfig(enforce_https=True)\n\n# Route-specific override (still enforced due to global setting)\n@app.get(\"/api/public\")\n@guard_deco.require_https()  # Explicit requirement\ndef public_endpoint():\n    return {\"data\": \"definitely secure\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#https-for-sensitive-operations","title":". HTTPS for Sensitive Operations","text":"<pre><code>@app.post(\"/api/payment\")\n@guard_deco.require_https()\ndef payment_endpoint(payment_data: dict):\n    return {\"status\": \"payment processed securely\"}\n\n@app.post(\"/api/user/password\")\n@guard_deco.require_https()\ndef change_password(password_data: dict):\n    return {\"status\": \"password updated\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#authentication-requirements","title":"Authentication Requirements","text":"<p>Enforce different types of authentication:</p>"},{"location":"tutorial/decorators/authentication/#bearer-token-authentication","title":". Bearer Token Authentication","text":"<pre><code>@app.get(\"/api/profile\")\n@guard_deco.require_auth(type=\"bearer\")\ndef user_profile():\n    return {\"profile\": \"user data\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#multiple-authentication-types","title":". Multiple Authentication Types","text":"<pre><code>@app.get(\"/api/admin\")\n@guard_deco.require_auth(type=\"bearer\")\ndef admin_endpoint():\n    return {\"admin\": \"data\"}\n\n@app.get(\"/api/service\")\n@guard_deco.require_auth(type=\"basic\")\ndef service_endpoint():\n    return {\"service\": \"data\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#combined-https-and-auth","title":". Combined HTTPS and Auth","text":"<pre><code>@app.post(\"/api/secure-admin\")\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\ndef secure_admin():\n    return {\"data\": \"doubly secure\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>Require API keys for endpoint access:</p>"},{"location":"tutorial/decorators/authentication/#basic-api-key-requirement","title":". Basic API Key Requirement","text":"<pre><code>@app.get(\"/api/key-protected\")\n@guard_deco.api_key_auth(header_name=\"X-API-Key\")\ndef api_key_endpoint():\n    return {\"data\": \"api key required\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#custom-header-names","title":". Custom Header Names","text":"<pre><code>@app.get(\"/api/custom-key\")\n@guard_deco.api_key_auth(header_name=\"X-Custom-Auth\")\ndef custom_key_endpoint():\n    return {\"data\": \"custom header auth\"}\n\n@app.get(\"/api/service-key\")\n@guard_deco.api_key_auth(header_name=\"Authorization-Key\")\ndef service_key_endpoint():\n    return {\"data\": \"service authentication\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#multiple-key-requirements","title":". Multiple Key Requirements","text":"<pre><code>@app.get(\"/api/dual-auth\")\n@guard_deco.api_key_auth(header_name=\"X-API-Key\")\n@guard_deco.api_key_auth(header_name=\"X-Service-Key\")\ndef dual_auth_endpoint():\n    return {\"data\": \"dual key authentication\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#required-headers","title":"Required Headers","text":"<p>Enforce specific headers for authentication and security:</p>"},{"location":"tutorial/decorators/authentication/#security-headers","title":". Security Headers","text":"<pre><code>@app.get(\"/api/secure\")\n@guard_deco.require_headers({\n    \"X-Requested-With\": \"XMLHttpRequest\",\n    \"X-CSRF-Token\": \"required\"\n})\ndef secure_endpoint():\n    return {\"data\": \"csrf protected\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#api-versioning-headers","title":". API Versioning Headers","text":"<pre><code>@app.get(\"/api/v2/data\")\n@guard_deco.require_headers({\n    \"Accept\": \"application/vnd.api+json\",\n    \"API-Version\": \"2.0\"\n})\ndef versioned_endpoint():\n    return {\"data\": \"version 2.0\", \"format\": \"json-api\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#client-identification","title":". Client Identification","text":"<pre><code>@app.get(\"/api/client-specific\")\n@guard_deco.require_headers({\n    \"X-Client-ID\": \"required\",\n    \"X-Client-Version\": \"required\",\n    \"User-Agent\": \"required\"\n})\ndef client_endpoint():\n    return {\"data\": \"client identified\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#combined-authentication-patterns","title":"Combined Authentication Patterns","text":"<p>Stack multiple authentication decorators for comprehensive security:</p>"},{"location":"tutorial/decorators/authentication/#maximum-security-endpoint","title":". Maximum Security Endpoint","text":"<pre><code>@app.post(\"/api/admin/critical\")\n@guard_deco.require_https()                          # Secure connection\n@guard_deco.require_auth(type=\"bearer\")              # Bearer token\n@guard_deco.api_key_auth(header_name=\"X-Admin-Key\")  # Admin API key\n@guard_deco.require_headers({\n    \"X-CSRF-Token\": \"required\",                      # CSRF protection\n    \"X-Request-ID\": \"required\"                       # Request tracking\n})\ndef critical_admin_endpoint():\n    return {\"status\": \"critical operation completed\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#service-to-service-authentication","title":". Service-to-Service Authentication","text":"<pre><code>@app.post(\"/api/service/webhook\")\n@guard_deco.require_https()\n@guard_deco.api_key_auth(header_name=\"X-Service-Key\")\n@guard_deco.require_headers({\n    \"X-Signature\": \"required\",    # Webhook signature\n    \"Content-Type\": \"application/json\"\n})\ndef webhook_endpoint():\n    return {\"status\": \"webhook processed\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#client-application-authentication","title":". Client Application Authentication","text":"<pre><code>@app.get(\"/api/mobile/data\")\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.require_headers({\n    \"X-App-Version\": \"required\",\n    \"X-Device-ID\": \"required\",\n    \"Accept\": \"application/json\"\n})\ndef mobile_endpoint():\n    return {\"data\": \"mobile app data\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#authentication-flow-examples","title":"Authentication Flow Examples","text":""},{"location":"tutorial/decorators/authentication/#login-endpoint","title":". Login Endpoint","text":"<pre><code>@app.post(\"/auth/login\")\n@guard_deco.require_https()\n@guard_deco.require_headers({\n    \"Content-Type\": \"application/json\",\n    \"X-CSRF-Token\": \"required\"\n})\ndef login(credentials: dict):\n    # Validate credentials\n    return {\"token\": \"jwt_token\", \"expires\": \"3600\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#token-refresh","title":". Token Refresh","text":"<pre><code>@app.post(\"/auth/refresh\")\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.require_headers({\n    \"X-Refresh-Token\": \"required\"\n})\ndef refresh_token():\n    return {\"token\": \"new_jwt_token\", \"expires\": \"3600\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#logout","title":". Logout","text":"<pre><code>@app.post(\"/auth/logout\")\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.require_headers({\n    \"X-CSRF-Token\": \"required\"\n})\ndef logout():\n    return {\"status\": \"logged out\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#api-gateway-pattern","title":"API Gateway Pattern","text":"<p>Different authentication for different API tiers:</p>"},{"location":"tutorial/decorators/authentication/#public-api","title":". Public API","text":"<pre><code>@app.get(\"/api/public/status\")\n@guard_deco.api_key_auth(header_name=\"X-Public-Key\")\ndef public_status():\n    return {\"status\": \"public api active\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#partner-api","title":". Partner API","text":"<pre><code>@app.get(\"/api/partner/data\")\n@guard_deco.require_https()\n@guard_deco.api_key_auth(header_name=\"X-Partner-Key\")\n@guard_deco.require_headers({\n    \"X-Partner-ID\": \"required\"\n})\ndef partner_data():\n    return {\"data\": \"partner exclusive\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#internal-api","title":". Internal API","text":"<pre><code>@app.get(\"/api/internal/admin\")\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.api_key_auth(header_name=\"X-Internal-Key\")\n@guard_deco.require_headers({\n    \"X-Service-Name\": \"required\",\n    \"X-Request-Context\": \"required\"\n})\ndef internal_admin():\n    return {\"data\": \"internal admin access\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#error-handling","title":"Error Handling","text":"<p>Authentication decorators return specific HTTP status codes:</p> <ul> <li>400 Bad Request: Missing required headers</li> <li>401 Unauthorized: Invalid or missing authentication</li> <li>403 Forbidden: Valid auth but insufficient permissions</li> <li>301/302 Redirect: HTTP to HTTPS redirect</li> </ul>"},{"location":"tutorial/decorators/authentication/#custom-error-responses","title":". Custom Error Responses","text":"<pre><code>config = SecurityConfig(\n    custom_error_responses={\n        400: \"Missing required authentication headers\",\n        401: \"Invalid authentication credentials\",\n        403: \"Insufficient privileges for this operation\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/authentication/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/authentication/#layer-authentication-methods","title":". Layer Authentication Methods","text":"<p>Use multiple authentication factors for sensitive operations:</p> <pre><code># Good: Multiple authentication layers\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.api_key_auth(header_name=\"X-API-Key\")\n\n# Avoid: Single authentication method for sensitive data\n# @guard_deco.api_key_auth(header_name=\"X-API-Key\")  # Too weak for sensitive ops\n</code></pre>"},{"location":"tutorial/decorators/authentication/#always-use-https-for-authentication","title":". Always Use HTTPS for Authentication","text":"<p>Never transmit credentials over unencrypted connections:</p> <pre><code># Good: HTTPS enforced for login\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n\n# Bad: Authentication without HTTPS\n# @guard_deco.require_auth(type=\"bearer\")  # Credentials could be intercepted\n</code></pre>"},{"location":"tutorial/decorators/authentication/#validate-header-content","title":". Validate Header Content","text":"<p>Don't just check for presence, validate the content:</p> <pre><code># The middleware handles presence validation\n@guard_deco.require_headers({\"X-API-Key\": \"required\"})\n\n# Your application code should validate the actual key value\ndef validate_api_key(request):\n    api_key = request.headers.get(\"X-API-Key\")\n    return api_key in valid_keys\n</code></pre>"},{"location":"tutorial/decorators/authentication/#use-appropriate-authentication-for-each-endpoint","title":". Use Appropriate Authentication for Each Endpoint","text":"<p>Match authentication strength to data sensitivity:</p> <pre><code># Public data: Light authentication\n@guard_deco.api_key_auth(header_name=\"X-Public-Key\")\n\n# User data: Medium authentication\n@guard_deco.require_auth(type=\"bearer\")\n\n# Admin data: Heavy authentication\n@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.api_key_auth(header_name=\"X-Admin-Key\")\n</code></pre>"},{"location":"tutorial/decorators/authentication/#integration-with-fastapi-security","title":"Integration with FastAPI Security","text":"<p>Combine decorators with FastAPI's built-in security:</p> <pre><code>from fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\n\n@app.get(\"/api/integrated\")\n@guard_deco.require_https()\n@guard_deco.require_headers({\"X-Client-ID\": \"required\"})\ndef integrated_endpoint(token: str = Depends(security)):\n    # FastAPI handles token extraction\n    # Decorators handle additional security\n    return {\"data\": \"integrated security\"}\n</code></pre>"},{"location":"tutorial/decorators/authentication/#testing-authentication","title":"Testing Authentication","text":"<p>Test your authentication decorators:</p> <pre><code>import pytest\nfrom fastapi.testclient import TestClient\n\ndef test_https_required():\n    # Should redirect HTTP to HTTPS\n    response = client.get(\"/api/secure\", base_url=\"http://testserver\")\n    assert response.status_code == 301\n\ndef test_api_key_required():\n    # Should reject without API key\n    response = client.get(\"/api/key-protected\")\n    assert response.status_code == 400\n\n    # Should accept with valid API key\n    response = client.get(\n        \"/api/key-protected\",\n        headers={\"X-API-Key\": \"valid-key\"}\n    )\n    assert response.status_code == 200\n</code></pre>"},{"location":"tutorial/decorators/authentication/#next-steps","title":"Next Steps","text":"<p>Now that you understand authentication decorators, explore other security features:</p> <ul> <li>Access Control Decorators - IP and geographic restrictions</li> <li>Rate Limiting Decorators - Request rate controls</li> <li>Behavioral Analysis - Monitor authentication patterns</li> <li>Content Filtering - Request validation</li> </ul> <p>For complete API reference, see the Authentication API Documentation.</p>"},{"location":"tutorial/decorators/behavioral/","title":"Behavioral Analysis Decorators","text":"<p>Behavioral analysis decorators provide advanced monitoring capabilities to detect suspicious usage patterns, automated behavior, and potential abuse of your API endpoints. These decorators help identify bots, scrapers, and malicious users through behavioral analysis.</p>"},{"location":"tutorial/decorators/behavioral/#usage-monitoring","title":"Usage Monitoring","text":"<p>Monitor how frequently individual IPs access specific endpoints:</p>"},{"location":"tutorial/decorators/behavioral/#basic-usage-monitoring","title":". Basic Usage Monitoring","text":"<pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/sensitive\")\n@guard_deco.usage_monitor(max_calls=10, window=3600, action=\"ban\")\ndef sensitive_endpoint():\n    return {\"data\": \"sensitive information\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#gaming-endpoint-protection","title":". Gaming Endpoint Protection","text":"<pre><code>@app.post(\"/api/game/lootbox\")\n@guard_deco.usage_monitor(max_calls=5, window=3600, action=\"ban\")\ndef lootbox_endpoint():\n    # Prevent lootbox farming\n    return {\"reward\": \"rare_item\", \"value\": 1000}\n\n@app.post(\"/api/game/daily-reward\")\n@guard_deco.usage_monitor(max_calls=1, window=86400, action=\"ban\")\ndef daily_reward():\n    # Only once per day per IP\n    return {\"reward\": \"daily_bonus\", \"amount\": 100}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#api-rate-abuse-detection","title":". API Rate Abuse Detection","text":"<pre><code>@app.get(\"/api/expensive-computation\")\n@guard_deco.usage_monitor(max_calls=3, window=3600, action=\"throttle\")\ndef expensive_operation():\n    # Prevent abuse of computationally expensive operations\n    return {\"result\": \"computed_data\"}\n\n@app.get(\"/api/search\")\n@guard_deco.usage_monitor(max_calls=100, window=3600, action=\"alert\")\ndef search_endpoint():\n    # Monitor for search abuse but don't block immediately\n    return {\"results\": \"search_data\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#return-pattern-monitoring","title":"Return Pattern Monitoring","text":"<p>Detect when the same IP receives specific responses too frequently:</p>"},{"location":"tutorial/decorators/behavioral/#winsuccess-pattern-detection","title":". Win/Success Pattern Detection","text":"<pre><code>@app.post(\"/api/lottery\")\n@guard_deco.return_monitor(\"win\", max_occurrences=2, window=86400, action=\"ban\")\ndef lottery_endpoint():\n    # Prevent lottery manipulation\n    result = random.choice([\"win\", \"lose\", \"lose\", \"lose\"])\n    return {\"result\": result, \"prize\": 1000 if result == \"win\" else 0}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#reward-system-protection","title":". Reward System Protection","text":"<pre><code>@app.get(\"/api/rewards/spin\")\n@guard_deco.return_monitor(\"rare_item\", max_occurrences=3, window=86400, action=\"ban\")\ndef spin_wheel():\n    # Prevent rare item farming\n    items = [\"common\", \"common\", \"rare_item\", \"common\"]\n    result = random.choice(items)\n    return {\"item\": result, \"rarity\": \"rare\" if result == \"rare_item\" else \"common\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#json-path-pattern-matching","title":". JSON Path Pattern Matching","text":"<pre><code>@app.post(\"/api/game/battle\")\n@guard_deco.return_monitor(\n    \"json:result.outcome==victory\",\n    max_occurrences=10,\n    window=3600,\n    action=\"alert\"\n)\ndef battle_endpoint():\n    # Monitor for suspicious win rates\n    return {\n        \"result\": {\n            \"outcome\": \"victory\",\n            \"experience\": 100,\n            \"loot\": [\"sword\", \"gold\"]\n        }\n    }\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#regex-pattern-detection","title":". Regex Pattern Detection","text":"<pre><code>@app.get(\"/api/contest/submit\")\n@guard_deco.return_monitor(\n    \"regex:(success|winner|prize)\",\n    max_occurrences=5,\n    window=86400,\n    action=\"ban\"\n)\ndef contest_submission():\n    # Detect multiple contest wins from same IP\n    return {\"status\": \"success\", \"message\": \"Contest entry submitted\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#frequency-detection","title":"Frequency Detection","text":"<p>Detect suspiciously high request frequencies:</p>"},{"location":"tutorial/decorators/behavioral/#slow-operations-protection","title":". Slow Operations Protection","text":"<pre><code>@app.post(\"/api/report/generate\")\n@guard_deco.suspicious_frequency(max_frequency=0.1, window=300, action=\"ban\")\ndef generate_report():\n    # Max 1 request per 10 seconds (0.1 requests/second)\n    return {\"status\": \"Report generation started\"}\n\n@app.post(\"/api/backup/create\")\n@guard_deco.suspicious_frequency(max_frequency=0.017, window=3600, action=\"ban\")\ndef create_backup():\n    # Max 1 request per minute (0.017 requests/second)\n    return {\"status\": \"Backup initiated\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#api-scraping-prevention","title":". API Scraping Prevention","text":"<pre><code>@app.get(\"/api/products/{product_id}\")\n@guard_deco.suspicious_frequency(max_frequency=2.0, window=300, action=\"alert\")\ndef product_details(product_id: int):\n    # Alert if more than 2 requests per second for 5 minutes\n    return {\"product\": f\"Product {product_id}\", \"price\": 99.99}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#complex-behavioral-analysis","title":"Complex Behavioral Analysis","text":"<p>Combine multiple behavioral rules for comprehensive protection:</p>"},{"location":"tutorial/decorators/behavioral/#multi-rule-analysis","title":". Multi-Rule Analysis","text":"<pre><code>from guard.handlers.behavior_handler import BehaviorRule\n\n# Define multiple rules\nrules = [\n    BehaviorRule(\"usage\", threshold=20, window=3600, action=\"alert\"),\n    BehaviorRule(\"return_pattern\", threshold=5, pattern=\"win\", window=86400, action=\"ban\"),\n    BehaviorRule(\"frequency\", threshold=60, window=300, action=\"throttle\")\n]\n\n@app.post(\"/api/casino/play\")\n@guard_deco.behavior_analysis(rules)\ndef casino_game():\n    # Protected by multiple behavioral rules\n    return {\"result\": \"win\", \"amount\": 500}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#gaming-platform-protection","title":". Gaming Platform Protection","text":"<pre><code># Comprehensive gaming endpoint protection\n@app.post(\"/api/game/action\")\n@guard_deco.usage_monitor(max_calls=100, window=3600, action=\"alert\")\n@guard_deco.return_monitor(\"critical_hit\", max_occurrences=10, window=3600, action=\"ban\")\n@guard_deco.suspicious_frequency(max_frequency=5.0, window=60, action=\"throttle\")\ndef game_action():\n    # Multi-layered protection against game exploitation\n    return {\"action\": \"attack\", \"result\": \"critical_hit\", \"damage\": 150}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#financial-api-protection","title":". Financial API Protection","text":"<pre><code>@app.post(\"/api/trading/execute\")\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"ban\")\n@guard_deco.return_monitor(\"profit\", max_occurrences=20, window=86400, action=\"alert\")\n@guard_deco.suspicious_frequency(max_frequency=1.0, window=60, action=\"ban\")\ndef execute_trade():\n    # Prevent trading bot abuse\n    return {\"status\": \"executed\", \"result\": \"profit\", \"amount\": 1000}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#action-types","title":"Action Types","text":"<p>Different actions can be taken when behavioral thresholds are exceeded:</p>"},{"location":"tutorial/decorators/behavioral/#ban-action","title":". Ban Action","text":"<pre><code>@guard_deco.usage_monitor(max_calls=5, window=3600, action=\"ban\")\ndef strict_endpoint():\n    # Immediately ban IPs that exceed threshold\n    return {\"data\": \"strictly protected\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#alert-action","title":". Alert Action","text":"<pre><code>@guard_deco.return_monitor(\"suspicious_pattern\", max_occurrences=3, window=3600, action=\"alert\")\ndef monitored_endpoint():\n    # Log alerts but don't block access\n    return {\"status\": \"monitored\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#throttle-action","title":". Throttle Action","text":"<pre><code>@guard_deco.suspicious_frequency(max_frequency=2.0, window=300, action=\"throttle\")\ndef throttled_endpoint():\n    # Apply rate limiting when threshold exceeded\n    return {\"data\": \"throttled access\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#log-action","title":". Log Action","text":"<pre><code>@guard_deco.usage_monitor(max_calls=100, window=3600, action=\"log\")\ndef logged_endpoint():\n    # Only log incidents for analysis\n    return {\"data\": \"logged access\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#advanced-pattern-formats","title":"Advanced Pattern Formats","text":""},{"location":"tutorial/decorators/behavioral/#status-code-monitoring","title":". Status Code Monitoring","text":"<pre><code>@guard_deco.return_monitor(\"status:200\", max_occurrences=1000, window=3600, action=\"alert\")\ndef success_monitored():\n    # Monitor successful request patterns\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#complex-json-patterns","title":". Complex JSON Patterns","text":"<pre><code>@guard_deco.return_monitor(\n    \"json:user.level&gt;50\",\n    max_occurrences=5,\n    window=86400,\n    action=\"ban\"\n)\ndef level_up():\n    # Detect suspicious leveling patterns\n    return {\"user\": {\"level\": 55, \"experience\": 10000}}\n\n@guard_deco.return_monitor(\n    \"json:transaction.amount&gt;10000\",\n    max_occurrences=3,\n    window=86400,\n    action=\"alert\"\n)\ndef high_value_transaction():\n    # Monitor large transactions\n    return {\"transaction\": {\"amount\": 15000, \"currency\": \"USD\"}}\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/behavioral/#set-realistic-thresholds","title":". Set Realistic Thresholds","text":"<p>Base thresholds on legitimate user behavior:</p> <pre><code># Good: Based on actual usage patterns\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"alert\")  # 50/hour is reasonable\n\n# Avoid: Too restrictive for normal users\n# @guard_deco.usage_monitor(max_calls=3, window=3600, action=\"ban\")  # Too strict\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#use-graduated-responses","title":". Use Graduated Responses","text":"<p>Start with monitoring, then escalate to blocking:</p> <pre><code># Progressive enforcement\n@guard_deco.usage_monitor(max_calls=20, window=3600, action=\"log\")      # Log at 20\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"alert\")    # Alert at 50\n@guard_deco.usage_monitor(max_calls=100, window=3600, action=\"ban\")     # Ban at 100\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#monitor-valuable-operations","title":". Monitor Valuable Operations","text":"<p>Focus on endpoints that provide value to attackers:</p> <pre><code># High-value endpoints\n@guard_deco.return_monitor(\"rare_reward\", max_occurrences=2, window=86400, action=\"ban\")\n\n# Financial operations\n@guard_deco.usage_monitor(max_calls=10, window=3600, action=\"ban\")\n\n# Data extraction points\n@guard_deco.suspicious_frequency(max_frequency=1.0, window=60, action=\"throttle\")\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#consider-time-windows-carefully","title":". Consider Time Windows Carefully","text":"<p>Match windows to expected usage patterns:</p> <pre><code># Daily limits for once-per-day operations\n@guard_deco.usage_monitor(max_calls=1, window=86400, action=\"ban\")\n\n# Hourly limits for regular operations\n@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"alert\")\n\n# Short-term frequency detection\n@guard_deco.suspicious_frequency(max_frequency=2.0, window=300, action=\"throttle\")\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#integration-with-redis","title":"Integration with Redis","text":"<p>For distributed applications, ensure Redis is configured:</p> <pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://localhost:6379\",\n    redis_prefix=\"fastapi_guard:\"\n)\n\n# Behavioral tracking will use Redis for distributed state\nguard_deco = SecurityDecorator(config)\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#error-handling","title":"Error Handling","text":"<p>Behavioral decorators integrate with middleware error handling:</p> <ul> <li>403 Forbidden: When action is \"ban\"</li> <li>429 Too Many Requests: When action is \"throttle\"</li> <li>Logging: When action is \"log\" or \"alert\"</li> </ul>"},{"location":"tutorial/decorators/behavioral/#custom-error-messages","title":". Custom Error Messages","text":"<pre><code>config = SecurityConfig(\n    custom_error_responses={\n        403: \"Behavioral analysis detected suspicious activity\",\n        429: \"Request frequency too high - throttled\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#monitoring-and-debugging","title":"Monitoring and Debugging","text":"<p>Enable detailed logging to monitor behavioral analysis:</p> <pre><code>config = SecurityConfig(\n    log_suspicious_level=\"DEBUG\",\n    log_request_level=\"INFO\"\n)\n\n# Logs will include:\n# - Behavioral rule violations\n# - Pattern matching results\n# - Action execution details\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#testing-behavioral-rules","title":"Testing Behavioral Rules","text":"<p>Test your behavioral decorators:</p> <pre><code>import pytest\nfrom fastapi.testclient import TestClient\n\ndef test_usage_monitor():\n    # Should allow normal usage\n    for i in range(5):\n        response = client.get(\"/api/monitored\")\n        assert response.status_code == 200\n\n    # Should block after threshold\n    response = client.get(\"/api/monitored\")\n    assert response.status_code == 403\n\ndef test_return_pattern():\n    # Mock responses to trigger pattern\n    with patch('random.choice', return_value='win'):\n        for i in range(3):\n            response = client.post(\"/api/lottery\")\n            if i &lt; 2:\n                assert response.status_code == 200\n            else:\n                assert response.status_code == 403  # Blocked after 2 wins\n</code></pre>"},{"location":"tutorial/decorators/behavioral/#next-steps","title":"Next Steps","text":"<p>Now that you understand behavioral analysis decorators, explore other security features:</p> <ul> <li>Advanced Decorators - Time windows and detection controls</li> <li>Access Control Decorators - IP and geographic restrictions</li> <li>Content Filtering - Request validation and filtering</li> <li>Rate Limiting Decorators - Traditional rate limiting</li> </ul> <p>For complete API reference, see the Behavioral Analysis API Documentation.</p>"},{"location":"tutorial/decorators/content-filtering/","title":"Content Filtering Decorators","text":"<p>Content filtering decorators allow you to control and validate incoming requests based on content type, size, user agents, referrers, and custom validation logic. These decorators help ensure your endpoints receive only the expected types of requests.</p>"},{"location":"tutorial/decorators/content-filtering/#content-type-filtering","title":"Content Type Filtering","text":"<p>Control which content types are accepted by specific endpoints:</p>"},{"location":"tutorial/decorators/content-filtering/#basic-content-type-restriction","title":". Basic Content Type Restriction","text":"<pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.post(\"/api/json-only\")\n@guard_deco.content_type_filter([\"application/json\"])\ndef json_only_endpoint(data: dict):\n    return {\"received\": data, \"type\": \"json\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#multiple-content-types","title":". Multiple Content Types","text":"<pre><code>@app.post(\"/api/flexible\")\n@guard_deco.content_type_filter([\n    \"application/json\",\n    \"application/x-www-form-urlencoded\",\n    \"text/plain\"\n])\ndef flexible_endpoint():\n    return {\"message\": \"Multiple content types accepted\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#image-upload-endpoints","title":". Image Upload Endpoints","text":"<pre><code>@app.post(\"/api/upload/image\")\n@guard_deco.content_type_filter([\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\"\n])\ndef image_upload():\n    return {\"status\": \"Image upload endpoint\"}\n\n@app.post(\"/api/upload/avatar\")\n@guard_deco.content_type_filter([\"image/jpeg\", \"image/png\"])\ndef avatar_upload():\n    return {\"status\": \"Avatar upload - JPEG/PNG only\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#request-size-limits","title":"Request Size Limits","text":"<p>Control the maximum size of incoming requests:</p>"},{"location":"tutorial/decorators/content-filtering/#basic-size-limits","title":". Basic Size Limits","text":"<pre><code>@app.post(\"/api/upload/small\")\n@guard_deco.max_request_size(1024 * 1024)  # 1MB limit\ndef small_upload():\n    return {\"status\": \"Small file upload\"}\n\n@app.post(\"/api/upload/large\")\n@guard_deco.max_request_size(50 * 1024 * 1024)  # 50MB limit\ndef large_upload():\n    return {\"status\": \"Large file upload\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#size-limits-with-content-types","title":". Size Limits with Content Types","text":"<pre><code>@app.post(\"/api/upload/document\")\n@guard_deco.content_type_filter([\"application/pdf\", \"text/plain\"])\n@guard_deco.max_request_size(10 * 1024 * 1024)  # 10MB for documents\ndef document_upload():\n    return {\"status\": \"Document uploaded\"}\n\n@app.post(\"/api/upload/media\")\n@guard_deco.content_type_filter([\"video/mp4\", \"audio/mpeg\"])\n@guard_deco.max_request_size(100 * 1024 * 1024)  # 100MB for media\ndef media_upload():\n    return {\"status\": \"Media uploaded\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#progressive-size-limits","title":". Progressive Size Limits","text":"<pre><code># Different limits for different user tiers\n@app.post(\"/api/upload/basic\")\n@guard_deco.max_request_size(1024 * 1024)  # 1MB for basic users\ndef basic_upload():\n    return {\"tier\": \"basic\", \"limit\": \"1MB\"}\n\n@app.post(\"/api/upload/premium\")\n@guard_deco.max_request_size(10 * 1024 * 1024)  # 10MB for premium\ndef premium_upload():\n    return {\"tier\": \"premium\", \"limit\": \"10MB\"}\n\n@app.post(\"/api/upload/enterprise\")\n@guard_deco.max_request_size(100 * 1024 * 1024)  # 100MB for enterprise\ndef enterprise_upload():\n    return {\"tier\": \"enterprise\", \"limit\": \"100MB\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#user-agent-blocking","title":"User Agent Blocking","text":"<p>Block specific user agent patterns for individual routes:</p>"},{"location":"tutorial/decorators/content-filtering/#block-bot-user-agents","title":". Block Bot User Agents","text":"<pre><code>@app.get(\"/api/human-only\")\n@guard_deco.block_user_agents([\n    r\".*bot.*\",\n    r\".*crawler.*\",\n    r\".*spider.*\",\n    r\".*scraper.*\"\n])\ndef human_only_endpoint():\n    return {\"message\": \"Human users only\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#block-specific-tools","title":". Block Specific Tools","text":"<pre><code>@app.get(\"/api/no-automation\")\n@guard_deco.block_user_agents([\n    r\"curl.*\",\n    r\"wget.*\",\n    r\"Python-urllib.*\",\n    r\"Python-requests.*\",\n    r\"PostmanRuntime.*\"\n])\ndef no_automation_endpoint():\n    return {\"message\": \"No automation tools\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#block-malicious-user-agents","title":". Block Malicious User Agents","text":"<pre><code>@app.get(\"/api/secure\")\n@guard_deco.block_user_agents([\n    r\".*sqlmap.*\",\n    r\".*nikto.*\",\n    r\".*nmap.*\",\n    r\".*masscan.*\",\n    r\".*nessus.*\",\n    r\".*burp.*\"\n])\ndef secure_endpoint():\n    return {\"data\": \"Protected from security scanners\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#referrer-requirements","title":"Referrer Requirements","text":"<p>Require requests to come from specific referrer domains:</p>"},{"location":"tutorial/decorators/content-filtering/#basic-referrer-validation","title":". Basic Referrer Validation","text":"<pre><code>@app.get(\"/api/internal\")\n@guard_deco.require_referrer([\"myapp.com\", \"app.mycompany.com\"])\ndef internal_api():\n    return {\"message\": \"Internal API access\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#multiple-domain-support","title":". Multiple Domain Support","text":"<pre><code>@app.get(\"/api/partner\")\n@guard_deco.require_referrer([\n    \"partner1.com\",\n    \"partner2.com\",\n    \"api.partner3.com\",\n    \"subdomain.partner4.com\"\n])\ndef partner_api():\n    return {\"data\": \"Partner API access\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#development-vs-production-referrers","title":". Development vs Production Referrers","text":"<pre><code>@app.get(\"/api/dev\")\n@guard_deco.require_referrer([\n    \"localhost:3000\",\n    \"127.0.0.1:3000\",\n    \"dev.myapp.com\"\n])\ndef development_api():\n    return {\"env\": \"development\"}\n\n@app.get(\"/api/prod\")\n@guard_deco.require_referrer([\n    \"myapp.com\",\n    \"www.myapp.com\"\n])\ndef production_api():\n    return {\"env\": \"production\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#custom-validation","title":"Custom Validation","text":"<p>Add custom validation logic for complex requirements:</p>"},{"location":"tutorial/decorators/content-filtering/#header-validation","title":". Header Validation","text":"<pre><code>from fastapi import Request, Response\n\nasync def validate_api_version(request: Request) -&gt; Response | None:\n    \"\"\"Validate API version header.\"\"\"\n    version = request.headers.get(\"API-Version\")\n    if not version:\n        return Response(\"Missing API-Version header\", status_code=400)\n\n    if version not in [\"1.0\", \"2.0\", \"2.1\"]:\n        return Response(\"Unsupported API version\", status_code=400)\n\n    return None\n\n@app.get(\"/api/versioned\")\n@guard_deco.custom_validation(validate_api_version)\ndef versioned_endpoint():\n    return {\"message\": \"Version validated\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#request-body-validation","title":". Request Body Validation","text":"<pre><code>async def validate_json_structure(request: Request) -&gt; Response | None:\n    \"\"\"Validate JSON request structure.\"\"\"\n    if request.method in [\"POST\", \"PUT\", \"PATCH\"]:\n        try:\n            if \"application/json\" in request.headers.get(\"content-type\", \"\"):\n                body = await request.json()\n\n                # Require specific fields\n                required_fields = [\"user_id\", \"action\", \"timestamp\"]\n                for field in required_fields:\n                    if field not in body:\n                        return Response(\n                            f\"Missing required field: {field}\",\n                            status_code=400\n                        )\n\n                # Validate field types\n                if not isinstance(body.get(\"user_id\"), int):\n                    return Response(\"user_id must be integer\", status_code=400)\n\n        except Exception:\n            return Response(\"Invalid JSON\", status_code=400)\n\n    return None\n\n@app.post(\"/api/structured\")\n@guard_deco.custom_validation(validate_json_structure)\ndef structured_endpoint():\n    return {\"status\": \"Structure validated\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#authentication-token-validation","title":". Authentication Token Validation","text":"<pre><code>async def validate_bearer_token(request: Request) -&gt; Response | None:\n    \"\"\"Validate Bearer token format.\"\"\"\n    auth_header = request.headers.get(\"Authorization\", \"\")\n\n    if not auth_header.startswith(\"Bearer \"):\n        return Response(\"Invalid authorization format\", status_code=401)\n\n    token = auth_header[7:]  # Remove \"Bearer \" prefix\n\n    # Validate token format (example: JWT-like structure)\n    if len(token.split(\".\")) != 3:\n        return Response(\"Invalid token format\", status_code=401)\n\n    return None\n\n@app.get(\"/api/token-validated\")\n@guard_deco.custom_validation(validate_bearer_token)\ndef token_validated_endpoint():\n    return {\"message\": \"Token format validated\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#combining-content-filters","title":"Combining Content Filters","text":"<p>Stack multiple content filtering decorators for comprehensive validation:</p>"},{"location":"tutorial/decorators/content-filtering/#complete-upload-endpoint","title":". Complete Upload Endpoint","text":"<pre><code>@app.post(\"/api/upload/complete\")\n@guard_deco.content_type_filter([\"image/jpeg\", \"image/png\"])\n@guard_deco.max_request_size(5 * 1024 * 1024)  # 5MB limit\n@guard_deco.require_referrer([\"myapp.com\"])\n@guard_deco.block_user_agents([r\".*bot.*\", r\"curl.*\"])\ndef complete_upload():\n    return {\"status\": \"All validations passed\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#api-gateway-pattern","title":". API Gateway Pattern","text":"<pre><code># Public API - Basic filtering\n@app.post(\"/api/public/data\")\n@guard_deco.content_type_filter([\"application/json\"])\n@guard_deco.max_request_size(1024 * 1024)  # 1MB\ndef public_api():\n    return {\"tier\": \"public\"}\n\n# Partner API - Medium filtering\n@app.post(\"/api/partner/data\")\n@guard_deco.content_type_filter([\"application/json\", \"application/xml\"])\n@guard_deco.max_request_size(10 * 1024 * 1024)  # 10MB\n@guard_deco.require_referrer([\"partner.com\"])\ndef partner_api():\n    return {\"tier\": \"partner\"}\n\n# Internal API - Strict filtering\n@app.post(\"/api/internal/data\")\n@guard_deco.content_type_filter([\"application/json\"])\n@guard_deco.max_request_size(50 * 1024 * 1024)  # 50MB\n@guard_deco.require_referrer([\"internal.mycompany.com\"])\n@guard_deco.block_user_agents([r\".*bot.*\"])\ndef internal_api():\n    return {\"tier\": \"internal\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"tutorial/decorators/content-filtering/#content-type-based-routing","title":". Content Type Based Routing","text":"<pre><code>@app.post(\"/api/data/json\")\n@guard_deco.content_type_filter([\"application/json\"])\ndef json_processor():\n    return {\"processor\": \"json\"}\n\n@app.post(\"/api/data/xml\")\n@guard_deco.content_type_filter([\"application/xml\", \"text/xml\"])\ndef xml_processor():\n    return {\"processor\": \"xml\"}\n\n@app.post(\"/api/data/form\")\n@guard_deco.content_type_filter([\"application/x-www-form-urlencoded\"])\ndef form_processor():\n    return {\"processor\": \"form\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#size-based-processing","title":". Size-Based Processing","text":"<pre><code>@app.post(\"/api/process/small\")\n@guard_deco.max_request_size(1024 * 1024)  # 1MB - fast processing\ndef small_processor():\n    return {\"processing\": \"fast\", \"queue\": \"immediate\"}\n\n@app.post(\"/api/process/medium\")\n@guard_deco.max_request_size(10 * 1024 * 1024)  # 10MB - normal processing\ndef medium_processor():\n    return {\"processing\": \"normal\", \"queue\": \"standard\"}\n\n@app.post(\"/api/process/large\")\n@guard_deco.max_request_size(100 * 1024 * 1024)  # 100MB - slow processing\ndef large_processor():\n    return {\"processing\": \"slow\", \"queue\": \"background\"}\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#error-handling","title":"Error Handling","text":"<p>Content filtering decorators return specific HTTP status codes:</p> <ul> <li>400 Bad Request: Missing required headers, invalid content</li> <li>413 Payload Too Large: Request size exceeds limit</li> <li>415 Unsupported Media Type: Content type not allowed</li> <li>403 Forbidden: User agent blocked, referrer not allowed</li> </ul>"},{"location":"tutorial/decorators/content-filtering/#custom-error-messages","title":". Custom Error Messages","text":"<pre><code>config = SecurityConfig(\n    custom_error_responses={\n        400: \"Request validation failed\",\n        413: \"File too large for this endpoint\",\n        415: \"Content type not supported\",\n        403: \"Request source not authorized\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/content-filtering/#layer-content-controls","title":". Layer Content Controls","text":"<p>Apply multiple content filters for defense in depth:</p> <pre><code>@guard_deco.content_type_filter([\"application/json\"])  # Only JSON\n@guard_deco.max_request_size(1024 * 1024)             # Size limit\n@guard_deco.require_referrer([\"myapp.com\"])           # Trusted source\n@guard_deco.block_user_agents([r\".*bot.*\"])           # No bots\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#match-limits-to-functionality","title":". Match Limits to Functionality","text":"<p>Set appropriate size limits based on expected use:</p> <pre><code># Text API - small limit\n@guard_deco.max_request_size(64 * 1024)  # 64KB\n\n# Image upload - medium limit\n@guard_deco.max_request_size(5 * 1024 * 1024)  # 5MB\n\n# Video upload - large limit\n@guard_deco.max_request_size(100 * 1024 * 1024)  # 100MB\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#use-specific-content-type-lists","title":". Use Specific Content Type Lists","text":"<p>Be explicit about allowed content types:</p> <pre><code># Good: Specific types\n@guard_deco.content_type_filter([\"image/jpeg\", \"image/png\"])\n\n# Avoid: Too permissive\n# @guard_deco.content_type_filter([\"*/*\"])\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#validate-referrers-carefully","title":". Validate Referrers Carefully","text":"<p>Include all legitimate sources:</p> <pre><code>@guard_deco.require_referrer([\n    \"myapp.com\",\n    \"www.myapp.com\",\n    \"app.myapp.com\",\n    \"mobile.myapp.com\"  # Don't forget mobile subdomain\n])\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#testing-content-filters","title":"Testing Content Filters","text":"<p>Test your content filtering decorators:</p> <pre><code>import pytest\nfrom fastapi.testclient import TestClient\n\ndef test_content_type_filter():\n    # Should reject wrong content type\n    response = client.post(\n        \"/api/json-only\",\n        data=\"plain text\",\n        headers={\"Content-Type\": \"text/plain\"}\n    )\n    assert response.status_code == 415\n\n    # Should accept correct content type\n    response = client.post(\n        \"/api/json-only\",\n        json={\"data\": \"test\"},\n        headers={\"Content-Type\": \"application/json\"}\n    )\n    assert response.status_code == 200\n\ndef test_size_limit():\n    # Should reject large request\n    large_data = \"x\" * (2 * 1024 * 1024)  # 2MB\n    response = client.post(\n        \"/api/small-upload\",  # 1MB limit\n        data=large_data\n    )\n    assert response.status_code == 413\n\ndef test_user_agent_block():\n    # Should block bot user agent\n    response = client.get(\n        \"/api/human-only\",\n        headers={\"User-Agent\": \"GoogleBot/1.0\"}\n    )\n    assert response.status_code == 403\n</code></pre>"},{"location":"tutorial/decorators/content-filtering/#next-steps","title":"Next Steps","text":"<p>Now that you understand content filtering decorators, explore other security features:</p> <ul> <li>Advanced Decorators - Time windows and detection controls</li> <li>Behavioral Analysis - Monitor usage patterns</li> <li>Access Control Decorators - IP and geographic restrictions</li> <li>Authentication Decorators - HTTPS and auth requirements</li> </ul> <p>For complete API reference, see the Content Filtering API Documentation.</p>"},{"location":"tutorial/decorators/overview/","title":"Security Decorators Overview","text":"<p>FastAPI Guard's security decorators allow you to apply fine-grained security controls to individual routes, complementing the global middleware protection. This gives you the flexibility to customize security policies on a per-endpoint basis.</p>"},{"location":"tutorial/decorators/overview/#what-are-security-decorators","title":"What are Security Decorators?","text":"<p>Security decorators are Python decorators that you can apply to your FastAPI route functions to add specific security measures. They work alongside the global SecurityMiddleware to provide layered protection.</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityConfig\nfrom guard.decorators import SecurityDecorator\n\napp = FastAPI()\nconfig = SecurityConfig()\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/public\")\ndef public_endpoint():\n    return {\"message\": \"This uses global security settings\"}\n\n@app.get(\"/api/restricted\")\n@guard_deco.rate_limit(requests=5, window=300)\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])\ndef restricted_endpoint():\n    return {\"message\": \"This has additional route-specific restrictions\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#key-features","title":"Key Features","text":"<ul> <li>Route-Level Controls: Apply security rules to specific endpoints</li> <li>Override Global Settings: Route decorators can override global middleware settings</li> <li>Stacking Support: Combine multiple decorators for comprehensive protection</li> <li>Behavioral Analysis: Monitor endpoint usage patterns and detect anomalies</li> <li>Content Filtering: Control request types and sizes per endpoint</li> <li>Time-Based Access: Restrict access to specific time windows</li> </ul>"},{"location":"tutorial/decorators/overview/#decorator-categories","title":"Decorator Categories","text":""},{"location":"tutorial/decorators/overview/#access-control","title":". Access Control","text":"<p>Control who can access your endpoints based on IP, geography, and cloud providers.</p> <pre><code>@guard_deco.require_ip(whitelist=[\"192.168.1.0/24\"])\n@guard_deco.block_countries([\"CN\", \"RU\"])\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])\ndef sensitive_endpoint():\n    return {\"data\": \"restricted\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#authentication-authorization","title":". Authentication &amp; Authorization","text":"<p>Enforce authentication requirements and secure headers.</p> <pre><code>@guard_deco.require_https()\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.api_key_auth(header_name=\"X-API-Key\")\ndef authenticated_endpoint():\n    return {\"data\": \"authenticated\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#rate-limiting","title":". Rate Limiting","text":"<p>Apply custom rate limits to specific endpoints.</p> <pre><code>@guard_deco.rate_limit(requests=10, window=300)  # 10 requests per 5 minutes\n@guard_deco.geo_rate_limit({\"US\": (100, 3600), \"CN\": (5, 3600)})\ndef limited_endpoint():\n    return {\"data\": \"rate limited\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#behavioral-analysis","title":". Behavioral Analysis","text":"<p>Monitor and analyze user behavior patterns.</p> <pre><code>@guard_deco.usage_monitor(max_calls=50, window=3600, action=\"ban\")\n@guard_deco.return_monitor(\"win\", max_occurrences=3, window=86400, action=\"alert\")\ndef game_endpoint():\n    return {\"result\": \"win\", \"reward\": \"rare_item\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#content-filtering","title":". Content Filtering","text":"<p>Control request content and format.</p> <pre><code>@guard_deco.content_type_filter([\"application/json\"])\n@guard_deco.max_request_size(1024 * 1024)  # 1MB limit\n@guard_deco.require_referrer([\"myapp.com\"])\ndef upload_endpoint():\n    return {\"status\": \"uploaded\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#advanced-features","title":". Advanced Features","text":"<p>Time-based controls and sophisticated detection mechanisms.</p> <pre><code>@guard_deco.time_window(\"09:00\", \"17:00\", \"UTC\")  # Business hours only\n@guard_deco.suspicious_detection(enabled=True)\n@guard_deco.honeypot_detection([\"bot_trap\", \"hidden_field\"])\ndef advanced_endpoint():\n    return {\"data\": \"advanced protection\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#basic-setup","title":"Basic Setup","text":""},{"location":"tutorial/decorators/overview/#initialize-the-decorator","title":". Initialize the Decorator","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\nfrom guard.decorators import SecurityDecorator\n\napp = FastAPI()\nconfig = SecurityConfig(\n    enable_ip_banning=True,\n    enable_rate_limiting=True,\n    rate_limit_requests=100,\n    rate_limit_window=3600\n)\n\n# Create decorator instance\nguard_deco = SecurityDecorator(config)\n\n# Add global middleware\napp.add_middleware(SecurityMiddleware, config=config)\n\n# IMPORTANT: Set decorator handler for integration\napp.state.guard_decorator = guard_deco\n</code></pre>"},{"location":"tutorial/decorators/overview/#apply-decorators-to-routes","title":". Apply Decorators to Routes","text":"<pre><code>@app.post(\"/api/login\")\n@guard_deco.require_https()\n@guard_deco.rate_limit(requests=5, window=300)    # Stricter limit for login\n@guard_deco.suspicious_detection(enabled=True)\ndef login(credentials: dict):\n    # Login logic here\n    return {\"token\": \"jwt_token\"}\n\n@app.get(\"/api/admin\")\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])  # Internal network only\n@guard_deco.require_auth(type=\"bearer\")\n@guard_deco.time_window(\"09:00\", \"17:00\", \"UTC\")  # Business hours\ndef admin_panel():\n    return {\"message\": \"Admin access granted\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#configuration-priority","title":"Configuration Priority","text":"<p>Security settings are applied in this order (highest to lowest priority):</p> <ol> <li>Decorator Settings - Route-specific configurations</li> <li>Global Middleware Settings - Application-wide defaults</li> <li>Built-in Defaults - Library defaults</li> </ol> <p>This allows flexible overrides where routes can customize their security while maintaining global baselines.</p> <pre><code># Global: 100 requests/hour\nconfig = SecurityConfig(rate_limit_requests=100, rate_limit_window=3600)\n\n@app.get(\"/api/public\")\ndef public_endpoint():\n    # Uses global: 100 requests/hour\n    return {\"data\": \"public\"}\n\n@app.get(\"/api/limited\")\n@guard_deco.rate_limit(requests=10, window=300)  # Override: 10 requests/5min\ndef limited_endpoint():\n    # Uses decorator: 10 requests/5min\n    return {\"data\": \"limited\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/overview/#logical-decorator-order","title":". Logical Decorator Order","text":"<p>Apply decorators from most specific to most general:</p> <pre><code>@app.post(\"/api/admin/sensitive\")\n@guard_deco.require_https()                         # Security requirement\n@guard_deco.require_auth(type=\"bearer\")             # Authentication\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])    # Access control\n@guard_deco.rate_limit(requests=5, window=3600)     # Rate limiting\n@guard_deco.suspicious_detection(enabled=True)      # Monitoring\ndef admin_endpoint():\n    return {\"status\": \"admin action\"}\n</code></pre>"},{"location":"tutorial/decorators/overview/#combine-related-decorators","title":". Combine Related Decorators","text":"<p>Group related security measures:</p> <pre><code># Geographic restrictions\n@guard_deco.allow_countries([\"US\", \"CA\", \"GB\"])\n@guard_deco.block_clouds([\"AWS\", \"GCP\"])\n\n# Content controls\n@guard_deco.content_type_filter([\"image/jpeg\", \"image/png\"])\n@guard_deco.max_request_size(5 * 1024 * 1024)\n\n# Behavioral monitoring\n@guard_deco.usage_monitor(max_calls=50, window=3600)\n@guard_deco.return_monitor(\"rare_item\", max_occurrences=3, window=86400)\n</code></pre>"},{"location":"tutorial/decorators/overview/#error-handling","title":". Error Handling","text":"<p>Decorators integrate with middleware error handling:</p> <ul> <li>403 Forbidden: IP restrictions, country blocks, auth failures</li> <li>429 Too Many Requests: Rate limiting violations</li> <li>400 Bad Request: Content type mismatches, missing headers</li> <li>413 Payload Too Large: Request size exceeded</li> </ul>"},{"location":"tutorial/decorators/overview/#next-steps","title":"Next Steps","text":"<p>Now that you understand the overview, dive deeper into specific decorator categories:</p> <ul> <li>Access Control - IP filtering and geographic restrictions</li> <li>Authentication - HTTPS, auth requirements, and API keys</li> <li>Rate Limiting - Custom rate limits and geographic limits</li> <li>Behavioral Analysis - Usage monitoring and anomaly detection</li> <li>Content Filtering - Request validation and content controls</li> <li>Advanced Features - Time windows and sophisticated detection</li> </ul> <p>For complete API reference, see the Security Decorators API Documentation.</p>"},{"location":"tutorial/decorators/rate-limiting/","title":"Rate Limiting Decorators","text":"<p>Rate limiting decorators allow you to apply custom rate limits to specific endpoints, overriding global settings and providing fine-grained control over request frequencies. These decorators help prevent abuse and ensure fair usage of your API resources.</p>"},{"location":"tutorial/decorators/rate-limiting/#basic-rate-limiting","title":"Basic Rate Limiting","text":"<p>Apply custom rate limits to specific routes:</p>"},{"location":"tutorial/decorators/rate-limiting/#simple-rate-limit","title":". Simple Rate Limit","text":"<pre><code>from guard.decorators import SecurityDecorator\n\nguard_deco = SecurityDecorator(config)\n\n@app.get(\"/api/limited\")\n@guard_deco.rate_limit(requests=10, window=300)  # 10 requests per 5 minutes\ndef limited_endpoint():\n    return {\"data\": \"rate limited\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#override-global-settings","title":". Override Global Settings","text":"<pre><code># Global rate limit: 100 requests/hour\nconfig = SecurityConfig(rate_limit_requests=100, rate_limit_window=3600)\n\n@app.get(\"/api/public\")\ndef public_endpoint():\n    # Uses global: 100 requests/hour\n    return {\"data\": \"public\"}\n\n@app.get(\"/api/strict\")\n@guard_deco.rate_limit(requests=5, window=300)  # Override: 5 requests/5min\ndef strict_endpoint():\n    # Uses decorator: 5 requests/5min\n    return {\"data\": \"strictly limited\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#different-limits-for-different-operations","title":". Different Limits for Different Operations","text":"<pre><code>@app.get(\"/api/read\")\n@guard_deco.rate_limit(requests=100, window=3600)  # 100 reads/hour\ndef read_data():\n    return {\"data\": \"read operation\"}\n\n@app.post(\"/api/write\")\n@guard_deco.rate_limit(requests=10, window=3600)   # 10 writes/hour\ndef write_data(data: dict):\n    return {\"status\": \"write operation\"}\n\n@app.delete(\"/api/delete\")\n@guard_deco.rate_limit(requests=5, window=3600)    # 5 deletes/hour\ndef delete_data():\n    return {\"status\": \"delete operation\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#endpoint-specific-rate-limits","title":"Endpoint-Specific Rate Limits","text":"<p>Tailor rate limits to endpoint sensitivity and usage patterns:</p>"},{"location":"tutorial/decorators/rate-limiting/#authentication-endpoints","title":". Authentication Endpoints","text":"<pre><code>@app.post(\"/auth/login\")\n@guard_deco.rate_limit(requests=5, window=300)     # 5 attempts per 5 minutes\ndef login(credentials: dict):\n    return {\"token\": \"jwt_token\"}\n\n@app.post(\"/auth/register\")\n@guard_deco.rate_limit(requests=3, window=3600)    # 3 registrations per hour\ndef register(user_data: dict):\n    return {\"status\": \"user created\"}\n\n@app.post(\"/auth/forgot-password\")\n@guard_deco.rate_limit(requests=2, window=3600)    # 2 reset requests per hour\ndef forgot_password(email: str):\n    return {\"status\": \"reset email sent\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#sensitive-operations","title":". Sensitive Operations","text":"<pre><code>@app.post(\"/api/payment\")\n@guard_deco.rate_limit(requests=3, window=600)     # 3 payments per 10 minutes\ndef process_payment(payment_data: dict):\n    return {\"status\": \"payment processed\"}\n\n@app.post(\"/api/admin/user-ban\")\n@guard_deco.rate_limit(requests=10, window=3600)   # 10 bans per hour\ndef ban_user(user_id: str):\n    return {\"status\": \"user banned\"}\n\n@app.delete(\"/api/admin/data-purge\")\n@guard_deco.rate_limit(requests=1, window=86400)   # 1 purge per day\ndef purge_data():\n    return {\"status\": \"data purged\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#resource-intensive-operations","title":". Resource-Intensive Operations","text":"<pre><code>@app.post(\"/api/export\")\n@guard_deco.rate_limit(requests=2, window=3600)    # 2 exports per hour\ndef export_data():\n    return {\"status\": \"export started\"}\n\n@app.post(\"/api/report/generate\")\n@guard_deco.rate_limit(requests=5, window=3600)    # 5 reports per hour\ndef generate_report():\n    return {\"status\": \"report generating\"}\n\n@app.post(\"/api/search/complex\")\n@guard_deco.rate_limit(requests=20, window=300)    # 20 searches per 5 minutes\ndef complex_search(query: dict):\n    return {\"results\": \"search results\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#geographic-rate-limiting","title":"Geographic Rate Limiting","text":"<p>Apply different rate limits based on user's geographic location:</p>"},{"location":"tutorial/decorators/rate-limiting/#country-specific-limits","title":". Country-Specific Limits","text":"<pre><code>@app.get(\"/api/content\")\n@guard_deco.geo_rate_limit({\n    \"US\": (100, 3600),    # 100 requests/hour for US\n    \"CA\": (100, 3600),    # 100 requests/hour for Canada\n    \"GB\": (80, 3600),     # 80 requests/hour for UK\n    \"DE\": (80, 3600),     # 80 requests/hour for Germany\n    \"CN\": (10, 3600),     # 10 requests/hour for China\n    \"*\": (50, 3600)       # 50 requests/hour for others\n})\ndef geo_limited_content():\n    return {\"data\": \"geographic rate limited\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#tiered-geographic-access","title":". Tiered Geographic Access","text":"<pre><code>@app.get(\"/api/premium\")\n@guard_deco.geo_rate_limit({\n    # Tier 1: Premium countries\n    \"US\": (200, 3600),\n    \"CA\": (200, 3600),\n    \"GB\": (200, 3600),\n    \"DE\": (200, 3600),\n    \"AU\": (200, 3600),\n\n    # Tier 2: Standard countries\n    \"FR\": (100, 3600),\n    \"IT\": (100, 3600),\n    \"ES\": (100, 3600),\n    \"JP\": (100, 3600),\n\n    # Tier 3: Limited countries\n    \"IN\": (50, 3600),\n    \"BR\": (50, 3600),\n    \"MX\": (50, 3600),\n\n    # Default: Very limited\n    \"*\": (20, 3600)\n})\ndef premium_content():\n    return {\"data\": \"premium geographic content\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#regional-business-hours","title":". Regional Business Hours","text":"<pre><code>@app.get(\"/api/support\")\n@guard_deco.geo_rate_limit({\n    # Higher limits during business hours in respective regions\n    \"US\": (50, 3600),     # US business hours\n    \"EU\": (40, 3600),     # European business hours\n    \"APAC\": (30, 3600),   # Asia-Pacific business hours\n    \"*\": (20, 3600)       # Outside business regions\n})\ndef support_endpoint():\n    return {\"data\": \"support information\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#time-based-rate-limiting","title":"Time-Based Rate Limiting","text":"<p>Combine rate limiting with time windows:</p>"},{"location":"tutorial/decorators/rate-limiting/#business-hours-vs-after-hours","title":". Business Hours vs After Hours","text":"<pre><code># Business hours: stricter limits\n@app.post(\"/api/business/order\")\n@guard_deco.rate_limit(requests=50, window=3600)   # 50 orders/hour during business\n@guard_deco.time_window(\"09:00\", \"17:00\", \"EST\")\ndef business_hours_orders():\n    return {\"status\": \"business hours order\"}\n\n# After hours: more lenient\n@app.post(\"/api/after-hours/order\")\n@guard_deco.rate_limit(requests=20, window=3600)   # 20 orders/hour after hours\ndef after_hours_orders():\n    return {\"status\": \"after hours order\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#weekend-vs-weekday","title":". Weekend vs Weekday","text":"<pre><code># Weekday: higher limits for business users\n@app.get(\"/api/weekday/data\")\n@guard_deco.rate_limit(requests=100, window=3600)\ndef weekday_data():\n    return {\"data\": \"weekday business data\"}\n\n# Weekend: lower limits for personal use\n@app.get(\"/api/weekend/data\")\n@guard_deco.rate_limit(requests=30, window=3600)\ndef weekend_data():\n    return {\"data\": \"weekend personal data\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#advanced-rate-limiting-patterns","title":"Advanced Rate Limiting Patterns","text":""},{"location":"tutorial/decorators/rate-limiting/#graduated-rate-limits","title":". Graduated Rate Limits","text":"<p>Different limits based on endpoint complexity:</p> <pre><code># Simple operations: Higher limits\n@app.get(\"/api/simple/status\")\n@guard_deco.rate_limit(requests=1000, window=3600)\ndef simple_status():\n    return {\"status\": \"ok\"}\n\n# Medium operations: Moderate limits\n@app.get(\"/api/medium/data\")\n@guard_deco.rate_limit(requests=100, window=3600)\ndef medium_data():\n    return {\"data\": \"medium complexity\"}\n\n# Complex operations: Low limits\n@app.post(\"/api/complex/analysis\")\n@guard_deco.rate_limit(requests=10, window=3600)\ndef complex_analysis():\n    return {\"result\": \"complex analysis\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#user-tier-based-limits","title":". User Tier-Based Limits","text":"<pre><code># Free tier endpoints\n@app.get(\"/api/free/data\")\n@guard_deco.rate_limit(requests=100, window=86400)  # 100 per day\ndef free_tier_data():\n    return {\"data\": \"free tier\"}\n\n# Premium tier endpoints\n@app.get(\"/api/premium/data\")\n@guard_deco.rate_limit(requests=1000, window=3600)  # 1000 per hour\ndef premium_tier_data():\n    return {\"data\": \"premium tier\"}\n\n# Enterprise tier endpoints\n@app.get(\"/api/enterprise/data\")\n@guard_deco.rate_limit(requests=10000, window=3600) # 10000 per hour\ndef enterprise_tier_data():\n    return {\"data\": \"enterprise tier\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#api-versioning-rate-limits","title":". API Versioning Rate Limits","text":"<pre><code># Legacy API: Restricted to encourage migration\n@app.get(\"/api/v1/data\")\n@guard_deco.rate_limit(requests=50, window=3600)\ndef v1_data():\n    return {\"data\": \"legacy v1\", \"deprecated\": True}\n\n# Current API: Standard limits\n@app.get(\"/api/v2/data\")\n@guard_deco.rate_limit(requests=100, window=3600)\ndef v2_data():\n    return {\"data\": \"current v2\"}\n\n# Beta API: Higher limits to encourage testing\n@app.get(\"/api/v3/data\")\n@guard_deco.rate_limit(requests=200, window=3600)\ndef v3_data():\n    return {\"data\": \"beta v3\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#combining-with-other-decorators","title":"Combining with Other Decorators","text":"<p>Stack rate limiting with other security measures:</p>"},{"location":"tutorial/decorators/rate-limiting/#rate-limiting-access-control","title":". Rate Limiting + Access Control","text":"<pre><code>@app.post(\"/api/admin/action\")\n@guard_deco.require_ip(whitelist=[\"10.0.0.0/8\"])     # Internal network only\n@guard_deco.rate_limit(requests=20, window=3600)     # 20 actions per hour\ndef admin_action():\n    return {\"status\": \"admin action completed\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#rate-limiting-authentication","title":". Rate Limiting + Authentication","text":"<pre><code>@app.get(\"/api/user/profile\")\n@guard_deco.require_auth(type=\"bearer\")              # Authentication required\n@guard_deco.rate_limit(requests=60, window=3600)     # 60 requests per hour\ndef user_profile():\n    return {\"profile\": \"user data\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#rate-limiting-behavioral-analysis","title":". Rate Limiting + Behavioral Analysis","text":"<pre><code>@app.post(\"/api/game/action\")\n@guard_deco.rate_limit(requests=100, window=3600)    # 100 actions per hour\n@guard_deco.usage_monitor(max_calls=50, window=300)  # Monitor for burst usage\ndef game_action():\n    return {\"result\": \"game action completed\"}\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#error-handling","title":"Error Handling","text":"<p>Rate limiting decorators return specific HTTP status codes:</p> <ul> <li>429 Too Many Requests: Rate limit exceeded</li> <li>503 Service Unavailable: Rate limiting service unavailable</li> </ul>"},{"location":"tutorial/decorators/rate-limiting/#custom-rate-limit-messages","title":". Custom Rate Limit Messages","text":"<pre><code>config = SecurityConfig(\n    custom_error_responses={\n        429: \"Rate limit exceeded. Please try again later.\"\n    }\n)\n\n# The response will include rate limit headers:\n# X-RateLimit-Limit: 10\n# X-RateLimit-Remaining: 0\n# X-RateLimit-Reset: 1640995200\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/decorators/rate-limiting/#match-limits-to-endpoint-purpose","title":". Match Limits to Endpoint Purpose","text":"<p>Consider the business purpose and resource cost:</p> <pre><code># Good: High limits for lightweight operations\n@guard_deco.rate_limit(requests=1000, window=3600)  # Status checks\n\n# Good: Low limits for expensive operations\n@guard_deco.rate_limit(requests=5, window=3600)     # Data exports\n\n# Avoid: Same limits for all endpoints\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#consider-user-experience","title":". Consider User Experience","text":"<p>Don't make limits so strict they hurt legitimate users:</p> <pre><code># Good: Reasonable limits for normal usage\n@guard_deco.rate_limit(requests=100, window=3600)   # Allows normal browsing\n\n# Bad: Too restrictive for normal use\n# @guard_deco.rate_limit(requests=5, window=3600)   # Hurts legitimate users\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#use-geographic-limits-thoughtfully","title":". Use Geographic Limits Thoughtfully","text":"<p>Consider infrastructure and business presence:</p> <pre><code># Good: Higher limits where you have better infrastructure\n@guard_deco.geo_rate_limit({\n    \"US\": (200, 3600),  # Strong US presence\n    \"EU\": (150, 3600),  # Good EU infrastructure\n    \"AS\": (100, 3600),  # Developing APAC presence\n})\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#provide-clear-error-messages","title":". Provide Clear Error Messages","text":"<p>Help users understand the limits:</p> <pre><code>config = SecurityConfig(\n    custom_error_responses={\n        429: \"Rate limit exceeded. You can make 100 requests per hour. Current window resets at {reset_time}.\"\n    }\n)\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#monitoring-and-analytics","title":"Monitoring and Analytics","text":"<p>Track rate limiting effectiveness:</p> <pre><code># Enable detailed logging for rate limiting analysis\nconfig = SecurityConfig(\n    log_request_level=\"INFO\",       # Log all requests\n    log_suspicious_level=\"WARNING\"  # Log rate limit violations\n)\n\n# Logs will show:\n# \"Rate limit exceeded for IP: 203.0.113.1\"\n# \"Rate limit window reset for endpoint: /api/data\"\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#testing-rate-limits","title":"Testing Rate Limits","text":"<p>Test your rate limiting decorators:</p> <pre><code>import pytest\nfrom fastapi.testclient import TestClient\nimport time\n\ndef test_rate_limit():\n    # Should allow requests within limit\n    for _ in range(5):\n        response = client.get(\"/api/limited\")\n        assert response.status_code == 200\n\n    # Should block after limit exceeded\n    response = client.get(\"/api/limited\")\n    assert response.status_code == 429\n\n    # Should reset after window\n    time.sleep(301)  # Wait for 5-minute window to reset\n    response = client.get(\"/api/limited\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"tutorial/decorators/rate-limiting/#next-steps","title":"Next Steps","text":"<p>Now that you understand rate limiting decorators, explore other security features:</p> <ul> <li>Access Control Decorators - IP and geographic restrictions</li> <li>Authentication Decorators - HTTPS and auth requirements</li> <li>Behavioral Analysis - Monitor usage patterns</li> <li>Content Filtering - Request validation</li> </ul> <p>For complete API reference, see the Rate Limiting API Documentation.</p>"},{"location":"tutorial/examples/example-app/","title":"Example Application","text":"<p>FastAPI Guard comes with a fully functional example application that demonstrates its key security features. This example serves both as a reference implementation and a testing ground for your security settings.</p>"},{"location":"tutorial/examples/example-app/#features-demonstrated","title":"Features Demonstrated","text":"<p>The example app demonstrates:</p> <ul> <li>IP whitelist/blacklist filtering</li> <li>Rate limiting</li> <li>Penetration detection and prevention</li> <li>Auto-banning of suspicious IPs</li> <li>Geolocation-based filtering</li> <li>User agent filtering</li> <li>Redis integration</li> </ul>"},{"location":"tutorial/examples/example-app/#code-overview","title":"Code Overview","text":"<p>The example app is built using FastAPI and shows how to integrate FastAPI Guard as middleware:</p> <p>Example Code</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Initialize FastAPI app\napp = FastAPI(title=\"FastAPI Guard Playground\")\n\n# Configure FastAPI Guard\nconfig = SecurityConfig(\n    # Whitelist/Blacklist\n    whitelist=[\"0.0.0.0/32\", \"0.0.0.0\"],\n    blacklist=[\"192.168.1.100/32\", \"192.168.1.100\"],\n    ...\n)\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/examples/example-app/#running-the-example-app","title":"Running the Example App","text":""},{"location":"tutorial/examples/example-app/#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>The Docker Compose file does the following: - Builds the FastAPI Guard example app - Runs Redis with persistent data volume - Connects the application to Redis - Exposes the app on port 8000</p>"},{"location":"tutorial/examples/example-app/#docker-compose-file","title":"Docker Compose File","text":"<p>Docker Compose File</p> <pre><code>services:\n  fastapi-guard-example:\n    build:\n      context: .\n      dockerfile: ./Dockerfile\n    command: uvicorn main:app --host 0.0.0.0 --reload\n    ports:\n      - \"8000:8000\"\n    environment:\n      - REDIS_URL=redis://redis:6379\n      - REDIS_PREFIX=${REDIS_PREFIX:-\"fastapi_guard:\"}\n      - IPINFO_TOKEN=${IPINFO_TOKEN:-\"test_token\"}\n    depends_on:\n      redis:\n        condition: service_started\n  ...\n</code></pre>"},{"location":"tutorial/examples/example-app/#test-endpoints","title":"Test Endpoints","text":"<p>Once running, you can access the following endpoints:</p> <ul> <li><code>/</code>: Basic endpoint to test connection and rate limiting</li> <li><code>/ip</code>: Returns your client IP address as seen by the server</li> <li><code>/test?input=&lt;script&gt;alert(1)&lt;/script&gt;</code>: Test with various inputs to trigger penetration detection</li> <li><code>/docs</code>: Swagger UI documentation for interactive testing</li> </ul>"},{"location":"tutorial/examples/example-app/#testing-security-features","title":"Testing Security Features","text":"<p>You can use the included test battery to verify security features:</p> <p>Test battery</p> <pre><code># For rate limiting (will trigger after 15 requests)\nfor i in {1..20}; do curl http://0.0.0.0:8000/; echo \" Request $i\"; sleep 0.2; done\n\n# For XSS detection\ncurl \"http://0.0.0.0:8000/test?input=&lt;script&gt;alert(1)&lt;/script&gt;\"\n\n# For SQL injection detection\ncurl \"http://0.0.0.0:8000/test?query=SELECT%20*%20FROM%20users\"\n\n# For path traversal detection\ncurl \"http://0.0.0.0:8000/test?path=../../../etc/passwd\"\n\n# For command injection detection\ncurl \"http://0.0.0.0:8000/test?cmd=;ls;pwd;\"\n\n...\n</code></pre>"},{"location":"tutorial/examples/example-app/#environment-variables","title":"Environment Variables","text":"<p>The example app supports the following environment variables:</p> <ul> <li><code>IPINFO_TOKEN</code>: Your IPInfo API token (default: test_token)</li> <li><code>REDIS_URL</code>: Redis connection URL (default: redis://redis:6379)</li> <li><code>REDIS_PREFIX</code>: Prefix for Redis keys (default: fastapi_guard:)</li> </ul>"},{"location":"tutorial/examples/example-app/#source-code","title":"Source Code","text":"<p>You can find the complete example code in the examples directory of the GitHub repository.</p>"},{"location":"tutorial/examples/example-app/#example-with-passive-mode","title":"Example with Passive Mode","text":"<p>For production deployments where you want to assess potential false positives before fully enabling penetration detection, use the passive mode:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig, IPInfoManager\n\napp = FastAPI(title=\"My API with Security\")\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),\n\n    # Rate limiting\n    rate_limit=100,  # Allow 100 requests\n    rate_limit_window=60,  # per minute\n\n    # IP filtering\n    whitelist=[\"127.0.0.1\", \"192.168.1.0/24\"],  # Office network\n\n    # Geolocation\n    blocked_countries=[\"XX\", \"YY\"],  # Block specific countries\n\n    # Logging configuration\n    log_request_level=\"INFO\",       # Log normal requests as INFO (for development)\n    # log_request_level=None,       # Or disable for production\n    log_suspicious_level=\"WARNING\", # Keep suspicious activity at WARNING level\n\n    # Penetration detection with passive mode\n    enable_penetration_detection=True,\n    passive_mode=True,  # Don't block, just log\n\n    # Auto-banning (will only be logged in passive mode)\n    enable_ip_banning=True,\n    auto_ban_threshold=5,  # Number of suspicious requests before ban\n    auto_ban_duration=3600,  # Ban duration in seconds (1 hour)\n\n    # Redis for distributed deployment (optional)\n    enable_redis=True,\n    redis_url=\"redis://localhost:6379\",\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <p>You can use any configuration with this mode, but it restricts penetration detection to passive mode. After running in this mode for some time and analyzing logs, you can switch to full protection mode by removing the <code>passive_mode=True</code> flag or setting it to <code>False</code> (false by default).</p>"},{"location":"tutorial/ip-management/banning/","title":"IP Banning","text":"<p>FastAPI Guard provides powerful IP banning capabilities through the <code>IPBanManager</code>.</p>"},{"location":"tutorial/ip-management/banning/#automatic-ip-banning","title":"Automatic IP Banning","text":"<p>Configure automatic IP banning based on suspicious activity:</p> <pre><code>config = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600,  # Ban duration in seconds (1 hour)\n)\n</code></pre>"},{"location":"tutorial/ip-management/banning/#manual-ip-banning","title":"Manual IP Banning","text":"<p>You can also manually ban IPs using the <code>IPBanManager</code>:</p> <pre><code>from guard.handlers.ipban_handler import ip_ban_manager\n\n@app.post(\"/admin/ban/{ip}\")\nasync def ban_ip(ip: str, duration: int = 3600):\n    await ip_ban_manager.ban_ip(ip, duration)\n    return {\"message\": f\"IP {ip} banned for {duration} seconds\"}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#checking-ban-status","title":"Checking Ban Status","text":"<p>Check if an IP is currently banned:</p> <pre><code>@app.get(\"/admin/check/{ip}\")\nasync def check_ban(ip: str):\n    is_banned = await ip_ban_manager.is_ip_banned(ip)\n    return {\"ip\": ip, \"banned\": is_banned}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#reset-all-bans","title":"Reset All Bans","text":"<p>Clear all active IP bans:</p> <pre><code>@app.post(\"/admin/reset\")\nasync def reset_bans():\n    await ip_ban_manager.reset()\n    return {\"message\": \"All IP bans cleared\"}\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/","title":"Cloud Provider IP Blocking","text":"<p>FastAPI Guard can automatically detect and block requests from major cloud providers. The IP ranges for these providers are only loaded when cloud blocking is enabled, improving startup performance.</p>"},{"location":"tutorial/ip-management/cloud-providers/#supported-providers","title":"Supported Providers","text":"<p>Currently supported cloud providers:</p> <ul> <li>Amazon Web Services (AWS)</li> <li>Google Cloud Platform (GCP)</li> <li>Microsoft Azure</li> </ul>"},{"location":"tutorial/ip-management/cloud-providers/#basic-configuration","title":"Basic Configuration","text":"<p>Enable cloud provider IP blocking:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\", \"GCP\", \"Azure\"}\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#selective-blocking","title":"Selective Blocking","text":"<p>Block specific providers:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\"}  # Only block AWS IPs\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#ip-range-updates","title":"IP Range Updates","text":"<p>Cloud IP ranges are automatically updated daily. You can manually refresh them:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# Refresh IP ranges\ncloud_handler.refresh()\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#custom-ip-checking","title":"Custom IP Checking","text":"<p>Check if an IP belongs to a cloud provider:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n@app.get(\"/check-cloud/{ip}\")\nasync def check_cloud_ip(ip: str):\n    is_cloud = cloud_handler.is_cloud_ip(\n        ip,\n        providers={\"AWS\", \"GCP\", \"Azure\"}\n    )\n    return {\"ip\": ip, \"is_cloud\": is_cloud}\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/","title":"IP Geolocation","text":"<p>FastAPI Guard accepts an arbitrary class that implements geolocation and country-based filtering. All it needs is to implement the following protocol:</p> <pre><code>class GeoIPHandler(Protocol):\n    \"\"\"\n    Protocol for geographical IP handler.\n    \"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool: ...\n\n    async def initialize(self) -&gt; None: ...\n\n    async def initialize_redis(self, redis_handler: \"RedisManager\") -&gt; None: ...\n\n    def get_country(self, ip: str) -&gt; str | None: ...\n</code></pre> <p>It provides an implementation that uses the ipinfo.io service:</p> <pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\n</code></pre> <p>The geolocation handler is only initialized and used when country filtering is configured, improving performance for applications that don't need these features.</p>"},{"location":"tutorial/ip-management/geolocation/#setup","title":"Setup","text":""},{"location":"tutorial/ip-management/geolocation/#option-1-using-the-built-in-ipinfohandler","title":"Option 1: Using the built-in IPInfoHandler","text":"<ol> <li>Get your IPInfo token from ipinfo.io</li> <li>Configure geolocation in your app:</li> </ol> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    blocked_countries=[\"CN\", \"RU\"],  # Block specific countries\n    whitelist_countries=[\"US\", \"CA\"],\n    db_path=\"custom/ipinfo.db\",  # Optional custom database path\n    block_cloud_providers={\"AWS\", \"GCP\"}  # Case-sensitive provider names\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#option-2-providing-a-custom-geographical-ip-handler","title":"Option 2: Providing a custom geographical IP handler","text":"<pre><code>class CustomGeoIPHandler:\n    \"\"\"\n    Your custom class.\n    \"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        # your implementation\n        ...\n\n    async def initialize(self) -&gt; None:\n        # your implementation\n        ...\n\n    async def initialize_redis(self, redis_handler: \"RedisManager\") -&gt; None:\n        # your implementation\n        ...\n\n    def get_country(self, ip: str) -&gt; str | None:\n        # your implementation\n        ...\n\n\nconfig = SecurityConfig(\n    geo_ip_handler=CustomGeoIPHandler(),\n    blocked_countries=[\"CN\", \"RU\"],  # Block specific countries\n    whitelist_countries=[\"US\", \"CA\"],\n    db_path=\"custom/ipinfo.db\",  # Optional custom database path\n    block_cloud_providers={\"AWS\", \"GCP\"}  # Case-sensitive provider names\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-blocking","title":"Country Blocking","text":"<p>Block requests from specific countries using ISO 3166-1 alpha-2 country codes:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    blocked_countries=[\n        \"CN\",  # China\n        \"RU\",  # Russia\n        \"IR\",  # Iran\n        \"KP\"   # North Korea\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-whitelisting","title":"Country Whitelisting","text":"<p>Only allow requests from specific countries:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    whitelist_countries=[\n        \"US\",  # United States\n        \"CA\",  # Canada\n        \"GB\",  # United Kingdom\n        \"AU\"   # Australia\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#custom-geolocation-logic","title":"Custom Geolocation Logic","text":"<p>You can also use the <code>IPInfoManager</code> directly for custom geolocation logic:</p> <pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\n\nipinfo_db = IPInfoManager(token=\"your_ipinfo_token_here\")  # NOTE: Required when using custom geolocation\nawait ipinfo_db.initialize()\n\n@app.get(\"/country/{ip}\")\nasync def get_ip_country(ip: str):\n    country = ipinfo_db.get_country(ip)\n    return {\"ip\": ip, \"country\": country}\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security feature that protects your API from abuse, DoS attacks, and excessive usage. FastAPI Guard provides a robust rate limiting system through the dedicated <code>RateLimitManager</code> class.</p>"},{"location":"tutorial/ip-management/rate-limiter/#basic-configuration","title":"Basic Configuration","text":"<p>To enable rate limiting, configure the following parameters in your <code>SecurityConfig</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,               # Maximum number of requests allowed\n    rate_limit_window=60,         # Time window in seconds\n    # ... other configuration options ...\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#how-it-works","title":"How It Works","text":"<p>FastAPI Guard implements a sliding window rate limiting algorithm:</p> <ol> <li>Each client request is tracked using a timestamp</li> <li>Only requests within the current time window (last <code>rate_limit_window</code> seconds) are counted</li> <li>When a new request arrives, timestamps older than the window are automatically discarded</li> <li>If the count of valid timestamps exceeds <code>rate_limit</code>, the request is rejected with a 429 status</li> <li>This ensures precise rate limiting without artificial time boundaries</li> </ol> <p>The sliding window approach offers several advantages over fixed windows: - No traffic spikes at window boundaries - More consistent load on your API - Fair treatment of users across time periods - More accurate request counting</p>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-vs-redis-rate-limiting","title":"In-Memory vs. Redis Rate Limiting","text":"<p>FastAPI Guard supports two rate limiting storage backends:</p>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-rate-limiting","title":"In-Memory Rate Limiting","text":"<p>By default, rate limiting uses an in-memory deque for tracking request timestamps:</p> <pre><code>config = SecurityConfig(\n    # Rate limit is enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    enable_redis=False,\n)\n</code></pre> <p>Pros: - Simple setup (no external dependencies) - Fast performance - Automatic cleanup of old timestamps - True sliding window algorithm</p> <p>Cons: - Doesn't work across multiple application instances - Lost on application restart - Consumes application memory</p>"},{"location":"tutorial/ip-management/rate-limiter/#redis-based-rate-limiting","title":"Redis-Based Rate Limiting","text":"<p>For distributed environments, enable Redis-based rate limiting:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"myapp:\"  # Optional prefix for Redis keys (override default)\n)\n</code></pre> <p>Pros: - Works across multiple application instances - Persists through application restarts - Uses atomic Lua scripts for reliable concurrency handling - Consistent rate limiting across distributed systems</p> <p>Cons: - Requires a Redis server - Slightly higher latency due to network calls - Additional infrastructure dependency</p>"},{"location":"tutorial/ip-management/rate-limiter/#custom-response-messages","title":"Custom Response Messages","text":"<p>You can customize the rate limit exceeded message:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    custom_error_responses={\n        429: \"Rate limit exceeded. Please try again later.\"\n    }\n)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorial/ip-management/rate-limiter/#accessing-the-rate-limiter-directly","title":"Accessing the Rate Limiter Directly","text":"<p>For advanced use cases, you can access the rate limiter directly:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nasync def some_route():\n    # Get a reference to the handler\n    handler = rate_limit_handler(config)\n\n    # Reset rate limits (e.g., for a premium user)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#resetting-rate-limits","title":"Resetting Rate Limits","text":"<p>You might want to reset rate limits in certain scenarios:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\nasync def reset_rate_limits_for_user(user_id: str):\n    handler = rate_limit_handler(config)\n\n    # Clear all rate limits (use with caution)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#implementation-details","title":"Implementation Details","text":"<p>The <code>RateLimitManager</code> is implemented as a singleton to ensure consistent state across requests. It uses:</p> <ul> <li>TTLCache for in-memory storage with automatic expiration</li> <li>Redis increments with TTL for distributed storage</li> <li>Efficient counter storage to minimize memory footprint</li> </ul>"},{"location":"tutorial/ip-management/rate-limiter/#best-practices","title":"Best Practices","text":"<ol> <li>Set reasonable limits: Consider your API's typical usage patterns</li> <li>Use Redis in production: For reliability in distributed environments</li> <li>Implement graduated limits: Consider different limits for different API endpoints</li> <li>Inform clients: Return appropriate headers with rate limit information</li> <li>Monitor usage patterns: Keep an eye on rate limit hits to adjust as needed</li> </ol>"},{"location":"tutorial/ip-management/rate-limiter/#see-also","title":"See Also","text":"<ul> <li>RateLimitManager API Reference</li> <li>Redis Integration</li> <li>Security Middleware</li> </ul>"},{"location":"tutorial/redis-integration/caching/","title":"Redis Integration","text":"<p>FastAPI Guard uses Redis for distributed state management across multiple instances.</p>"},{"location":"tutorial/redis-integration/caching/#basic-configuration","title":"Basic Configuration","text":"<pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod-redis:6379/1\",\n    redis_prefix=\"myapp:security:\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-features","title":"Key Features","text":"<ul> <li>Distributed Rate Limiting</li> <li>Shared IP Ban List</li> <li>Cloud IP Range Caching</li> <li>Pattern Storage for Penetration Detection</li> </ul>"},{"location":"tutorial/redis-integration/caching/#fallback-behavior","title":"Fallback Behavior","text":"<p>When Redis is disabled (<code>enable_redis=False</code>):</p> <ul> <li>Uses in-memory storage (TTLCache)</li> <li>Rate limits are instance-local</li> <li>IP bans only affect current instance</li> <li>Cloud IP ranges refresh hourly</li> </ul>"},{"location":"tutorial/redis-integration/caching/#connection-management","title":"Connection Management","text":"<pre><code># Get RedisManager instance from middleware\nredis = request.app.state.security_middleware.redis_handler\n\n# Manual connection handling example\nasync with redis.get_connection() as conn:\n    await conn.set(\"key\", \"value\")\n\n# Automatic operation retry with proper arguments\nawait redis.safe_operation(\n    lambda conn: conn.get(\"my_key\"),\n    namespace=\"data\",\n    key=\"my_key\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-namespacing","title":"Key Namespacing","text":"<p>Keys are automatically prefixed using: <code>{redis_prefix}{namespace}:{key}</code></p> <p>Example: <code>fastapi_guard:cloud_ranges:AWS</code></p>"},{"location":"tutorial/redis-integration/caching/#best-practices","title":"Best Practices","text":"<ol> <li>Use separate Redis databases for different environments</li> <li>Set appropriate TTLs for transient data</li> <li>Monitor connection pool size in high-traffic deployments</li> <li>Use <code>safe_operation</code> for all Redis interactions</li> </ol>"},{"location":"tutorial/security/custom-patterns/","title":"Custom Patterns","text":"<p>FastAPI Guard allows you to add custom patterns for detecting suspicious activity.</p>"},{"location":"tutorial/security/custom-patterns/#adding-custom-patterns","title":"Adding Custom Patterns","text":"<p>Add your own patterns to the detection system:</p> <pre><code>from guard.handlers.suspatterns_handler import SusPatternsManager\n\nasync def setup_patterns():\n    # Add custom pattern\n    await SusPatternsManager.add_pattern(\n        r\"malicious_pattern.*\",\n        custom=True\n    )\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-types","title":"Pattern Types","text":"<p>You can add patterns for different types of attacks:</p> <pre><code># Custom XSS pattern\nawait SusPatternsManager.add_pattern(\n    r\"&lt;script\\s*src=.*&gt;\",\n    custom=True\n)\n\n# Custom SQL injection pattern\nawait SusPatternsManager.add_pattern(\n    r\";\\s*DROP\\s+TABLE\",\n    custom=True\n)\n\n# Custom file path pattern\nawait SusPatternsManager.add_pattern(\n    r\"\\.\\.\\/.*\\/etc\\/passwd\",\n    custom=True\n)\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#managing-patterns","title":"Managing Patterns","text":"<p>Remove or modify existing patterns:</p> <pre><code># Remove a custom pattern\nsuccess = await SusPatternsManager.remove_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\nif success:\n    print(\"Pattern removed successfully\")\nelse:\n    print(\"Pattern not found\")\n\n# Get all patterns (both default and custom)\nall_patterns = await SusPatternsManager.get_all_patterns()\n\n# Get only default patterns\ndefault_patterns = await SusPatternsManager.get_default_patterns()\n\n# Get only custom patterns\ncustom_patterns = await SusPatternsManager.get_custom_patterns()\n\n# Get all compiled patterns\nall_compiled_patterns = await SusPatternsManager.get_all_compiled_patterns()\n\n# Get only default compiled patterns\ndefault_compiled = await SusPatternsManager.get_default_compiled_patterns()\n\n# Get only custom compiled patterns\ncustom_compiled = await SusPatternsManager.get_custom_compiled_patterns()\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-testing","title":"Pattern Testing","text":"<p>Test your patterns against requests:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/test/patterns\")\nasync def test_patterns(request: Request):\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    return {\n        \"suspicious\": is_suspicious,\n        \"trigger_info\": trigger_info,\n        \"request_body\": await request.body()\n    }\n</code></pre>"},{"location":"tutorial/security/http-security-headers/","title":"HTTP Security Headers","text":"<p>FastAPI Guard provides comprehensive HTTP security header management to protect your application from various web vulnerabilities. This tutorial covers how to configure and use security headers following OWASP best practices.</p>"},{"location":"tutorial/security/http-security-headers/#overview","title":"Overview","text":"<p>Security headers are HTTP response headers that provide an additional layer of security by instructing browsers on how to handle your application's content. FastAPI Guard automatically manages these headers through the <code>SecurityHeadersManager</code>.</p>"},{"location":"tutorial/security/http-security-headers/#quick-start","title":"Quick Start","text":""},{"location":"tutorial/security/http-security-headers/#basic-setup","title":"Basic Setup","text":"<p>Enable security headers with default OWASP-recommended settings:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    security_headers={\n        \"enabled\": True  # Uses secure defaults\n    }\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre> <p>This automatically adds:</p> <ul> <li><code>X-Content-Type-Options: nosniff</code></li> <li><code>X-Frame-Options: SAMEORIGIN</code></li> <li><code>X-XSS-Protection: 1; mode=block</code></li> <li><code>Referrer-Policy: strict-origin-when-cross-origin</code></li> <li><code>Permissions-Policy: geolocation=(), microphone=(), camera=()</code></li> <li><code>X-Permitted-Cross-Domain-Policies: none</code></li> <li><code>X-Download-Options: noopen</code></li> <li><code>Cross-Origin-Embedder-Policy: require-corp</code></li> <li><code>Cross-Origin-Opener-Policy: same-origin</code></li> <li><code>Cross-Origin-Resource-Policy: same-origin</code></li> </ul>"},{"location":"tutorial/security/http-security-headers/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"enabled\": True,\n        \"hsts\": {\n            \"max_age\": 31536000,  # 1 year\n            \"include_subdomains\": True,\n            \"preload\": False\n        },\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\", \"https://cdn.jsdelivr.net\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n            \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n        },\n        \"frame_options\": \"DENY\",\n        \"referrer_policy\": \"no-referrer\"\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#content-security-policy-csp","title":"Content Security Policy (CSP)","text":"<p>CSP is one of the most powerful security headers, preventing XSS attacks by controlling which resources can be loaded.</p>"},{"location":"tutorial/security/http-security-headers/#basic-csp","title":"Basic CSP","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\"],\n            \"style-src\": [\"'self'\"],\n            \"img-src\": [\"'self'\", \"data:\"],\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#progressive-csp-implementation","title":"Progressive CSP Implementation","text":"<p>Start with a permissive policy and gradually tighten:</p> <pre><code># Step 1: Permissive policy\nconfig = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\", \"'unsafe-inline'\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n            \"report-uri\": [\"/api/csp-report\"]\n        }\n    }\n)\n\n# Step 2: Remove unsafe-inline for scripts\nconfig = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n        }\n    }\n)\n\n# Step 3: Strict CSP\nconfig = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'none'\"],\n            \"script-src\": [\"'self'\"],\n            \"style-src\": [\"'self'\"],\n            \"img-src\": [\"'self'\"],\n            \"connect-src\": [\"'self'\"],\n            \"font-src\": [\"'self'\"],\n            \"base-uri\": [\"'self'\"],\n            \"form-action\": [\"'self'\"],\n            \"frame-ancestors\": [\"'none'\"],\n            \"upgrade-insecure-requests\": []\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#csp-for-single-page-applications","title":"CSP for Single Page Applications","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\"],\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],  # For dynamic styles\n            \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n            \"connect-src\": [\"'self'\", \"https://api.example.com\"],\n            \"font-src\": [\"'self'\", \"https://fonts.gstatic.com\"],\n            \"frame-ancestors\": [\"'none'\"],\n            \"base-uri\": [\"'self'\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#csp-violation-reporting","title":"CSP Violation Reporting","text":"<p>Set up an endpoint to receive CSP violation reports:</p> <pre><code>from fastapi import Request\n\n@app.post(\"/api/csp-report\")\nasync def csp_report(request: Request):\n    from guard.handlers.security_headers_handler import security_headers_manager\n\n    report = await request.json()\n    is_valid = await security_headers_manager.validate_csp_report(report)\n\n    if is_valid:\n        # Log the violation (handled automatically)\n        return {\"status\": \"received\"}\n\n    return {\"status\": \"invalid\"}, 400\n\n# Configure CSP with reporting\nconfig = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"report-uri\": [\"/api/csp-report\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#http-strict-transport-security-hsts","title":"HTTP Strict Transport Security (HSTS)","text":"<p>HSTS ensures that browsers only connect to your site over HTTPS.</p>"},{"location":"tutorial/security/http-security-headers/#basic-hsts","title":"Basic HSTS","text":"<pre><code>config = SecurityConfig(\n    security_headers={\n        \"hsts\": {\n            \"max_age\": 31536000,  # 1 year\n            \"include_subdomains\": True,\n            \"preload\": False\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#hsts-rollout-strategy","title":"HSTS Rollout Strategy","text":"<pre><code># Phase 1: Short duration (5 minutes)\nconfig = SecurityConfig(\n    security_headers={\n        \"hsts\": {\n            \"max_age\": 300,\n            \"include_subdomains\": False,\n            \"preload\": False\n        }\n    }\n)\n\n# Phase 2: Longer duration (1 week)\nconfig = SecurityConfig(\n    security_headers={\n        \"hsts\": {\n            \"max_age\": 604800,\n            \"include_subdomains\": True,\n            \"preload\": False\n        }\n    }\n)\n\n# Phase 3: Production (1 year + preload)\nconfig = SecurityConfig(\n    security_headers={\n        \"hsts\": {\n            \"max_age\": 31536000,  # Required for preload\n            \"include_subdomains\": True,  # Required for preload\n            \"preload\": True\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#clickjacking-protection","title":"Clickjacking Protection","text":"<p>Prevent your site from being embedded in frames:</p> <pre><code># Option 1: Deny all framing\nconfig = SecurityConfig(\n    security_headers={\n        \"frame_options\": \"DENY\"\n    }\n)\n\n# Option 2: Allow same-origin framing\nconfig = SecurityConfig(\n    security_headers={\n        \"frame_options\": \"SAMEORIGIN\"\n    }\n)\n\n# Option 3: Use CSP frame-ancestors (more flexible)\nconfig = SecurityConfig(\n    security_headers={\n        \"frame_options\": None,  # Disable X-Frame-Options\n        \"csp\": {\n            \"frame-ancestors\": [\"'self'\", \"https://trusted.example.com\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#cors-and-security-headers","title":"CORS and Security Headers","text":"<p>Security headers work alongside CORS configuration:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\"https://app.example.com\"],\n    cors_allow_credentials=True,\n    cors_allow_methods=[\"GET\", \"POST\"],\n    cors_allow_headers=[\"*\"],\n\n    security_headers={\n        \"enabled\": True,\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"connect-src\": [\"'self'\", \"https://app.example.com\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#custom-headers","title":"Custom Headers","text":"<p>Add application-specific security headers:</p> <pre><code>config = SecurityConfig(\n    security_headers={\n        \"custom\": {\n            \"X-Permitted-Cross-Domain-Policies\": \"none\",\n            \"X-Download-Options\": \"noopen\",\n            \"X-DNS-Prefetch-Control\": \"off\",\n            \"X-Robots-Tag\": \"noindex, nofollow\"\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Different headers for development and production:</p> <pre><code>import os\n\nis_production = os.getenv(\"ENVIRONMENT\") == \"production\"\n\nconfig = SecurityConfig(\n    security_headers={\n        \"enabled\": True,\n        \"hsts\": {\n            \"max_age\": 31536000 if is_production else 0,\n            \"include_subdomains\": is_production,\n            \"preload\": is_production\n        },\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\"] + ([] if is_production else [\"'unsafe-inline'\"]),\n            \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n        } if is_production else None  # Disable CSP in development\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#redis-integration","title":"Redis Integration","text":"<p>Security headers configuration is cached in Redis for performance:</p> <pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://localhost:6379\",\n\n    security_headers={\n        \"enabled\": True,\n        \"csp\": {\n            \"default-src\": [\"'self'\"]\n        }\n    }\n)\n\n# Headers are cached with TTL of 24 hours\n# Cache keys:\n# - security_headers:csp_config\n# - security_headers:hsts_config\n# - security_headers:custom_headers\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#testing-security-headers","title":"Testing Security Headers","text":""},{"location":"tutorial/security/http-security-headers/#using-curl","title":"Using curl","text":"<pre><code># Check security headers\ncurl -I https://your-app.com\n\n# Check CSP header\ncurl -I https://your-app.com | grep -i content-security-policy\n\n# Test CORS headers\ncurl -H \"Origin: https://app.example.com\" \\\n     -I https://your-app.com\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#automated-testing","title":"Automated Testing","text":"<pre><code>import pytest\nfrom fastapi.testclient import TestClient\n\ndef test_security_headers(client: TestClient):\n    response = client.get(\"/\")\n\n    # Check essential headers\n    assert response.headers.get(\"X-Content-Type-Options\") == \"nosniff\"\n    assert response.headers.get(\"X-Frame-Options\") == \"SAMEORIGIN\"\n    assert \"strict-origin\" in response.headers.get(\"Referrer-Policy\", \"\")\n\n    # Check HSTS\n    hsts = response.headers.get(\"Strict-Transport-Security\", \"\")\n    assert \"max-age=31536000\" in hsts\n\n    # Check CSP\n    csp = response.headers.get(\"Content-Security-Policy\", \"\")\n    assert \"default-src 'self'\" in csp\n\ndef test_csp_violation_reporting(client: TestClient):\n    report = {\n        \"csp-report\": {\n            \"document-uri\": \"https://example.com\",\n            \"violated-directive\": \"script-src\",\n            \"blocked-uri\": \"https://evil.com/script.js\"\n        }\n    }\n\n    response = client.post(\"/api/csp-report\", json=report)\n    assert response.status_code == 200\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"tutorial/security/http-security-headers/#enable-logging","title":"Enable Logging","text":"<pre><code>import logging\n\n# Configure logging for security headers\nlogging.getLogger(\"fastapi_guard.handlers.security_headers\").setLevel(logging.DEBUG)\n\nconfig = SecurityConfig(\n    custom_log_file=\"security.log\",\n    security_headers={\"enabled\": True}\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#agent-integration","title":"Agent Integration","text":"<p>Monitor security header events with FastAPI Guard Agent:</p> <pre><code>config = SecurityConfig(\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n\n    security_headers={\n        \"enabled\": True,\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"report-uri\": [\"/api/csp-report\"]\n        }\n    }\n)\n\n# Events sent to agent:\n# - security_headers_applied: When headers are added\n# - csp_violation: When CSP violations occur\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorial/security/http-security-headers/#issue-inline-scripts-blocked-by-csp","title":"Issue: Inline Scripts Blocked by CSP","text":"<p>Solution: Use external scripts</p> <pre><code>&lt;!-- Instead of inline --&gt;\n&lt;script&gt;console.log('Hello')&lt;/script&gt;\n\n&lt;!-- Use external --&gt;\n&lt;script src=\"/static/app.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Or allow unsafe-inline in your CSP configuration (less secure):</p> <pre><code>config = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"script-src\": [\"'self'\", \"'unsafe-inline'\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#issue-third-party-resources-blocked","title":"Issue: Third-Party Resources Blocked","text":"<p>Solution: Add specific sources to CSP</p> <pre><code>config = SecurityConfig(\n    security_headers={\n        \"csp\": {\n            \"default-src\": [\"'self'\"],\n            \"script-src\": [\"'self'\", \"https://cdn.jsdelivr.net\"],\n            \"style-src\": [\"'self'\", \"https://fonts.googleapis.com\"],\n            \"font-src\": [\"'self'\", \"https://fonts.gstatic.com\"]\n        }\n    }\n)\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#issue-hsts-causing-access-issues","title":"Issue: HSTS Causing Access Issues","text":"<p>Solution: Start with short max_age</p> <pre><code># Start with 5 minutes\nconfig = SecurityConfig(\n    security_headers={\n        \"hsts\": {\"max_age\": 300}\n    }\n)\n\n# Gradually increase after testing\n</code></pre>"},{"location":"tutorial/security/http-security-headers/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Header Caching: Headers are cached in memory (TTL: 300 seconds) and Redis (TTL: 24 hours)</li> <li>CSP Complexity: Complex CSP policies may impact page load time</li> </ol>"},{"location":"tutorial/security/http-security-headers/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Header Injection Prevention: FastAPI Guard automatically validates all header values against injection attacks</li> <li>CORS Security: Wildcard origins (<code>*</code>) are automatically blocked when credentials are enabled</li> <li>Thread Safety: The SecurityHeadersManager uses thread-safe patterns for production environments</li> <li>Cache Security: Secure cache key generation prevents cache poisoning attacks</li> <li>Input Validation: All header values are sanitized for newlines, control characters, and excessive length</li> <li>Start Restrictive: Begin with strict policies and relax as needed</li> <li>Monitor Violations: Set up CSP reporting and monitoring</li> <li>Test Thoroughly: Test header changes before production deployment</li> <li>Use HTTPS: Many security headers require HTTPS to be effective</li> </ol>"},{"location":"tutorial/security/http-security-headers/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"tutorial/security/http-security-headers/#online-tools","title":"Online Tools","text":"<ul> <li>Security Headers Scanner</li> <li>CSP Evaluator</li> <li>Mozilla Observatory</li> </ul>"},{"location":"tutorial/security/http-security-headers/#browser-extensions","title":"Browser Extensions","text":"<ul> <li>CSP Evaluator Extension</li> <li>Security Headers Extension</li> </ul>"},{"location":"tutorial/security/http-security-headers/#references","title":"References","text":"<ul> <li>OWASP Secure Headers Project</li> <li>MDN Web Docs: HTTP Headers</li> <li>Content Security Policy Reference</li> </ul>"},{"location":"tutorial/security/http-security-headers/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>Configuration - Complete configuration options</li> <li>Security Middleware - Middleware integration</li> </ul>"},{"location":"tutorial/security/monitoring/","title":"Security Monitoring","text":"<p>FastAPI Guard provides robust security logging capabilities that can be leveraged for monitoring and analytics. This guide covers how to work with the logs generated by FastAPI Guard and options for deeper security analytics.</p>"},{"location":"tutorial/security/monitoring/#basic-logging","title":"Basic Logging","text":"<p>By default, FastAPI Guard logs all security events to standard Python logging facilities. You can configure custom log paths using the <code>custom_log_file</code> parameter in the <code>SecurityConfig</code>.</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"/path/to/security.log\"\n)\n</code></pre>"},{"location":"tutorial/security/monitoring/#passive-mode-for-penetration-detection","title":"Passive Mode for Penetration Detection","text":"<p>When deploying in production environments, it's often best to start with passive mode to understand your traffic patterns before enabling blocking rules.</p> <pre><code>config = SecurityConfig(\n    enable_penetration_detection=True,\n    passive_mode=True  # Log but don't block\n)\n</code></pre> <p>In passive mode, FastAPI Guard will detect potential penetration attempts, but instead of blocking the request, it will only log the incident with the prefix <code>[PASSIVE MODE]</code> in your logs. This helps identify false positives before enabling full blocking mode.</p>"},{"location":"tutorial/security/monitoring/#configurable-log-levels","title":"Configurable Log Levels","text":"<p>FastAPI Guard allows you to configure different log levels for normal and suspicious requests:</p> <pre><code>config = SecurityConfig(\n    # Normal requests logged at INFO level (or None to disable)\n    log_request_level=\"INFO\",\n    # Security events logged at WARNING level\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre> <p>This separation allows:</p> <ul> <li>Quieter logs in production by disabling or reducing normal request logging</li> <li>Maintaining visibility for security events</li> <li>Different log routing based on severity</li> </ul> <p>Available log levels include: <code>\"INFO\"</code>, <code>\"DEBUG\"</code>, <code>\"WARNING\"</code>, <code>\"ERROR\"</code>, <code>\"CRITICAL\"</code>, and <code>None</code> (to disable).</p>"},{"location":"tutorial/security/monitoring/#log-analysis","title":"Log Analysis","text":"<p>FastAPI Guard logs contain valuable security intelligence, including:</p> <ul> <li>IP addresses attempting suspicious actions</li> <li>Pattern matches indicating attack vectors (SQL injection, XSS, etc.)</li> <li>Geographic origins of traffic</li> <li>Rate limiting violations</li> <li>Cloud provider origins</li> </ul> <p>You can use standard log analysis tools to process and visualize these logs.</p>"},{"location":"tutorial/security/penetration-detection/","title":"Penetration Detection","text":"<p>FastAPI Guard includes sophisticated penetration attempt detection to identify and block malicious requests.</p>"},{"location":"tutorial/security/penetration-detection/#basic-configuration","title":"Basic Configuration","text":"<p>Enable penetration detection with the enhanced Detection Engine:</p> <pre><code>config = SecurityConfig(\n    # Core detection settings\n    enable_penetration_detection=True,\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600,  # Ban duration in seconds\n\n    # Detection Engine configuration\n    detection_compiler_timeout=2.0,  # Pattern matching timeout\n    detection_max_content_length=10000,  # Max content to analyze\n    detection_preserve_attack_patterns=True,  # Preserve attacks during truncation\n    detection_semantic_threshold=0.7,  # Semantic detection threshold (0.0-1.0)\n\n    # Performance monitoring\n    detection_anomaly_threshold=3.0,  # Standard deviations for anomaly\n    detection_slow_pattern_threshold=0.1,  # Slow pattern threshold (seconds)\n    detection_monitor_history_size=1000,  # Metrics history size\n    detection_max_tracked_patterns=1000,  # Max patterns to track\n)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#detection-patterns","title":"Detection Patterns","text":"<p>The system checks for various attack patterns including:</p> <ul> <li>SQL Injection attempts</li> <li>XSS (Cross-Site Scripting)</li> <li>Command Injection</li> <li>Path Traversal</li> <li>Template Injection</li> <li>HTTP Response Splitting</li> <li>LDAP Injection</li> <li>XML Injection</li> <li>NoSQL Injection</li> <li>File Upload attacks</li> </ul>"},{"location":"tutorial/security/penetration-detection/#enhanced-detection-features","title":"Enhanced Detection Features","text":"<p>The new Detection Engine provides advanced threat detection capabilities:</p>"},{"location":"tutorial/security/penetration-detection/#multi-layered-detection","title":"Multi-layered Detection","text":"<ul> <li>Pattern Matching: Regex-based detection with timeout protection</li> <li>Semantic Analysis: AI-powered detection of obfuscated attacks</li> <li>Performance Monitoring: Real-time tracking of pattern effectiveness</li> </ul>"},{"location":"tutorial/security/penetration-detection/#comprehensive-results","title":"Comprehensive Results","text":"<p>The detection engine returns detailed information about threats:</p> <pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Direct detection with rich results\nresult = await sus_patterns_handler.detect(\n    content=\"SELECT * FROM users WHERE id=1 OR 1=1\",\n    ip_address=\"192.168.1.100\",\n    context=\"query_param\"\n)\n\nif result[\"is_threat\"]:\n    print(f\"Threat Score: {result['threat_score']}\")  # 0.0 to 1.0\n    for threat in result[\"threats\"]:\n        if threat[\"type\"] == \"regex\":\n            print(f\"Pattern: {threat['pattern']}\")\n        elif threat[\"type\"] == \"semantic\":\n            print(f\"Attack Type: {threat['attack_type']}\")\n            print(f\"Probability: {threat['probability']}\")\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#performance-analytics","title":"Performance Analytics","text":"<p>Monitor and optimize detection performance:</p> <pre><code># Get performance statistics\nstats = await sus_patterns_handler.get_performance_stats()\nprint(f\"Slow patterns: {stats['slow_patterns']}\")\nprint(f\"Problematic patterns: {stats['problematic_patterns']}\")\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#custom-detection-logic","title":"Custom Detection Logic","text":"<p>You can use the penetration detection directly in your routes:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/api/data\")\nasync def submit_data(request: Request):\n    # Legacy method (still supported)\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    if is_suspicious:\n        return JSONResponse(\n            status_code=400,\n            content={\"error\": f\"Suspicious activity detected: {trigger_info}\"}\n        )\n    # Process legitimate request\n    return {\"status\": \"success\"}\n</code></pre> <p>For more control, use the enhanced detection API:</p> <pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n@app.post(\"/api/secure\")\nasync def secure_endpoint(request: Request, data: dict):\n    # Check request body with enhanced detection\n    result = await sus_patterns_handler.detect(\n        content=json.dumps(data),\n        ip_address=request.client.host,\n        context=\"request_body\"\n    )\n\n    if result[\"is_threat\"] and result[\"threat_score\"] &gt; 0.8:\n        # High-confidence threat detected\n        threat_types = [t.get(\"attack_type\", t[\"type\"]) for t in result[\"threats\"]]\n        return JSONResponse(\n            status_code=403,\n            content={\"error\": f\"Threat detected: {', '.join(threat_types)}\"}\n        )\n\n    # Process request\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#logging-suspicious-activity","title":"Logging Suspicious Activity","text":"<p>Configure logging for suspicious activities:</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"security.log\",\n    log_level=\"WARNING\"\n)\n</code></pre> <p>Example log output:</p> <pre><code>2024-01-20 10:15:23 - WARNING - Suspicious activity detected from 192.168.1.1: POST /api/data - Reason: SQL injection attempt\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#passive-mode","title":"Passive Mode","text":"<p>When <code>passive_mode</code> is enabled, FastAPI Guard will:</p> <ol> <li>Detect potential penetration attempts (work as usual)</li> <li>Log them with detailed information about what triggered the detection</li> <li>Allow the requests to proceed without blocking</li> </ol> <p>This helps you understand your traffic patterns and fine-tune your security settings before enforcing blocks that might affect legitimate users.</p>"},{"location":"tutorial/security/penetration-detection/#how-to-use-passive-mode","title":"How to Use Passive Mode","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\n\napp = FastAPI()\n\n# Create a configuration with passive mode enabled\nconfig = SecurityConfig(\n    enable_penetration_detection=True,  # True by default\n    passive_mode=True,  # Enable passive mode\n)\n\n# Add the middleware to your application\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#checking-logs","title":"Checking Logs","text":"<p>When using passive mode, watch your logs for entries starting with \"[PASSIVE MODE]\". These entries provide detailed information about what triggered the detection, including:</p> <ul> <li>The client's IP address</li> <li>The HTTP method and URL</li> <li>The specific pattern that was matched</li> <li>Which part of the request triggered the detection (query parameter, body, header, etc.)</li> <li>Threat score and attack type (for semantic detection)</li> <li>Performance metrics and timeouts</li> </ul>"},{"location":"tutorial/security/penetration-detection/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"tutorial/security/penetration-detection/#pattern-management","title":"Pattern Management","text":"<p>Add or remove custom patterns:</p> <pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Add custom pattern\nawait sus_patterns_handler.add_pattern(\n    r\"(?i)exec\\s*\\(\\s*['\\\"].*['\\\"]\\s*\\)\",  # Detect exec() calls\n    custom=True\n)\n\n# Remove pattern\nawait sus_patterns_handler.remove_pattern(\n    r\"(?i)exec\\s*\\(\\s*['\\\"].*['\\\"]\\s*\\)\",\n    custom=True\n)\n\n# Get all patterns\npatterns = await sus_patterns_handler.get_all_patterns()\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#semantic-threshold-tuning","title":"Semantic Threshold Tuning","text":"<p>Adjust the semantic detection sensitivity:</p> <pre><code># More strict (fewer false positives, might miss some attacks)\nawait sus_patterns_handler.configure_semantic_threshold(0.9)\n\n# More lenient (catch more attacks, might have false positives)\nawait sus_patterns_handler.configure_semantic_threshold(0.5)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#component-status","title":"Component Status","text":"<p>Check which detection components are active:</p> <pre><code>status = await sus_patterns_handler.get_component_status()\n# Returns: {\n#     \"compiler\": True,\n#     \"preprocessor\": True,\n#     \"semantic_analyzer\": True,\n#     \"performance_monitor\": True\n# }\n</code></pre> <p>Integration with FastAPI Guard Agent</p> <p>When the Guard Agent is enabled, the Detection Engine automatically:</p> <ul> <li>Sends detailed threat detection events</li> <li>Reports pattern performance metrics</li> <li>Tracks pattern effectiveness</li> <li>Shares threat intelligence</li> </ul> <p>Configure with:</p> <pre><code>config = SecurityConfig(\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_enable_events=True,\n    agent_enable_metrics=True,\n    # ... other settings\n)\n</code></pre> <p>Best Practices</p> <ol> <li>Start with Passive Mode: Test detection patterns without blocking traffic</li> <li>Monitor Performance: Review slow patterns regularly</li> <li>Tune Thresholds: Adjust based on your false positive tolerance</li> <li>Update Patterns: Keep patterns updated with latest attack vectors</li> <li>Use Correlation IDs: Track related detections across requests</li> </ol> <p>Further Reading</p> <ul> <li>Detection Engine Overview</li> <li>Detection Engine Architecture</li> <li>Detection Engine Components</li> <li>Performance Tuning Guide</li> </ul>"},{"location":"tutorial/security/proxy-security/","title":"Proxy Security","text":"<p>When your application is behind a proxy, load balancer, or CDN, properly handling the <code>X-Forwarded-For</code> header is critical for security. FastAPI Guard implements a secure approach to prevent IP spoofing attacks.</p>"},{"location":"tutorial/security/proxy-security/#the-problem","title":"The Problem","text":"<p>The <code>X-Forwarded-For</code> header is sent by proxies to identify the original client IP, but since it can be manipulated by clients, it poses a security risk if trusted blindly.</p> <p>Common security issues include:</p> <ul> <li>IP spoofing to bypass IP-based access controls</li> <li>False attribution in security logs</li> <li>Bypassing rate limiting and IP bans</li> </ul>"},{"location":"tutorial/security/proxy-security/#secure-configuration","title":"Secure Configuration","text":"<p>FastAPI Guard implements a secure-by-default approach where X-Forwarded-For headers are only trusted from explicitly configured trusted proxies:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # List of trusted proxy IPs/ranges\n    trusted_proxy_depth=1,  # Number of proxies in the chain (default: 1)\n    trust_x_forwarded_proto=True,  # Whether to trust X-Forwarded-Proto for HTTPS detection\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#how-it-works","title":"How It Works","text":"<ol> <li>When a request arrives, FastAPI Guard checks if it's from a trusted proxy</li> <li>If not from a trusted proxy, the direct connecting IP is always used</li> <li>If from a trusted proxy, the X-Forwarded-For header is parsed to extract the original client IP</li> <li>The extracted IP is then used for all security checks</li> </ol>"},{"location":"tutorial/security/proxy-security/#configuration-options","title":"Configuration Options","text":""},{"location":"tutorial/security/proxy-security/#trusted_proxies","title":"trusted_proxies","text":"<p>List of IP addresses or CIDR ranges that are allowed to set X-Forwarded-For headers:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.1\",         # Single IP\n        \"192.168.1.0/24\",   # CIDR range\n        \"172.16.0.0/16\"     # Another CIDR range\n    ]\n)\n</code></pre> <p>If empty (default), X-Forwarded-For headers will not be trusted at all.</p>"},{"location":"tutorial/security/proxy-security/#trusted_proxy_depth","title":"trusted_proxy_depth","text":"<p>Controls how the client IP is extracted from the X-Forwarded-For header:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],\n    trusted_proxy_depth=2  # Assumes two proxies in the chain\n)\n</code></pre> <p>The X-Forwarded-For format is: <code>client, proxy1, proxy2, ...</code> (leftmost is the original client) - With depth=1 (default): Assumes one proxy in chain, uses leftmost IP as client - With depth=2: Assumes two proxies in chain, still uses leftmost IP - Higher values handle more complex proxy chains</p>"},{"location":"tutorial/security/proxy-security/#trust_x_forwarded_proto","title":"trust_x_forwarded_proto","text":"<p>Whether to trust the X-Forwarded-Proto header for HTTPS detection:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],\n    trust_x_forwarded_proto=True  # Trust X-Forwarded-Proto from trusted proxies\n)\n</code></pre> <p>This only applies when the request comes from a trusted proxy.</p>"},{"location":"tutorial/security/proxy-security/#real-world-examples","title":"Real-World Examples","text":""},{"location":"tutorial/security/proxy-security/#single-reverse-proxy","title":"Single Reverse Proxy","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],  # Your Nginx/HAProxy IP\n    trusted_proxy_depth=1,         # One proxy\n    trust_x_forwarded_proto=True   # Trust HTTPS status from proxy\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#load-balancer-proxy","title":"Load Balancer + Proxy","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.1\",         # Load balancer IP\n        \"192.168.1.0/24\"    # Internal proxy subnet\n    ],\n    trusted_proxy_depth=2,  # Two proxies in chain\n    trust_x_forwarded_proto=True\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#cloud-provider-load-balancer","title":"Cloud Provider Load Balancer","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.0/8\"        # Cloud provider's internal IP range\n    ],\n    trusted_proxy_depth=1,\n    trust_x_forwarded_proto=True\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#best-practices","title":"Best Practices","text":"<ol> <li>Be specific: Only include the exact IPs or ranges of your known proxies</li> <li>Use correct depth: Configure based on your actual proxy chain</li> <li>Regular audits: Periodically review your trusted proxy list</li> <li>Test configuration: Verify correct IP extraction in your environment</li> </ol>"},{"location":"tutorial/security/detection-engine/architecture/","title":"Detection Engine Architecture","text":"<p>The FastAPI Guard Detection Engine uses a modular architecture that provides timeout-protected pattern matching with optional preprocessing and heuristic analysis. This document describes the actual implementation and how components interact.</p>"},{"location":"tutorial/security/detection-engine/architecture/#system-architecture","title":"System Architecture","text":"<pre><code>flowchart TD\n    Request[FastAPI Request] --&gt; Middleware[SecurityMiddleware&lt;br/&gt;\u2022 Checks if penetration detection enabled&lt;br/&gt;\u2022 Calls detect_penetration_attempt]\n\n    Middleware --&gt; DPA[detect_penetration_attempt&lt;br/&gt;\u2022 Extracts content from request&lt;br/&gt;\u2022 Query, body, path, headers&lt;br/&gt;\u2022 Calls SusPatternsManager.detect]\n\n    DPA --&gt; SPM[SusPatternsManager Singleton&lt;br/&gt;\u2022 Manages patterns: default + custom&lt;br/&gt;\u2022 Initializes components lazily&lt;br/&gt;\u2022 Orchestrates detection process]\n\n    SPM --&gt; CP[ContentPreprocessor&lt;br/&gt;if configured]\n    SPM --&gt; PC[PatternCompiler&lt;br/&gt;if configured]\n    SPM --&gt; SA[SemanticAnalyzer&lt;br/&gt;if configured]\n\n    CP --&gt; PM[PerformanceMonitor&lt;br/&gt;always created]\n    PC --&gt; PM\n    SA --&gt; PM\n\n    style Request fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style Middleware fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style DPA fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style SPM fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style PM fill:#fce4ec,stroke:#880e4f,stroke-width:2px\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#core-components","title":"Core Components","text":""},{"location":"tutorial/security/detection-engine/architecture/#1-suspatternsmanager","title":"1. SusPatternsManager","text":"<p>The central component that manages the detection process:</p> <pre><code>class SusPatternsManager:\n    \"\"\"Singleton pattern manager with enhanced detection capabilities.\"\"\"\n\n    _instance: SusPatternsManager | None = None\n    _lock: threading.Lock = threading.Lock()\n\n    def __new__(cls) -&gt; SusPatternsManager:\n        # Singleton implementation\n\n    def __init__(self) -&gt; None:\n        # Load patterns from YAML files\n        self.patterns: list[str] = []\n        self.custom_patterns: set[str] = set()\n        self.compiled_patterns: list[re.Pattern] = []\n\n        # Detection engine components (initialized lazily)\n        self._compiler: PatternCompiler | None = None\n        self._preprocessor: ContentPreprocessor | None = None\n        self._semantic_analyzer: SemanticAnalyzer | None = None\n        self._performance_monitor: PerformanceMonitor | None = None\n</code></pre> <p>Key Responsibilities:</p> <ul> <li>Pattern loading from YAML files</li> <li>Custom pattern management</li> <li>Component initialization based on configuration</li> <li>Detection orchestration</li> <li>Result aggregation</li> </ul>"},{"location":"tutorial/security/detection-engine/architecture/#2-component-initialization","title":"2. Component Initialization","text":"<p>Components are initialized only when needed based on configuration:</p> <pre><code>def _ensure_detection_components(self) -&gt; None:\n    \"\"\"Initialize detection engine components based on configuration.\"\"\"\n    config = get_current_config()\n\n    # PatternCompiler: Only if timeout &gt; 0\n    if config.detection_compiler_timeout &gt; 0 and not self._compiler:\n        self._compiler = PatternCompiler(config)\n\n    # ContentPreprocessor: Only if max_content_length &gt; 0\n    if config.detection_max_content_length &gt; 0 and not self._preprocessor:\n        self._preprocessor = ContentPreprocessor(config)\n\n    # SemanticAnalyzer: Only if threshold &gt; 0\n    if config.detection_semantic_threshold &gt; 0 and not self._semantic_analyzer:\n        self._semantic_analyzer = SemanticAnalyzer(config)\n\n    # PerformanceMonitor: Always created\n    if not self._performance_monitor:\n        self._performance_monitor = PerformanceMonitor(config)\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#detection-flow","title":"Detection Flow","text":""},{"location":"tutorial/security/detection-engine/architecture/#1-request-reception","title":"1. Request Reception","text":"<pre><code># In middleware.py\nif self.config.enable_penetration_detection:\n    detection_result, trigger_info = await detect_penetration_attempt(request)\n    if detection_result:\n        # Handle detected attack\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#2-content-extraction","title":"2. Content Extraction","text":"<pre><code># In utils.py\nasync def detect_penetration_attempt(request: Request) -&gt; tuple[bool, str]:\n    # Extract content from various sources\n    contents_to_check = []\n\n    # Query parameters\n    if request.query_params:\n        for key, value in request.query_params.items():\n            contents_to_check.append((f\"{key}={value}\", \"query_param\"))\n\n    # Request body\n    body = await get_body_content(request)\n    if body:\n        contents_to_check.append((body, \"body\"))\n\n    # Path parameters\n    if path_params := request.path_params:\n        contents_to_check.append((str(path_params), \"path\"))\n\n    # Headers\n    for header, value in request.headers.items():\n        contents_to_check.append((f\"{header}: {value}\", \"header\"))\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#3-detection-process","title":"3. Detection Process","text":"<pre><code># For each content piece\nfor content, context in contents_to_check:\n    result = await sus_patterns_handler.detect(\n        content=content,\n        ip_address=client_ip,\n        context=context,\n        correlation_id=correlation_id\n    )\n\n    if result[\"is_threat\"]:\n        return True, format_trigger_info(result)\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#4-detection-implementation","title":"4. Detection Implementation","text":"<p>The actual detection in <code>SusPatternsManager.detect()</code>:</p> <pre><code>async def detect(self, content: str, **kwargs) -&gt; dict[str, Any]:\n    start_time = time.time()\n    threats = []\n    timeouts = []\n\n    # 1. Ensure components are initialized\n    self._ensure_detection_components()\n\n    # 2. Preprocess content\n    if self._preprocessor:\n        processed_content = self._preprocessor.preprocess(content)\n        preserved_attacks = processed_content != content[:len(processed_content)]\n    else:\n        processed_content = content\n        preserved_attacks = False\n\n    # 3. Pattern matching\n    for i, pattern in enumerate(self.compiled_patterns):\n        pattern_str = self.patterns[i] if i &lt; len(self.patterns) else str(pattern.pattern)\n\n        if self._compiler:\n            # Use timeout-protected matching\n            safe_matcher = self._compiler.create_safe_matcher(pattern_str, pattern)\n            match_result = await safe_matcher(processed_content)\n\n            if match_result:\n                if match_result.get(\"timeout\"):\n                    timeouts.append(pattern_str)\n                elif match_result.get(\"match\"):\n                    threats.append({\n                        \"type\": \"regex\",\n                        \"pattern\": pattern_str,\n                        \"execution_time\": match_result.get(\"execution_time\", 0)\n                    })\n        else:\n            # Fallback to direct matching\n            try:\n                if pattern.search(processed_content):\n                    threats.append({\n                        \"type\": \"regex\",\n                        \"pattern\": pattern_str\n                    })\n            except Exception:\n                pass\n\n    # 4. Semantic analysis\n    if self._semantic_analyzer and not threats:\n        semantic_result = self._semantic_analyzer.analyze_content(processed_content)\n        if semantic_result[\"score\"] &gt; self._semantic_analyzer.threshold:\n            threats.append({\n                \"type\": \"semantic\",\n                \"score\": semantic_result[\"score\"],\n                \"attack_types\": semantic_result[\"attack_types\"],\n                \"confidence\": semantic_result[\"confidence\"]\n            })\n\n    # 5. Performance tracking\n    execution_time = time.time() - start_time\n    if self._performance_monitor:\n        for threat in threats:\n            await self._performance_monitor.record_metric(\n                pattern=threat.get(\"pattern\", \"semantic\"),\n                execution_time=threat.get(\"execution_time\", execution_time),\n                matched=True,\n                timeout=False\n            )\n\n    # 6. Build result\n    return {\n        \"is_threat\": len(threats) &gt; 0,\n        \"threat_score\": max((t.get(\"score\", 1.0) for t in threats), default=0.0),\n        \"threats\": threats,\n        \"context\": kwargs.get(\"context\", \"unknown\"),\n        \"original_length\": len(content),\n        \"processed_length\": len(processed_content),\n        \"execution_time\": execution_time,\n        \"detection_method\": \"enhanced\" if self._compiler else \"legacy\",\n        \"timeouts\": timeouts,\n        \"correlation_id\": kwargs.get(\"correlation_id\")\n    }\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#data-flow","title":"Data Flow","text":""},{"location":"tutorial/security/detection-engine/architecture/#pattern-loading","title":"Pattern Loading","text":"<pre><code>flowchart LR\n    YAML[YAML Files&lt;br/&gt;package data] --&gt; PL[Pattern Loading&lt;br/&gt;\u2022 Read YAML files&lt;br/&gt;\u2022 Merge custom&lt;br/&gt;\u2022 Compile regex]\n    Custom[Custom Patterns&lt;br/&gt;runtime] --&gt; PL\n    Cache[Compiled Cache&lt;br/&gt;memory] --&gt; PL\n\n    style YAML fill:#bbdefb,stroke:#1565c0,stroke-width:2px\n    style Custom fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px\n    style Cache fill:#ffccbc,stroke:#bf360c,stroke-width:2px\n    style PL fill:#fff9c4,stroke:#f57f17,stroke-width:2px\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#detection-result-structure","title":"Detection Result Structure","text":"<pre><code>{\n    \"is_threat\": bool,              # True if any threat detected\n    \"threat_score\": float,          # 0.0-1.0, highest score\n    \"threats\": [                    # List of detected threats\n        {\n            \"type\": \"regex\",        # or \"semantic\"\n            \"pattern\": str,         # For regex matches\n            \"score\": float,         # For semantic matches\n            \"execution_time\": float # Pattern execution time\n        }\n    ],\n    \"context\": str,                 # Where content came from\n    \"original_length\": int,         # Original content length\n    \"processed_length\": int,        # After preprocessing\n    \"execution_time\": float,        # Total detection time\n    \"detection_method\": str,        # \"enhanced\" or \"legacy\"\n    \"timeouts\": list[str],         # Patterns that timed out\n    \"correlation_id\": str | None    # Request correlation ID\n}\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#integration-points","title":"Integration Points","text":""},{"location":"tutorial/security/detection-engine/architecture/#1-configuration-integration","title":"1. Configuration Integration","text":"<p>The engine reads configuration from <code>SecurityConfig</code>:</p> <pre><code># Key configuration fields\nconfig.enable_penetration_detection     # Enable/disable\nconfig.detection_compiler_timeout       # Pattern timeout\nconfig.detection_max_content_length     # Content limit\nconfig.detection_preserve_attack_patterns # Preservation\nconfig.detection_semantic_threshold     # Semantic threshold\nconfig.detection_slow_pattern_threshold # Performance threshold\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#2-redis-integration-optional","title":"2. Redis Integration (Optional)","text":"<p>When Redis is enabled: - Custom patterns can be stored/retrieved - Performance metrics can be aggregated - Pattern effectiveness can be tracked</p>"},{"location":"tutorial/security/detection-engine/architecture/#3-agent-integration-optional","title":"3. Agent Integration (Optional)","text":"<p>When Agent is enabled: - Detection events are sent with full context - Performance metrics are reported - Pattern effectiveness is tracked</p>"},{"location":"tutorial/security/detection-engine/architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"tutorial/security/detection-engine/architecture/#1-redos-prevention","title":"1. ReDoS Prevention","text":"<p>The engine prevents Regular Expression Denial of Service through:</p> <pre><code># In PatternCompiler.create_safe_matcher()\nasync def safe_matcher(content: str) -&gt; dict[str, Any] | None:\n    try:\n        start = time.time()\n        match = await asyncio.wait_for(\n            asyncio.to_thread(pattern.search, content),\n            timeout=self.timeout\n        )\n        return {\n            \"match\": match,\n            \"execution_time\": time.time() - start\n        }\n    except asyncio.TimeoutError:\n        return {\"timeout\": True}\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#2-resource-management","title":"2. Resource Management","text":"<ul> <li>Memory: Content preprocessing limits input size</li> <li>CPU: Timeout protection prevents excessive CPU usage</li> <li>Concurrency: Thread pool executor prevents blocking</li> <li>Caching: Bounded caches prevent memory leaks</li> </ul>"},{"location":"tutorial/security/detection-engine/architecture/#3-error-isolation","title":"3. Error Isolation","text":"<p>Each component handles errors independently: - Pattern compilation errors don't crash the system - Timeout errors are logged but don't stop detection - Component initialization failures fall back gracefully</p>"},{"location":"tutorial/security/detection-engine/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"tutorial/security/detection-engine/architecture/#latency-impact","title":"Latency Impact","text":"Component Typical Latency Max Latency Preprocessing &lt; 1ms 5ms Pattern Matching (per pattern) &lt; 0.1ms timeout value Semantic Analysis 1-5ms 10ms Total Detection 5-20ms 50ms"},{"location":"tutorial/security/detection-engine/architecture/#memory-usage","title":"Memory Usage","text":"<ul> <li>Pattern storage: ~100KB for default patterns</li> <li>Compiled pattern cache: ~1MB</li> <li>Performance history: ~500KB (configurable)</li> <li>Total overhead: ~2-5MB per instance</li> </ul>"},{"location":"tutorial/security/detection-engine/architecture/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"tutorial/security/detection-engine/architecture/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># Get performance statistics\nstats = await sus_patterns_handler.get_performance_stats()\n\n# Example output\n{\n    \"slow_patterns\": [...],          # Patterns exceeding threshold\n    \"problematic_patterns\": [...],   # Patterns with issues\n    \"summary\": {\n        \"total_executions\": 10000,\n        \"average_time\": 0.002,\n        \"timeout_rate\": 0.001,\n        \"match_rate\": 0.05\n    }\n}\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#component-status","title":"Component Status","text":"<pre><code># Check component status\nstatus = await sus_patterns_handler.get_component_status()\n\n# Example output\n{\n    \"compiler\": True,           # PatternCompiler active\n    \"preprocessor\": True,       # ContentPreprocessor active\n    \"semantic_analyzer\": False, # Not configured\n    \"performance_monitor\": True # Always active\n}\n</code></pre>"},{"location":"tutorial/security/detection-engine/architecture/#best-practices","title":"Best Practices","text":"<ol> <li>Configuration: Start with defaults, adjust based on monitoring</li> <li>Pattern Management: Regularly review and optimize patterns</li> <li>Performance: Monitor slow patterns and remove/optimize them</li> <li>Security: Always enable timeout protection in production</li> <li>Testing: Test patterns in staging before production deployment</li> </ol>"},{"location":"tutorial/security/detection-engine/architecture/#limitations","title":"Limitations","text":"<ol> <li>Pattern-Based: Relies on known attack patterns</li> <li>Context-Unaware: Doesn't understand application-specific logic</li> <li>Performance Trade-offs: More detection = higher latency</li> <li>False Positives: Legitimate content may match patterns</li> </ol>"},{"location":"tutorial/security/detection-engine/architecture/#future-considerations","title":"Future Considerations","text":"<p>While not currently implemented, potential enhancements could include:</p> <ul> <li>True machine learning models</li> <li>Distributed pattern learning</li> <li>Real-time threat intelligence feeds</li> <li>Context-aware detection</li> </ul>"},{"location":"tutorial/security/detection-engine/components/","title":"Detection Engine Components","text":"<p>This document provides detailed information about each component of the FastAPI Guard Detection Engine, including their actual implementation, capabilities, and usage.</p>"},{"location":"tutorial/security/detection-engine/components/#component-overview","title":"Component Overview","text":"<p>The Detection Engine consists of four main components, each initialized conditionally based on configuration:</p> <ol> <li>ContentPreprocessor - Truncates content while preserving attack patterns</li> <li>PatternCompiler - Provides timeout-protected pattern matching</li> <li>SemanticAnalyzer - Heuristic-based attack detection</li> <li>PerformanceMonitor - Tracks execution metrics</li> </ol>"},{"location":"tutorial/security/detection-engine/components/#contentpreprocessor","title":"ContentPreprocessor","text":"<p>Located in <code>guard/detection_engine/preprocessor.py</code></p>"},{"location":"tutorial/security/detection-engine/components/#purpose","title":"Purpose","text":"<p>Intelligently truncates content to prevent excessive memory usage while ensuring potential attack patterns are preserved.</p>"},{"location":"tutorial/security/detection-engine/components/#implementation","title":"Implementation","text":"<pre><code>class ContentPreprocessor:\n    \"\"\"Intelligent content preprocessing with attack pattern preservation.\"\"\"\n\n    def __init__(self, config: SecurityConfig):\n        self.max_length = config.detection_max_content_length\n        self.preserve_patterns = config.detection_preserve_attack_patterns\n</code></pre>"},{"location":"tutorial/security/detection-engine/components/#key-methods","title":"Key Methods","text":""},{"location":"tutorial/security/detection-engine/components/#preprocesscontent-str-str","title":"<code>preprocess(content: str) -&gt; str</code>","text":"<p>Preprocesses content with the following logic:</p> <ol> <li>If content length \u2264 max_length, returns unchanged</li> <li>If preserve_patterns is False, simple truncation</li> <li>If preserve_patterns is True:</li> <li>Scans for attack patterns in a sliding window</li> <li>Preserves sections containing potential attacks</li> <li>Returns truncated content with preserved attack regions</li> </ol>"},{"location":"tutorial/security/detection-engine/components/#attack-pattern-preservation","title":"Attack Pattern Preservation","text":"<p>The preprocessor looks for indicators like: - SQL keywords: SELECT, UNION, INSERT, DELETE, etc. - Script tags and JavaScript events - Path traversal patterns: ../, ..\\ - Command injection indicators - Common encoding patterns</p>"},{"location":"tutorial/security/detection-engine/components/#example-usage","title":"Example Usage","text":"<pre><code>preprocessor = ContentPreprocessor(config)\nprocessed = preprocessor.preprocess(long_content)\n# Result: Truncated content with attack patterns preserved\n</code></pre>"},{"location":"tutorial/security/detection-engine/components/#patterncompiler","title":"PatternCompiler","text":"<p>Located in <code>guard/detection_engine/compiler.py</code></p>"},{"location":"tutorial/security/detection-engine/components/#purpose_1","title":"Purpose","text":"<p>Provides safe pattern compilation and execution with timeout protection against ReDoS attacks.</p>"},{"location":"tutorial/security/detection-engine/components/#implementation_1","title":"Implementation","text":"<pre><code>class PatternCompiler:\n    \"\"\"Pattern compilation with timeout protection.\"\"\"\n\n    def __init__(self, config: SecurityConfig):\n        self.timeout = config.detection_compiler_timeout\n        self._compiled_cache: dict[str, re.Pattern | None] = {}\n</code></pre>"},{"location":"tutorial/security/detection-engine/components/#key-methods_1","title":"Key Methods","text":""},{"location":"tutorial/security/detection-engine/components/#compile_patternpattern-str-repattern-none","title":"<code>compile_pattern(pattern: str) -&gt; re.Pattern | None</code>","text":"<p>Compiles regex patterns with error handling: - Caches compiled patterns for performance - Returns None for invalid patterns - Logs compilation errors</p>"},{"location":"tutorial/security/detection-engine/components/#create_safe_matcherpattern-str-compiled_pattern-repattern-callable","title":"<code>create_safe_matcher(pattern: str, compiled_pattern: re.Pattern) -&gt; Callable</code>","text":"<p>Creates a timeout-protected matcher function:</p> <pre><code>async def safe_matcher(content: str) -&gt; dict[str, Any] | None:\n    try:\n        match = await asyncio.wait_for(\n            asyncio.to_thread(compiled_pattern.search, content),\n            timeout=self.timeout\n        )\n        return {\"match\": match} if match else None\n    except asyncio.TimeoutError:\n        return {\"timeout\": True}\n</code></pre>"},{"location":"tutorial/security/detection-engine/components/#timeout-protection","title":"Timeout Protection","text":"<ul> <li>Uses <code>asyncio.wait_for()</code> with configurable timeout</li> <li>Runs pattern matching in thread pool to prevent blocking</li> <li>Returns timeout indicator instead of hanging</li> </ul>"},{"location":"tutorial/security/detection-engine/components/#semanticanalyzer","title":"SemanticAnalyzer","text":"<p>Located in <code>guard/detection_engine/semantic.py</code></p>"},{"location":"tutorial/security/detection-engine/components/#purpose_2","title":"Purpose","text":"<p>Provides heuristic-based detection of obfuscated attacks that might bypass regex patterns.</p>"},{"location":"tutorial/security/detection-engine/components/#implementation_2","title":"Implementation","text":"<pre><code>class SemanticAnalyzer:\n    \"\"\"Heuristic-based semantic analysis for attack detection.\"\"\"\n\n    def __init__(self, config: SecurityConfig):\n        self.threshold = config.detection_semantic_threshold\n        self.token_patterns = self._initialize_patterns()\n</code></pre>"},{"location":"tutorial/security/detection-engine/components/#key-methods_2","title":"Key Methods","text":""},{"location":"tutorial/security/detection-engine/components/#analyze_contentcontent-str-dictstr-any","title":"<code>analyze_content(content: str) -&gt; dict[str, Any]</code>","text":"<p>Performs multi-stage analysis:</p> <ol> <li>Token Extraction: Breaks content into meaningful tokens</li> <li>Pattern Analysis: Looks for attack-specific patterns</li> <li>Context Evaluation: Considers token relationships</li> <li>Scoring: Calculates threat probability</li> </ol>"},{"location":"tutorial/security/detection-engine/components/#attack-detection-heuristics","title":"Attack Detection Heuristics","text":"<p>The analyzer detects:</p> <ul> <li>SQL Injection:</li> <li>Keywords: SELECT, UNION, WHERE, OR, AND</li> <li>Operators: =, --, /*</li> <li> <p>Functions: concat(), char()</p> </li> <li> <p>XSS Attacks:</p> </li> <li>Tags:"},{"location":"tutorial/security/detection-engine/configuration/","title":"Detection Engine Configuration Guide","text":"<p>This guide provides comprehensive documentation for configuring the FastAPI Guard Detection Engine to optimize security and performance for your specific needs.</p>"},{"location":"tutorial/security/detection-engine/configuration/#configuration-overview","title":"Configuration Overview","text":"<p>The Detection Engine is configured through the <code>SecurityConfig</code> model, which provides numerous parameters to control detection behavior, performance characteristics, and integration options.</p>"},{"location":"tutorial/security/detection-engine/configuration/#configuration-categories","title":"Configuration Categories","text":""},{"location":"tutorial/security/detection-engine/configuration/#1-core-detection-settings","title":"1. Core Detection Settings","text":"<p>These settings control the fundamental behavior of the detection engine:</p> <pre><code>from guard import SecurityConfig\n\nconfig = SecurityConfig(\n    # Enable/disable penetration detection\n    enable_penetration_detection=True,  # Default: True\n\n    # Auto-ban settings for suspicious activity\n    auto_ban_threshold=5,        # Ban after N suspicious requests\n    auto_ban_duration=3600,      # Ban duration in seconds (1 hour)\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#2-detection-engine-settings","title":"2. Detection Engine Settings","text":"<p>Fine-tune the detection engine components:</p> <pre><code>config = SecurityConfig(\n    # Pattern compilation and execution\n    detection_compiler_timeout=2.0,      # Timeout for pattern matching (seconds)\n\n    # Content preprocessing\n    detection_max_content_length=10000,  # Max characters to analyze\n    detection_preserve_attack_patterns=True,  # Preserve attacks during truncation\n\n    # Semantic analysis\n    detection_semantic_threshold=0.7,    # Threat score threshold (0.0-1.0)\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#3-performance-monitoring-settings","title":"3. Performance Monitoring Settings","text":"<p>Configure performance tracking and optimization:</p> <pre><code>config = SecurityConfig(\n    # Anomaly detection\n    detection_anomaly_threshold=3.0,     # Standard deviations for anomaly\n\n    # Pattern performance\n    detection_slow_pattern_threshold=0.1,  # Slow pattern threshold (seconds)\n\n    # Monitoring history\n    detection_monitor_history_size=1000,   # Number of metrics to keep\n    detection_max_tracked_patterns=1000,   # Maximum patterns to track\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's a comprehensive configuration example with all detection engine settings:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\n\napp = FastAPI()\n\n# Full detection engine configuration\nconfig = SecurityConfig(\n    # Core security settings\n    enable_penetration_detection=True,\n    auto_ban_threshold=5,\n    auto_ban_duration=3600,\n    passive_mode=False,  # Set to True for monitoring without blocking\n\n    # Detection engine optimization\n    detection_compiler_timeout=2.0,\n    detection_max_content_length=10000,\n    detection_preserve_attack_patterns=True,\n    detection_semantic_threshold=0.7,\n\n    # Performance monitoring\n    detection_anomaly_threshold=3.0,\n    detection_slow_pattern_threshold=0.1,\n    detection_monitor_history_size=1000,\n    detection_max_tracked_patterns=1000,\n\n    # Redis integration (optional)\n    use_redis=True,\n    redis_host=\"localhost\",\n    redis_port=6379,\n    redis_db=0,\n\n    # Agent integration (optional)\n    enable_agent=True,\n    agent_api_key=\"your-api-key\",\n    agent_enable_events=True,\n    agent_enable_metrics=True,\n\n    # Logging\n    custom_log_file=\"security.log\",\n    log_level=\"WARNING\"\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#configuration-profiles","title":"Configuration Profiles","text":""},{"location":"tutorial/security/detection-engine/configuration/#high-security-profile","title":"High Security Profile","text":"<p>For applications requiring maximum security with stricter detection:</p> <pre><code>high_security_config = SecurityConfig(\n    # Strict detection settings\n    enable_penetration_detection=True,\n    auto_ban_threshold=3,            # Lower threshold\n    auto_ban_duration=7200,          # Longer ban (2 hours)\n\n    # Tighter detection parameters\n    detection_compiler_timeout=1.0,   # Shorter timeout\n    detection_max_content_length=5000,  # Analyze less content\n    detection_semantic_threshold=0.5,   # More sensitive detection\n\n    # Aggressive monitoring\n    detection_anomaly_threshold=2.0,    # More sensitive to anomalies\n    detection_slow_pattern_threshold=0.05,  # Stricter performance\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#performance-optimized-profile","title":"Performance Optimized Profile","text":"<p>For high-traffic applications prioritizing performance:</p> <pre><code>performance_config = SecurityConfig(\n    # Balanced detection\n    enable_penetration_detection=True,\n    auto_ban_threshold=10,           # Higher threshold\n    auto_ban_duration=1800,          # Shorter ban (30 minutes)\n\n    # Performance-focused settings\n    detection_compiler_timeout=3.0,   # Longer timeout allowed\n    detection_max_content_length=2000,  # Analyze less content\n    detection_semantic_threshold=0.8,   # Less sensitive\n\n    # Relaxed monitoring\n    detection_anomaly_threshold=4.0,    # Less sensitive\n    detection_slow_pattern_threshold=0.2,  # More tolerant\n    detection_monitor_history_size=500,    # Smaller history\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#development-profile","title":"Development Profile","text":"<p>For development and testing environments:</p> <pre><code>dev_config = SecurityConfig(\n    # Enable detection but in passive mode\n    enable_penetration_detection=True,\n    passive_mode=True,               # Log but don't block\n\n    # Verbose settings for debugging\n    detection_compiler_timeout=5.0,   # Generous timeout\n    detection_max_content_length=50000,  # Large content analysis\n\n    # Full monitoring\n    detection_monitor_history_size=5000,  # Large history\n\n    # Detailed logging\n    log_level=\"DEBUG\",\n    custom_log_file=\"security-debug.log\"\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#parameter-reference","title":"Parameter Reference","text":""},{"location":"tutorial/security/detection-engine/configuration/#detection-compiler-settings","title":"Detection Compiler Settings","text":"Parameter Type Default Range Description <code>detection_compiler_timeout</code> float 2.0 0.1-30.0 Maximum seconds for pattern execution <p>Usage Guidelines:</p> <ul> <li>Lower values (0.1-1.0): High security, may timeout complex patterns</li> <li>Default (2.0): Balanced for most applications</li> <li>Higher values (3.0-5.0): More tolerant, for complex legitimate patterns</li> </ul>"},{"location":"tutorial/security/detection-engine/configuration/#content-preprocessing-settings","title":"Content Preprocessing Settings","text":"Parameter Type Default Description <code>detection_max_content_length</code> int 10000 Maximum characters to process <code>detection_preserve_attack_patterns</code> bool True Preserve attacks during truncation <p>Best Practices: - Set <code>max_content_length</code> based on your typical request size - Always keep <code>preserve_attack_patterns</code> True for security - Consider memory usage with very large content limits</p>"},{"location":"tutorial/security/detection-engine/configuration/#semantic-analysis-settings","title":"Semantic Analysis Settings","text":"Parameter Type Default Range Description <code>detection_semantic_threshold</code> float 0.7 0.0-1.0 Minimum score to consider threat <p>Threshold Guidelines: - 0.0-0.3: Very sensitive, many false positives - 0.4-0.6: Sensitive, catches more attacks - 0.7-0.8: Balanced (recommended) - 0.9-1.0: Very strict, may miss obfuscated attacks</p>"},{"location":"tutorial/security/detection-engine/configuration/#performance-monitoring-settings","title":"Performance Monitoring Settings","text":"Parameter Type Default Description <code>detection_anomaly_threshold</code> float 3.0 Standard deviations for anomaly <code>detection_slow_pattern_threshold</code> float 0.1 Seconds to consider pattern slow <code>detection_monitor_history_size</code> int 1000 Metrics to keep in memory <code>detection_max_tracked_patterns</code> int 1000 Maximum patterns to track <p>Optimization Tips: - Lower <code>anomaly_threshold</code> to catch unusual behavior earlier - Adjust <code>slow_pattern_threshold</code> based on your performance requirements - Increase history sizes for better long-term analysis</p>"},{"location":"tutorial/security/detection-engine/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>You can adjust certain settings at runtime:</p> <pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Adjust semantic threshold dynamically\nawait sus_patterns_handler.configure_semantic_threshold(0.8)\n\n# Add custom patterns\nawait sus_patterns_handler.add_pattern(\n    r\"(?i)custom_threat_pattern\",\n    custom=True\n)\n\n# Check component status\nstatus = await sus_patterns_handler.get_component_status()\nprint(f\"Components active: {status}\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The Detection Engine validates configuration on startup:</p> <pre><code>try:\n    config = SecurityConfig(\n        detection_compiler_timeout=0.05  # Too low, will be adjusted\n    )\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#environment-variables","title":"Environment Variables","text":"<p>You can also configure the detection engine using environment variables:</p> <pre><code># Core settings\nFASTAPI_GUARD_ENABLE_PENETRATION_DETECTION=true\nFASTAPI_GUARD_AUTO_BAN_THRESHOLD=5\n\n# Detection engine\nFASTAPI_GUARD_DETECTION_COMPILER_TIMEOUT=2.0\nFASTAPI_GUARD_DETECTION_MAX_CONTENT_LENGTH=10000\nFASTAPI_GUARD_DETECTION_SEMANTIC_THRESHOLD=0.7\n\n# Performance monitoring\nFASTAPI_GUARD_DETECTION_ANOMALY_THRESHOLD=3.0\nFASTAPI_GUARD_DETECTION_SLOW_PATTERN_THRESHOLD=0.1\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#monitoring-configuration-effectiveness","title":"Monitoring Configuration Effectiveness","text":""},{"location":"tutorial/security/detection-engine/configuration/#check-performance-impact","title":"Check Performance Impact","text":"<pre><code># Get performance statistics\nstats = await sus_patterns_handler.get_performance_stats()\n\n# Analyze configuration effectiveness\nif stats['summary']['average_time'] &gt; 0.05:\n    print(\"Consider optimizing configuration for better performance\")\n\nif stats['summary']['timeout_rate'] &gt; 0.01:\n    print(\"High timeout rate - consider increasing compiler_timeout\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#monitor-false-positives","title":"Monitor False Positives","text":"<pre><code># Track false positive rate\nif config.passive_mode:\n    # In passive mode, analyze logs for false positives\n    # Adjust detection_semantic_threshold based on findings\n    pass\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#configuration-checklist","title":"Configuration Checklist","text":"<p>Before deploying to production:</p> <ul> <li>[ ] Test configuration in staging environment</li> <li>[ ] Verify timeout settings don't impact legitimate traffic</li> <li>[ ] Confirm content length limits handle your use cases</li> <li>[ ] Test semantic threshold with known attack patterns</li> <li>[ ] Monitor performance metrics for first 24 hours</li> <li>[ ] Review logs for false positives/negatives</li> <li>[ ] Ensure Redis/Agent connections are stable</li> <li>[ ] Document any custom patterns added</li> </ul>"},{"location":"tutorial/security/detection-engine/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorial/security/detection-engine/configuration/#high-false-positive-rate","title":"High False Positive Rate","text":"<pre><code># Increase semantic threshold\nconfig.detection_semantic_threshold = 0.8\n\n# Review problematic patterns\nstats = await sus_patterns_handler.get_performance_stats()\nfor pattern in stats['problematic_patterns']:\n    print(f\"Review pattern: {pattern}\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#performance-issues","title":"Performance Issues","text":"<pre><code># Reduce content analysis size\nconfig.detection_max_content_length = 5000\n\n# Increase timeout tolerance\nconfig.detection_compiler_timeout = 3.0\n\n# Monitor specific patterns\nslow_patterns = monitor.get_slow_patterns(threshold=0.05)\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#memory-usage","title":"Memory Usage","text":"<pre><code># Reduce monitoring history\nconfig.detection_monitor_history_size = 500\nconfig.detection_max_tracked_patterns = 500\n\n# Clear old metrics periodically\nmonitor.clear_old_metrics()\n</code></pre>"},{"location":"tutorial/security/detection-engine/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Review Performance Tuning Guide</li> <li>Explore Custom Pattern Development</li> <li>Monitor with Security Dashboard</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/","title":"Detection Engine","text":"<p>The FastAPI Guard Detection Engine is an enhanced pattern-based threat detection system that provides protection against common web application attacks through timeout-protected pattern matching and optional heuristic analysis.</p>"},{"location":"tutorial/security/detection-engine/overview/#overview","title":"Overview","text":"<p>The Detection Engine is an evolution of FastAPI Guard's suspicious patterns system, introducing:</p> <ul> <li>Timeout Protection: Prevents ReDoS attacks through configurable execution timeouts</li> <li>Content Preprocessing: Truncates content while preserving potential attack patterns</li> <li>Optional Semantic Analysis: Heuristic-based detection for obfuscated attacks (disabled by default)</li> <li>Performance Tracking: Monitors pattern execution times to identify slow patterns</li> <li>Singleton Architecture: Centralized pattern management with lazy initialization</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#key-features","title":"Key Features","text":""},{"location":"tutorial/security/detection-engine/overview/#1-pattern-matching-with-timeout-protection","title":"1. Pattern Matching with Timeout Protection","text":"<p>The engine protects against Regular Expression Denial of Service (ReDoS) by: - Wrapping pattern execution in asyncio timeouts - Configurable timeout via <code>detection_compiler_timeout</code> (default: 2.0 seconds) - Graceful handling of timeout events - Logging of patterns that exceed timeout thresholds</p>"},{"location":"tutorial/security/detection-engine/overview/#2-content-preprocessing","title":"2. Content Preprocessing","text":"<p>The <code>ContentPreprocessor</code> component: - Truncates content to <code>detection_max_content_length</code> (default: 10,000 characters) - Preserves attack patterns when <code>detection_preserve_attack_patterns</code> is True - Uses a sliding window approach to retain potential threats - Returns both processed content and preservation metrics</p>"},{"location":"tutorial/security/detection-engine/overview/#3-optional-semantic-analysis","title":"3. Optional Semantic Analysis","text":"<p>When enabled, provides heuristic-based detection: - Pattern-based heuristics for SQL injection, XSS, path traversal, etc. - Configurable threshold via <code>detection_semantic_threshold</code> (default: 0.7) - Returns probability scores and detected attack types - Must be explicitly enabled in configuration</p>"},{"location":"tutorial/security/detection-engine/overview/#4-performance-monitoring","title":"4. Performance Monitoring","text":"<p>Tracks execution metrics: - Records pattern execution times - Identifies slow patterns exceeding <code>detection_slow_pattern_threshold</code> - Maintains rolling statistics with configurable history size - Provides performance summaries and anomaly detection</p>"},{"location":"tutorial/security/detection-engine/overview/#architecture","title":"Architecture","text":"<p>The Detection Engine uses a modular design:</p> <pre><code>flowchart TB\n    Request[FastAPI Request] --&gt; DPA[detect_penetration_attempt]\n    DPA --&gt; SPM[SusPatternsManager.detect]\n\n    SPM --&gt; CP[ContentPreprocessor&lt;br/&gt;if configured]\n    SPM --&gt; PC[PatternCompiler&lt;br/&gt;if configured]\n    SPM --&gt; SA[SemanticAnalyzer&lt;br/&gt;if configured]\n\n    CP --&gt; PM[PerformanceMonitor&lt;br/&gt;if configured]\n    PC --&gt; PM\n    SA --&gt; PM\n\n    PM --&gt; Results[Detection Results]\n\n    style Request fill:#f9f,stroke:#333,stroke-width:2px\n    style Results fill:#9f9,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#basic-usage","title":"Basic Usage","text":"<p>The Detection Engine is automatically used when penetration detection is enabled:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\n\napp = FastAPI()\n\n# Configure with detection engine settings\nconfig = SecurityConfig(\n    # Enable penetration detection\n    enable_penetration_detection=True,\n\n    # Pattern execution timeout (prevents ReDoS)\n    detection_compiler_timeout=2.0,\n\n    # Content preprocessing\n    detection_max_content_length=10000,\n    detection_preserve_attack_patterns=True,\n\n    # Optional: Enable semantic analysis\n    # Note: Requires explicit configuration\n    detection_semantic_threshold=0.7,\n\n    # Performance monitoring\n    detection_slow_pattern_threshold=0.1,\n    detection_monitor_history_size=1000,\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#how-it-works","title":"How It Works","text":""},{"location":"tutorial/security/detection-engine/overview/#1-request-analysis","title":"1. Request Analysis","text":"<p>When a request arrives, <code>detect_penetration_attempt()</code> extracts content from: - Query parameters - Request body (JSON, form data) - Path parameters - Headers</p>"},{"location":"tutorial/security/detection-engine/overview/#2-detection-process","title":"2. Detection Process","text":"<p>For each content piece, the engine:</p> <pre><code># 1. Preprocessing (if max_content_length is configured)\nif len(content) &gt; config.detection_max_content_length:\n    content = preprocessor.preprocess(content)\n\n# 2. Pattern matching with timeout protection\nfor pattern in patterns:\n    with timeout(config.detection_compiler_timeout):\n        if pattern.search(content):\n            # Attack detected\n\n# 3. Semantic analysis (if threshold is configured)\nif config.detection_semantic_threshold &gt; 0:\n    result = semantic_analyzer.analyze_content(content)\n    if result['score'] &gt; config.detection_semantic_threshold:\n        # Attack detected\n\n# 4. Performance tracking (always enabled)\nperformance_monitor.record_metric(...)\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#3-results","title":"3. Results","text":"<p>The engine returns detailed information about detected threats:</p> <pre><code>{\n    \"is_threat\": True,\n    \"threat_score\": 0.85,\n    \"threats\": [\n        {\n            \"type\": \"regex\",\n            \"pattern\": \"union.*select\",\n            \"execution_time\": 0.002\n        }\n    ],\n    \"context\": \"body:json\",\n    \"original_length\": 500,\n    \"processed_length\": 500,\n    \"execution_time\": 0.015,\n    \"detection_method\": \"enhanced\",\n    \"timeouts\": [],  # List of patterns that timed out\n    \"correlation_id\": \"request-123\"\n}\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#configuration-reference","title":"Configuration Reference","text":""},{"location":"tutorial/security/detection-engine/overview/#detection-settings","title":"Detection Settings","text":"Setting Type Default Description <code>enable_penetration_detection</code> bool <code>True</code> Enable/disable detection engine <code>detection_compiler_timeout</code> float <code>2.0</code> Maximum seconds for pattern execution <code>detection_max_content_length</code> int <code>10000</code> Maximum characters to analyze <code>detection_preserve_attack_patterns</code> bool <code>True</code> Preserve potential attacks during truncation <code>detection_semantic_threshold</code> float <code>0.7</code> Threshold for semantic detection (0=disabled) <code>detection_anomaly_threshold</code> float <code>3.0</code> Standard deviations for performance anomaly <code>detection_slow_pattern_threshold</code> float <code>0.1</code> Seconds to consider pattern slow <code>detection_monitor_history_size</code> int <code>1000</code> Number of metrics to keep <code>detection_max_tracked_patterns</code> int <code>1000</code> Maximum patterns to track"},{"location":"tutorial/security/detection-engine/overview/#component-initialization","title":"Component Initialization","text":"<p>Components are initialized only when needed:</p> <ul> <li>PatternCompiler: Created if <code>detection_compiler_timeout</code> &gt; 0</li> <li>ContentPreprocessor: Created if <code>detection_max_content_length</code> &gt; 0</li> <li>SemanticAnalyzer: Created if <code>detection_semantic_threshold</code> &gt; 0</li> <li>PerformanceMonitor: Always created for tracking</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#pattern-management","title":"Pattern Management","text":""},{"location":"tutorial/security/detection-engine/overview/#default-patterns","title":"Default Patterns","text":"<p>The engine loads patterns from: 1. Built-in YAML files in the package 2. Custom patterns added via API</p>"},{"location":"tutorial/security/detection-engine/overview/#adding-custom-patterns","title":"Adding Custom Patterns","text":"<pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Add a pattern\nawait sus_patterns_handler.add_pattern(\n    r\"(?i)malicious.*pattern\",\n    custom=True\n)\n\n# Remove a pattern\nawait sus_patterns_handler.remove_pattern(\n    r\"(?i)malicious.*pattern\",\n    custom=True\n)\n\n# Clear all custom patterns\nawait sus_patterns_handler.clear_custom_patterns()\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tutorial/security/detection-engine/overview/#timeout-protection","title":"Timeout Protection","text":"<p>The timeout mechanism uses <code>asyncio.wait_for()</code> to prevent patterns from running indefinitely:</p> <pre><code>try:\n    result = await asyncio.wait_for(\n        pattern_match(content),\n        timeout=config.detection_compiler_timeout\n    )\nexcept asyncio.TimeoutError:\n    # Pattern timed out, log and continue\n    timeouts.append(pattern_string)\n</code></pre>"},{"location":"tutorial/security/detection-engine/overview/#memory-usage","title":"Memory Usage","text":"<ul> <li>Content preprocessing limits memory usage by truncating large inputs</li> <li>Performance history is bounded by <code>detection_monitor_history_size</code></li> <li>Pattern tracking is limited to <code>detection_max_tracked_patterns</code></li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#cpu-usage","title":"CPU Usage","text":"<ul> <li>Timeout protection prevents CPU-intensive patterns from blocking</li> <li>Slow patterns are identified and can be optimized or removed</li> <li>Semantic analysis adds overhead only when explicitly enabled</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#integration-points","title":"Integration Points","text":""},{"location":"tutorial/security/detection-engine/overview/#redis-integration","title":"Redis Integration","text":"<p>When Redis is enabled: - Custom patterns can be shared across instances - Performance metrics can be aggregated - Pattern effectiveness can be tracked globally</p>"},{"location":"tutorial/security/detection-engine/overview/#agent-integration","title":"Agent Integration","text":"<p>When Agent is enabled: - Detection events are sent with full context - Performance metrics are reported - Pattern effectiveness is tracked</p>"},{"location":"tutorial/security/detection-engine/overview/#limitations","title":"Limitations","text":"<ol> <li>Pattern-Based: The engine relies on regex patterns and heuristics, not true AI/ML</li> <li>Language Agnostic: Patterns may not understand context-specific semantics</li> <li>Performance Trade-offs: More thorough detection requires more processing time</li> <li>False Positives: Legitimate content may trigger patterns</li> </ol>"},{"location":"tutorial/security/detection-engine/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Start with Defaults: The default configuration works well for most applications</li> <li>Monitor Performance: Use <code>get_performance_stats()</code> to identify slow patterns</li> <li>Adjust Timeouts: Set timeouts based on your latency requirements</li> <li>Test Patterns: Validate custom patterns don't cause false positives</li> <li>Enable Gradually: Start with basic detection and enable advanced features as needed</li> </ol>"},{"location":"tutorial/security/detection-engine/overview/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorial/security/detection-engine/overview/#high-false-positive-rate","title":"High False Positive Rate","text":"<ul> <li>Increase <code>detection_semantic_threshold</code></li> <li>Review and refine custom patterns</li> <li>Consider disabling problematic default patterns</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#performance-issues","title":"Performance Issues","text":"<ul> <li>Reduce <code>detection_max_content_length</code></li> <li>Increase <code>detection_compiler_timeout</code></li> <li>Remove slow patterns identified by monitoring</li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#memory-usage_1","title":"Memory Usage","text":"<ul> <li>Decrease <code>detection_monitor_history_size</code></li> <li>Reduce <code>detection_max_tracked_patterns</code></li> </ul>"},{"location":"tutorial/security/detection-engine/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Review Detection Engine Components for detailed component documentation</li> <li>See Configuration Guide for advanced configuration</li> <li>Check Performance Tuning for optimization tips</li> </ul>"},{"location":"tutorial/security/detection-engine/performance-tuning/","title":"Detection Engine Performance Tuning Guide","text":"<p>This guide provides comprehensive strategies for optimizing the FastAPI Guard Detection Engine for maximum performance while maintaining security effectiveness.</p>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-overview","title":"Performance Overview","text":"<p>The Detection Engine's performance is influenced by several factors:</p> <ul> <li>Pattern complexity and quantity</li> <li>Content size being analyzed</li> <li>Semantic analysis overhead</li> <li>Redis/Agent communication latency</li> <li>Concurrent request volume</li> </ul>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-metrics","title":"Performance Metrics","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#key-performance-indicators","title":"Key Performance Indicators","text":"<p>Monitor these metrics to assess performance:</p> <pre><code>from guard.handlers.suspatterns_handler import sus_patterns_handler\n\n# Get comprehensive performance statistics\nstats = await sus_patterns_handler.get_performance_stats()\n\n# Key metrics to monitor\nprint(f\"Average execution time: {stats['summary']['average_time']}s\")\nprint(f\"Timeout rate: {stats['summary']['timeout_rate']*100}%\")\nprint(f\"Match rate: {stats['summary']['match_rate']*100}%\")\nprint(f\"Slow patterns: {len(stats['slow_patterns'])}\")\nprint(f\"Problematic patterns: {len(stats['problematic_patterns'])}\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Target performance levels for different scenarios:</p> Scenario Target Response Time Acceptable Timeout Rate API Gateway &lt; 10ms &lt; 0.1% Web Application &lt; 50ms &lt; 1% High Security &lt; 100ms &lt; 2% Batch Processing &lt; 500ms &lt; 5%"},{"location":"tutorial/security/detection-engine/performance-tuning/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#1-pattern-optimization","title":"1. Pattern Optimization","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#identify-slow-patterns","title":"Identify Slow Patterns","text":"<pre><code># Get patterns exceeding threshold\nslow_patterns = monitor.get_slow_patterns(threshold=0.05)\n\nfor pattern_info in slow_patterns:\n    pattern = pattern_info['pattern']\n    avg_time = pattern_info['average_time']\n\n    if avg_time &gt; 0.1:\n        # Consider removing or optimizing\n        print(f\"Critical: {pattern} - {avg_time}s average\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#optimize-pattern-complexity","title":"Optimize Pattern Complexity","text":"<p>Before (Slow):</p> <pre><code># Catastrophic backtracking risk\npattern = r\"(.*)*attack\"\npattern = r\"(a+)+b\"\npattern = r\"(\\w+)*@(\\w+)*\\.com\"\n</code></pre> <p>After (Optimized):</p> <pre><code># Atomic groups prevent backtracking\npattern = r\"(?:.*?)attack\"\npattern = r\"(?:a+)b\"\npattern = r\"\\w+@\\w+\\.com\"\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#use-non-capturing-groups","title":"Use Non-Capturing Groups","text":"<pre><code># Slower - creates capture groups\npattern = r\"(SELECT|INSERT|UPDATE).*(FROM|INTO)\"\n\n# Faster - non-capturing groups\npattern = r\"(?:SELECT|INSERT|UPDATE).*(?:FROM|INTO)\"\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#2-content-preprocessing-optimization","title":"2. Content Preprocessing Optimization","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#adjust-content-length","title":"Adjust Content Length","text":"<pre><code># For high-traffic APIs\nconfig = SecurityConfig(\n    detection_max_content_length=2000,  # Analyze less content\n    detection_preserve_attack_patterns=True  # Still preserve threats\n)\n\n# For form submissions\nconfig = SecurityConfig(\n    detection_max_content_length=5000,  # Moderate analysis\n)\n\n# For file uploads\nconfig = SecurityConfig(\n    detection_max_content_length=1000,  # Minimal header analysis\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#smart-truncation-strategy","title":"Smart Truncation Strategy","text":"<pre><code># Configure based on content type\nif content_type == \"application/json\":\n    config.detection_max_content_length = 5000\nelif content_type == \"multipart/form-data\":\n    config.detection_max_content_length = 1000\nelse:\n    config.detection_max_content_length = 10000\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#3-semantic-analysis-tuning","title":"3. Semantic Analysis Tuning","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#disable-for-high-performance-endpoints","title":"Disable for High-Performance Endpoints","text":"<pre><code># Selectively disable semantic analysis\n@app.get(\"/health\")\nasync def health_check():\n    # Skip semantic analysis for health checks\n    return {\"status\": \"ok\"}\n\n@app.post(\"/api/data\")\nasync def process_data(request: Request):\n    # Full analysis for data endpoints\n    return await handle_request(request)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#adjust-semantic-threshold","title":"Adjust Semantic Threshold","text":"<pre><code># Performance vs Security trade-off\n# Higher threshold = Faster (fewer semantic checks triggered)\nconfig = SecurityConfig(\n    detection_semantic_threshold=0.8  # Only high-confidence threats\n)\n\n# For critical endpoints\nconfig = SecurityConfig(\n    detection_semantic_threshold=0.6  # More thorough analysis\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#4-caching-optimization","title":"4. Caching Optimization","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#redis-configuration","title":"Redis Configuration","text":"<pre><code># Optimize Redis settings\nconfig = SecurityConfig(\n    use_redis=True,\n    redis_pool_size=20,  # Increase pool for high traffic\n    redis_ttl=3600,      # Shorter TTL for dynamic patterns\n)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#pattern-compilation-cache","title":"Pattern Compilation Cache","text":"<pre><code># Monitor cache effectiveness\ncompiler = sus_patterns_handler._compiler\ncache_stats = compiler.get_cache_stats()\n\nif cache_stats['hit_rate'] &lt; 0.8:\n    # Increase cache size\n    compiler.max_cache_size = 2000\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#5-timeout-configuration","title":"5. Timeout Configuration","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#dynamic-timeout-adjustment","title":"Dynamic Timeout Adjustment","text":"<pre><code># Base timeout on endpoint criticality\nclass DynamicTimeoutMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"path\"].startswith(\"/api/critical\"):\n            # Longer timeout for critical endpoints\n            timeout = 3.0\n        elif scope[\"path\"].startswith(\"/static\"):\n            # Minimal timeout for static resources\n            timeout = 0.5\n        else:\n            # Default timeout\n            timeout = 2.0\n\n        # Apply timeout\n        scope[\"detection_timeout\"] = timeout\n        await self.app(scope, receive, send)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#6-parallel-processing","title":"6. Parallel Processing","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#batch-pattern-matching","title":"Batch Pattern Matching","text":"<pre><code># Process multiple patterns in parallel\nasync def parallel_pattern_check(content: str, patterns: list):\n    tasks = []\n    for pattern in patterns:\n        task = asyncio.create_task(\n            check_pattern_async(content, pattern)\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    return any(results)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#real-time-monitoring","title":"Real-time Monitoring","text":"<pre><code>import asyncio\nfrom datetime import datetime\n\nasync def monitor_performance():\n    while True:\n        stats = await sus_patterns_handler.get_performance_stats()\n\n        # Alert on performance degradation\n        if stats['summary']['average_time'] &gt; 0.05:\n            logger.warning(\n                f\"Performance degradation detected: \"\n                f\"{stats['summary']['average_time']}s average\"\n            )\n\n        # Check for anomalies\n        anomalies = monitor.get_anomalies()\n        if anomalies:\n            logger.error(f\"Pattern anomalies detected: {len(anomalies)}\")\n\n        await asyncio.sleep(60)  # Check every minute\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-dashboard","title":"Performance Dashboard","text":"<pre><code># Create performance metrics endpoint\n@app.get(\"/metrics/detection-engine\")\nasync def get_detection_metrics():\n    stats = await sus_patterns_handler.get_performance_stats()\n\n    return {\n        \"performance\": {\n            \"average_execution_ms\": stats['summary']['average_time'] * 1000,\n            \"p95_execution_ms\": stats['summary'].get('p95_time', 0) * 1000,\n            \"timeout_rate\": stats['summary']['timeout_rate'],\n            \"total_executions\": stats['summary']['total_executions']\n        },\n        \"patterns\": {\n            \"total\": len(stats['all_patterns']),\n            \"slow\": len(stats['slow_patterns']),\n            \"problematic\": len(stats['problematic_patterns'])\n        },\n        \"health\": calculate_health_score(stats)\n    }\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#troubleshooting-performance-issues","title":"Troubleshooting Performance Issues","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#high-cpu-usage","title":"High CPU Usage","text":"<pre><code># 1. Check for runaway patterns\nproblematic = monitor.get_problematic_patterns()\nfor pattern in problematic:\n    if pattern['timeout_rate'] &gt; 0.05:\n        # Remove or fix pattern\n        await sus_patterns_handler.remove_pattern(\n            pattern['pattern'], \n            custom=True\n        )\n\n# 2. Reduce concurrent execution\nconfig.detection_max_concurrent = 10  # Limit parallel checks\n\n# 3. Implement circuit breaker\nclass CircuitBreaker:\n    def __init__(self, threshold=0.5, timeout=60):\n        self.threshold = threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.last_failure = None\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#memory-issues","title":"Memory Issues","text":"<pre><code># 1. Reduce history size\nconfig = SecurityConfig(\n    detection_monitor_history_size=500,  # Smaller history\n    detection_max_tracked_patterns=500   # Track fewer patterns\n)\n\n# 2. Clear old data periodically\nasync def cleanup_task():\n    while True:\n        monitor.clear_old_metrics()\n        compiler.clear_unused_cache()\n        await asyncio.sleep(3600)  # Every hour\n\n# 3. Monitor memory usage\nimport psutil\nprocess = psutil.Process()\nmemory_mb = process.memory_info().rss / 1024 / 1024\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#latency-spikes","title":"Latency Spikes","text":"<pre><code># 1. Implement request sampling\nclass SamplingMiddleware:\n    def __init__(self, sample_rate=0.1):\n        self.sample_rate = sample_rate\n\n    async def should_analyze(self, request):\n        # Only analyze sample of requests\n        return random.random() &lt; self.sample_rate\n\n# 2. Priority queue for critical paths\ncritical_paths = {\"/api/payment\", \"/api/auth\"}\nif request.path in critical_paths:\n    # Full analysis\n    result = await detect_full(content)\nelse:\n    # Light analysis\n    result = await detect_light(content)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/security/detection-engine/performance-tuning/#1-regular-pattern-audits","title":"1. Regular Pattern Audits","text":"<pre><code># Weekly pattern review\nasync def audit_patterns():\n    stats = await sus_patterns_handler.get_performance_stats()\n\n    # Remove ineffective patterns\n    for pattern in stats['all_patterns']:\n        if pattern['match_rate'] &lt; 0.0001 and pattern['age_days'] &gt; 30:\n            logger.info(f\"Removing ineffective pattern: {pattern['pattern']}\")\n            await sus_patterns_handler.remove_pattern(pattern['pattern'])\n\n    # Optimize slow patterns\n    for pattern in stats['slow_patterns']:\n        optimized = optimize_pattern(pattern['pattern'])\n        if optimized != pattern['pattern']:\n            await sus_patterns_handler.remove_pattern(pattern['pattern'])\n            await sus_patterns_handler.add_pattern(optimized, custom=True)\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#2-load-testing","title":"2. Load Testing","text":"<pre><code># Performance test script\nimport asyncio\nimport time\n\nasync def load_test():\n    test_contents = [\n        \"normal request data\",\n        \"SELECT * FROM users WHERE id=1\",\n        \"&lt;script&gt;alert('xss')&lt;/script&gt;\",\n        # Add more test cases\n    ]\n\n    start = time.time()\n    tasks = []\n\n    for _ in range(1000):\n        for content in test_contents:\n            task = sus_patterns_handler.detect(\n                content=content,\n                ip_address=\"127.0.0.1\",\n                context=\"load_test\"\n            )\n            tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    elapsed = time.time() - start\n\n    print(f\"Processed {len(tasks)} requests in {elapsed:.2f}s\")\n    print(f\"Average: {elapsed/len(tasks)*1000:.2f}ms per request\")\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#3-gradual-rollout","title":"3. Gradual Rollout","text":"<pre><code># Feature flag for new patterns\nNEW_PATTERNS_ENABLED = False\n\nif NEW_PATTERNS_ENABLED:\n    await sus_patterns_handler.add_pattern(new_pattern, custom=True)\n\n# Canary deployment\nif hash(request.client.host) % 100 &lt; 10:  # 10% of users\n    # Use new detection settings\n    config.detection_semantic_threshold = 0.6\nelse:\n    # Use stable settings\n    config.detection_semantic_threshold = 0.7\n</code></pre>"},{"location":"tutorial/security/detection-engine/performance-tuning/#performance-checklist","title":"Performance Checklist","text":"<p>Before deploying to production:</p> <ul> <li>[ ] Average execution time &lt; 50ms</li> <li>[ ] Timeout rate &lt; 1%</li> <li>[ ] No patterns with &gt; 100ms average execution</li> <li>[ ] Cache hit rate &gt; 80%</li> <li>[ ] Memory usage stable over 24 hours</li> <li>[ ] CPU usage &lt; 20% under normal load</li> <li>[ ] Tested with 10x expected traffic</li> <li>[ ] Monitoring alerts configured</li> <li>[ ] Rollback plan prepared</li> </ul>"},{"location":"tutorial/security/detection-engine/performance-tuning/#next-steps","title":"Next Steps","text":"<ul> <li>Implement Custom Patterns optimized for performance</li> <li>Configure Monitoring Dashboard for real-time insights</li> <li>Review Architecture Guide for optimization opportunities</li> </ul>"}]}