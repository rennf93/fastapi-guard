{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Guard","text":"<p><code>fastapi-guard</code> is a comprehensive security library for FastAPI applications, providing middleware to control IPs, log requests, and detect penetration attempts. It integrates seamlessly with FastAPI to offer robust protection against various security threats, ensuring your application remains secure and reliable.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_token_here\"),\n    enable_redis=False,\n    rate_limit=100,\n    auto_ban_threshold=5\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"#example-app","title":"Example App","text":"<p>Inside examples, you can find a simple example app that demonstrates how to use FastAPI Guard.</p>"},{"location":"#live-playground","title":"Live Playground","text":"<p>Try FastAPI Guard features directly in your browser:</p> <p>https://playground.fastapi-guard.com</p> <p>This interactive demo allows you to explore FastAPI Guard's capabilities without any setup.</p>"},{"location":"#docker-container","title":"Docker Container","text":"<p>You can also download the example app as a Docker container from GitHub Container Registry.</p> <pre><code># Pull the latest version\ndocker pull ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Or pull a specific version (matches library releases)\ndocker pull ghcr.io/rennf93/fastapi-guard-example:v2.1.3\n</code></pre>"},{"location":"#running-the-example-app","title":"Running the Example App","text":""},{"location":"#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example app is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>This will start both the FastAPI Guard example app and Redis service. The app will be available at http://0.0.0.0:8000.</p>"},{"location":"#using-docker-container-only","title":"Using Docker Container Only","text":"<p>Alternatively, you can run just the container:</p> <pre><code># Run with default settings\ndocker run -host 0.0.0.0 -p 8000:8000 ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Run with custom Redis connection\ndocker run -host 0.0.0.0 -p 8000:8000 \\\n -e REDIS_URL=redis://your-redis-host:your-redis-port \\\n -e REDIS_PREFIX=your-redis-prefix \\\n -e IPINFO_TOKEN=your-ipinfo-token \\\n ghcr.io/rennf93/fastapi-guard-example:latest\n</code></pre> <p>The example app includes endpoints to test various security features of FastAPI Guard. Access the Swagger documentation at http://0.0.0.0:8000/docs after running the container.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>IP Whitelisting and Blacklisting: Control access based on IP addresses.</li> <li>User Agent Filtering: Block requests from specific user agents.</li> <li>Rate Limiting: Limit the number of requests from a single IP.</li> <li>Automatic IP Banning: Automatically ban IPs after a certain number of suspicious requests.</li> <li>Penetration Attempt Detection: Detect and log potential penetration attempts.</li> <li>Custom Logging: Log security events to a custom file.</li> <li>CORS Configuration: Configure CORS settings for your FastAPI application.</li> <li>Cloud Provider IP Blocking: Block requests from cloud provider IPs (AWS, GCP, Azure).</li> <li>IP Geolocation: Use IPInfo.io API to determine the country of an IP address.</li> <li>Optimized Performance: Selective loading of external resources based on configuration.</li> <li>Flexible Storage: Choose between Redis-backed distributed state or in-memory storage.</li> <li>Automatic Fallback: Seamless operation with/without Redis connection.</li> <li>Secure Proxy Handling: Protection against X-Forwarded-For header injection attacks</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>First Steps</li> <li>IP Management</li> <li>Rate Limiting</li> <li>API Reference</li> <li>Redis Integration Guide</li> <li>Example App</li> </ul> <p>\ud83d\udcd6 Learn More in the Tutorial</p>"},{"location":"installation/","title":"Installation","text":"<p>Install <code>fastapi-guard</code> using pip:</p> <pre><code>pip install fastapi-guard\n</code></pre> <p>Note: Ensure you have Python 3.10 or higher installed.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before using <code>fastapi-guard</code>'s country filtering features, obtain an IPInfo token:</p> <ol> <li>Visit IPInfo's website to create a free account.</li> <li>After signing up, you'll receive an API token.</li> <li>The free tier includes:</li> <li>Up to 50,000 requests per month.</li> <li>Access to IP to Country database.</li> <li>Daily database updates.</li> <li>IPv4 &amp; IPv6 support.</li> </ol> <p>Note: The IPInfo token is only required when using the country filtering features (<code>blocked_countries</code>, <code>whitelist_countries</code> and/or <code>block_cloud_providers</code>).</p> <p>Usage Example:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country blocking\n    enable_redis=True,  # Enabled by default, disable to use in-memory storage\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"prod:security:\",\n    whitelist=[\"192.168.1.1\", \"2001:db8::1\"],\n    blacklist=[\"10.0.0.1\", \"2001:db8::2\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    blocked_user_agents=[\"curl\", \"wget\"],\n    auto_ban_threshold=5,\n    auto_ban_duration=86400,\n    custom_log_file=\"security.log\",\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre> <p>Note: When Redis is disabled: - Rate limiting and IP bans become instance-local - Cloud provider IP ranges refresh every hour - Penetration patterns reset on app restart</p>"},{"location":"installation/#secure-proxy-configuration","title":"Secure Proxy Configuration","text":"<p>If your application is behind a proxy or load balancer, configure trusted proxies:</p> <pre><code>config = SecurityConfig(\n    # Security configuration for proxies\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # Only trust specific IPs/ranges\n    trusted_proxy_depth=1,  # Default proxy depth\n    trust_x_forwarded_proto=True,  # Trust X-Forwarded-Proto from trusted proxies\n\n    # Other config options...\n)\n</code></pre> <p>This prevents IP spoofing attacks via X-Forwarded-For header manipulation.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#v213-2025-06-18","title":"v2.1.3 (2025-06-18)","text":""},{"location":"release-notes/#bug-fixes-v213","title":"Bug Fixes (v2.1.3)","text":"<ul> <li>Fixed IPv6 address support throughout the project - PR #51 - Issue #50</li> </ul>"},{"location":"release-notes/#v212-2025-05-26","title":"v2.1.2 (2025-05-26)","text":""},{"location":"release-notes/#improvements-v212","title":"Improvements (v2.1.2)","text":"<ul> <li>Switched from Poetry to uv for package management</li> </ul>"},{"location":"release-notes/#v211-2025-05-08","title":"v2.1.1 (2025-05-08)","text":""},{"location":"release-notes/#bug-fixes-v211","title":"Bug Fixes (v2.1.1)","text":"<ul> <li>Fixed <code>custom_response_modifier</code> implementation.</li> </ul>"},{"location":"release-notes/#v210-2025-05-08","title":"v2.1.0 (2025-05-08)","text":""},{"location":"release-notes/#improvements-v210","title":"Improvements (v2.1.0)","text":"<ul> <li>Rate Limiting: Replaced fixed window rate limiting with true sliding window algorithm</li> <li>Added atomic Redis Lua script for distributed rate limiting</li> <li>Improved timestamp tracking for more accurate request counting</li> <li>Fixed edge cases in rate limiting that could cause unexpected 429 errors</li> </ul>"},{"location":"release-notes/#v200-2025-05-05","title":"v2.0.0 (2025-05-05)","text":""},{"location":"release-notes/#security-fixes-v200","title":"Security Fixes (v2.0.0)","text":"<ul> <li>IMPORTANT: Fixed Remote Header Injection vulnerability via X-Forwarded-For manipulation (GHSA-77q8-qmj7-x7pp)</li> <li>CVE ID: CVE-2025-46814</li> <li>Added secure client IP extraction with trusted proxy validation</li> <li>Added new configuration parameters for proxy security:</li> <li><code>trusted_proxies</code>: List of trusted proxy IPs or CIDR ranges</li> <li><code>trusted_proxy_depth</code>: Configurable proxy chain depth</li> <li><code>trust_x_forwarded_proto</code>: Option to trust X-Forwarded-Proto header</li> </ul>"},{"location":"release-notes/#new-features-v200","title":"New Features (v2.0.0)","text":"<ul> <li>IPInfo is now completely optional, you can implement your own <code>GeoIPHandler</code></li> <li>Added protocol-based design for customizable geographical IP handling</li> <li>Introduced <code>GeoIPHandler</code> protocol allowing custom implementations</li> <li>Separated protocol definitions into dedicated modules</li> </ul>"},{"location":"release-notes/#improvements-v200","title":"Improvements (v2.0.0)","text":"<ul> <li>Deprecated <code>ipinfo_token</code> and <code>ipinfo_db_path</code> in favor of <code>geo_ip_handler</code></li> <li>Improved type safety and code readability</li> <li>Added runtime type checking for custom GeoIP handlers</li> </ul>"},{"location":"release-notes/#v150-2025-05-01","title":"v1.5.0 (2025-05-01)","text":""},{"location":"release-notes/#improvements-v150","title":"Improvements (v1.5.0)","text":"<ul> <li>IpInfo token is now only required when using country filtering or cloud blocking</li> <li>Performance: Selective loading of IP geolocation database and cloud IP ranges</li> <li>Only download/process IP geolocation data when country filtering is configured</li> <li>Only fetch cloud provider IP ranges when cloud blocking is enabled</li> <li>Reduced startup time and memory usage when not using all security features</li> </ul>"},{"location":"release-notes/#v140-2025-04-30","title":"v1.4.0 (2025-04-30)","text":""},{"location":"release-notes/#new-features-v140","title":"New Features (v1.4.0)","text":"<ul> <li>Added configurable logging levels for normal and suspicious requests</li> <li>Enhanced log_activity function to support all logging levels</li> <li>Added ability to completely disable request logging</li> </ul>"},{"location":"release-notes/#improvements-v140","title":"Improvements (v1.4.0)","text":"<ul> <li>Improved performance by allowing complete disabling of normal request logging</li> <li>Better log level control for different environments (dev/prod)</li> </ul>"},{"location":"release-notes/#v132-2025-04-27","title":"v1.3.2 (2025-04-27)","text":""},{"location":"release-notes/#new-features-v132","title":"New Features (v1.3.2)","text":"<ul> <li>Created an interactive FastAPI Guard Playground</li> <li>Added <code>passive_mode</code> option to log suspicious activity without blocking requests</li> <li>Enhanced <code>detect_penetration_attempt</code> function to return trigger information</li> </ul>"},{"location":"release-notes/#v122-2025-04-07","title":"v1.2.2 (2025-04-07)","text":""},{"location":"release-notes/#improvements-v122","title":"Improvements (v1.2.2)","text":"<ul> <li>Added an empty <code>py.typed</code></li> <li>Fixed the <code>package_data</code> configuration in <code>setup.py</code></li> <li>Added <code>mypy</code> configuration to <code>pyproject.toml</code></li> <li>Added <code>MANIFEST.in</code></li> </ul>"},{"location":"release-notes/#v121-2025-04-05","title":"v1.2.1 (2025-04-05)","text":""},{"location":"release-notes/#new-features-v121","title":"New Features (v1.2.1)","text":"<ul> <li>Added new pattern management methods to <code>SusPatternsManager</code>:</li> <li><code>get_default_patterns()</code> and <code>get_custom_patterns()</code> for separate pattern access</li> <li><code>get_default_compiled_patterns()</code> and <code>get_custom_compiled_patterns()</code> for separate compiled pattern access</li> <li>Enhanced <code>remove_pattern()</code> method to return success/failure status</li> </ul>"},{"location":"release-notes/#improvements-v121","title":"Improvements (v1.2.1)","text":"<ul> <li>Fixed issue with default pattern removal in <code>SusPatternsManager</code></li> <li>Improved pattern separation between default and custom patterns</li> </ul>"},{"location":"release-notes/#v120-2025-04-04","title":"v1.2.0 (2025-04-04)","text":""},{"location":"release-notes/#new-features-v120","title":"New Features (v1.2.0)","text":"<ul> <li>Added dedicated <code>RateLimitManager</code> for improved rate limiting functionality</li> <li>TTLCache-based in-memory rate limiting still available</li> <li>Extended Redis support for distributed rate limiting</li> </ul>"},{"location":"release-notes/#improvements-v120","title":"Improvements (v1.2.0)","text":"<ul> <li>Fixed rate limiting logic to properly handle rate limiting</li> <li>Standardized Singleton pattern across all handlers</li> <li>Added new <code>keys</code>and <code>delete_pattern</code> methods to <code>RedisManager</code> for easy key/pattern retrieval/cleanup</li> </ul>"},{"location":"release-notes/#v110-2025-03-21","title":"v1.1.0 (2025-03-21)","text":""},{"location":"release-notes/#new-features-v110","title":"New Features (v1.1.0)","text":"<ul> <li>Added proper typing throughout the codebase</li> <li>Added custom Docker container for example app</li> <li>Added better Docker Compose support</li> </ul>"},{"location":"release-notes/#improvements-v110","title":"Improvements (v1.1.0)","text":"<ul> <li>Fixed multiple typing issues across test files</li> <li>Improved documentation for Docker container usage</li> <li>Enhanced serialization of Redis data</li> </ul>"},{"location":"release-notes/#v100-2025-02-19","title":"v1.0.0 (2025-02-19)","text":""},{"location":"release-notes/#new-features-v100","title":"New Features (v1.0.0)","text":"<ul> <li>Added Redis integration for distributed state management</li> </ul>"},{"location":"release-notes/#improvements-v100","title":"Improvements (v1.0.0)","text":"<ul> <li>Improved tests &amp; testing coverage (100% coverage)</li> </ul>"},{"location":"release-notes/#v040-2025-02-16","title":"v0.4.0 (2025-02-16)","text":""},{"location":"release-notes/#new-features-v040","title":"New Features (v0.4.0)","text":"<ul> <li>Added <code>db_path</code> parameter to <code>IPInfoManager</code> for custom database locations</li> </ul>"},{"location":"release-notes/#improvements-v040","title":"Improvements (v0.4.0)","text":"<ul> <li>Improved IPInfo database handling with local caching</li> </ul>"},{"location":"release-notes/#bug-fixes-v034","title":"Bug Fixes (v0.3.4)","text":"<ul> <li>Fixed Azure IP ranges download by adding proper User-Agent headers (#19)</li> <li>Fixed cloud provider validation logic to properly filter invalid entries</li> <li>Resolved test coverage gaps on all test files</li> </ul>"},{"location":"release-notes/#v034-2025-01-26","title":"v0.3.4 (2025-01-26)","text":""},{"location":"release-notes/#bug-fixes-v033","title":"Bug Fixes (v0.3.3)","text":"<ul> <li>Fixed issue with accepted <code>Headers</code> on <code>Swagger UI</code> access/requests.</li> </ul>"},{"location":"release-notes/#v033-2024-12-14","title":"v0.3.3 (2024-12-14)","text":""},{"location":"release-notes/#bug-fixes-v032","title":"Bug Fixes (v0.3.2)","text":"<ul> <li>Fixed package structure to properly include all required modules</li> <li>Resolved import issues with handlers package</li> <li>Improved package installation reliability</li> </ul>"},{"location":"api/cloud-manager/","title":"CloudManager","text":"<p>The <code>CloudManager</code> class manages detection of IP addresses from major cloud providers. It uses a singleton pattern to ensure only one instance exists throughout the application.</p>"},{"location":"api/cloud-manager/#class-definition","title":"Class Definition","text":"<pre><code>class CloudManager:\n    _instance = None\n    ip_ranges: dict[str, set[ipaddress.IPv4Network]]\n    redis_handler: Any = None\n    logger: logging.Logger\n\n    def __new__(cls: type[\"CloudManager\"]) -&gt; \"CloudManager\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.ip_ranges = {\n                \"AWS\": set(),\n                \"GCP\": set(),\n                \"Azure\": set(),\n            }\n            cls._instance.redis_handler = None\n            cls._instance.logger = logging.getLogger(__name__)\n            # IP ranges are loaded on-demand, not at initialization\n        return cls._instance\n</code></pre>"},{"location":"api/cloud-manager/#redis-integration","title":"Redis Integration","text":"<p>When Redis is enabled, CloudManager automatically:</p> <ul> <li>Caches cloud IP ranges in Redis with 1-hour TTL</li> <li>Uses cached ranges if available</li> <li>Synchronizes ranges across instances</li> </ul>"},{"location":"api/cloud-manager/#methods","title":"Methods","text":""},{"location":"api/cloud-manager/#refresh","title":"refresh","text":"<pre><code>def refresh(self):\n    \"\"\"\n    Refresh IP ranges from all cloud providers.\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#is_cloud_ip","title":"is_cloud_ip","text":"<pre><code>def is_cloud_ip(\n    self,\n    ip: str,\n    providers: set[str]\n) -&gt; bool:\n    \"\"\"\n    Check if an IP belongs to specified cloud providers.\n\n    Args:\n        ip: IP address to check\n        providers: Set of provider names ('AWS', 'GCP', 'Azure')\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# The singleton instance is already created\n\n# Check if IP is from AWS\nis_aws = cloud_handler.is_cloud_ip(\"54.239.28.85\", {\"AWS\"})\n\n# Check multiple providers\nis_cloud = cloud_handler.is_cloud_ip(\n    \"35.186.224.25\",\n    {\"AWS\", \"GCP\", \"Azure\"}\n)\n\n# Refresh IP ranges manually if needed\ncloud_handler.refresh()  # Synchronous refresh\nawait cloud_handler.refresh_async()  # Asynchronous with Redis\n</code></pre>"},{"location":"api/ipban-manager/","title":"IPBanManager","text":"<p>The <code>IPBanManager</code> class handles temporary IP bans in your FastAPI application.</p>"},{"location":"api/ipban-manager/#overview","title":"Overview","text":"<pre><code>from guard.handlers.ipban_handler import IPBanManager\n\nip_ban_manager = IPBanManager()\n</code></pre> <p>The <code>IPBanManager</code> uses an in-memory cache to track banned IPs and their ban durations.</p>"},{"location":"api/ipban-manager/#distributed-banning","title":"Distributed Banning","text":"<p>When Redis is enabled:</p> <ul> <li>Bans are shared across instances</li> <li>Ban expiration is handled automatically</li> <li>Supports atomic ban operations</li> </ul> <pre><code># Cluster-wide ban\nawait ip_ban_manager.ban_ip(\"192.168.1.1\", 3600, distributed=True)\n\n# Check ban status across cluster\nis_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\", check_redis=True)\n</code></pre>"},{"location":"api/ipban-manager/#methods","title":"Methods","text":""},{"location":"api/ipban-manager/#ban_ip","title":"ban_ip","text":"<p>Ban an IP address for a specified duration.</p> <pre><code>async def ban_ip(ip: str, duration: int) -&gt; None\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to ban - <code>duration</code>: Ban duration in seconds</p> <p>Example:</p> <pre><code>await ip_ban_manager.ban_ip(\"192.168.1.1\", 3600)  # Ban for 1 hour\n</code></pre>"},{"location":"api/ipban-manager/#is_ip_banned","title":"is_ip_banned","text":"<p>Check if an IP address is currently banned.</p> <pre><code>async def is_ip_banned(ip: str) -&gt; bool\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to check</p> <p>Returns: - <code>bool</code>: True if the IP is banned, False otherwise</p> <p>Example:</p> <pre><code>is_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\")\n</code></pre>"},{"location":"api/ipban-manager/#reset","title":"reset","text":"<p>Reset all banned IPs.</p> <pre><code>async def reset() -&gt; None\n</code></pre> <p>Example:</p> <pre><code>await ip_ban_manager.reset()\n</code></pre>"},{"location":"api/ipban-manager/#usage-with-securitymiddleware","title":"Usage with SecurityMiddleware","text":"<p>The <code>IPBanManager</code> is automatically integrated when you use the <code>SecurityMiddleware</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600  # Ban for 1 hour\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ipinfo-manager/","title":"IPInfoManager","text":"<p>The <code>IPInfoManager</code> class handles IP geolocation using IPInfo's database. It uses a singleton pattern to ensure only one instance exists throughout the application.</p> <p>Performance Note: The IPInfo database is only downloaded and initialized when country-based filtering is configured in your application, improving startup time and reducing resource usage when these features aren't needed.</p>"},{"location":"api/ipinfo-manager/#class-definition","title":"Class Definition","text":"<pre><code>class IPInfoManager:\n    _instance = None\n    token: str\n    db_path: Path\n    reader: Reader | None = None\n    redis_handler: Any = None\n\n    def __new__(cls: type[\"IPInfoManager\"], token: str, db_path: Path | None = None) -&gt; \"IPInfoManager\":\n        if not token:\n            raise ValueError(\"IPInfo token is required!\")\n\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.token = token\n            cls._instance.db_path = db_path or Path(\"data/ipinfo/country_asn.mmdb\")\n            cls._instance.reader = None\n            cls._instance.redis_handler = None\n        # Update token\n        elif token:\n            cls._instance.token = token\n            # Update db_path\n            if db_path is not None:\n                cls._instance.db_path = db_path\n        return cls._instance\n</code></pre>"},{"location":"api/ipinfo-manager/#methods","title":"Methods","text":""},{"location":"api/ipinfo-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"\n    Initialize and download the database if needed.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#get_country","title":"get_country","text":"<pre><code>def get_country(self, ip: str) -&gt; str | None:\n    \"\"\"\n    Get country code for an IP address.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#close","title":"close","text":"<pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#redis-caching","title":"Redis Caching","text":"<p>The database is cached in Redis with 24-hour TTL when enabled:</p> <pre><code># Get cached database\ndb_content = await redis.get_key(\"ipinfo\", \"database\")\n\n# Force refresh cache\nawait ipinfo_db.initialize()  # Will update Redis cache\n</code></pre>"},{"location":"api/ipinfo-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\nfrom pathlib import Path\n\n# Initialize with custom database location\nipinfo_db = IPInfoManager(\n    token=\"your_token\",\n    db_path=Path(\"/custom/path/ipinfo.db\") # default is ./data/ipinfo/country_asn.mmdb\n)\nawait ipinfo_db.initialize()\n\n# Get country for IP\ncountry = ipinfo_db.get_country(\"8.8.8.8\")\nprint(f\"Country: {country}\")  # Output: \"US\"\n\n# Clean up\nipinfo_db.close()\n\n# Get the same instance\nsame_db = IPInfoManager(token=\"your_token\")  # Same instance returned\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":""},{"location":"api/overview/#core-components","title":"Core Components","text":"<ul> <li>SecurityMiddleware: The main middleware that handles all security features</li> <li>IPBanManager: Manages IP banning functionality</li> <li>IPInfoManager: Handles IP geolocation using IPInfo's database</li> <li>SusPatternsManager: Manages suspicious patterns for threat detection</li> <li>CloudManager: Handles cloud provider IP range detection</li> <li>Utilities: Helper functions for logging and request analysis</li> <li>RateLimitManager: Handles rate limiting functionality</li> <li>RedisManager: Handles Redis connections and atomic operations</li> </ul>"},{"location":"api/overview/#key-classes-and-instances","title":"Key Classes and Instances","text":"<pre><code># Core middleware\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Handler classes and their pre-initialized instances\nfrom guard.handlers.cloud_handler import CloudManager, cloud_handler\nfrom guard.handlers.ipban_handler import IPBanManager, ip_ban_manager\nfrom guard.handlers.ratelimit_handler import RateLimitManager, rate_limit_handler\nfrom guard.handlers.redis_handler import RedisManager, redis_handler\nfrom guard.handlers.suspatterns_handler import SusPatternsManager, sus_patterns_handler\n\n# Special case - requires parameters\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n</code></pre>"},{"location":"api/overview/#singleton-pattern","title":"Singleton Pattern","text":"<p>Most handler classes use a singleton pattern with <code>__new__</code> to ensure only one instance:</p> <pre><code>class ExampleHandler:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs) -&gt; \"ExampleHandler\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            # Initialize instance attributes\n        return cls._instance\n</code></pre>"},{"location":"api/overview/#configuration-model","title":"Configuration Model","text":"<p>The <code>SecurityConfig</code> class is the central configuration point:</p> <pre><code>class SecurityConfig:\n    def __init__(\n        self,\n        geo_ip_handler: GeoIPHandler | None = None,\n        whitelist: list[str] | None = None,\n        blacklist: list[str] = [],\n        blocked_countries: list[str] = [],\n        whitelist_countries: list[str] = [],\n        blocked_user_agents: list[str] = [],\n        auto_ban_threshold: int = 5,\n        auto_ban_duration: int = 3600,\n        rate_limit: int = 100,\n        rate_limit_window: int = 60,\n        enable_cors: bool = False,\n        # ... other parameters\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/overview/#optimized-loading","title":"Optimized Loading","text":"<p>FastAPI Guard uses a smart loading strategy to improve performance:</p> <ul> <li>IPInfoManager: Only downloaded and initialized when country filtering is configured</li> <li>CloudManager: Only fetches cloud provider IP ranges when cloud blocking is enabled</li> <li>Handlers Initialization: Middleware conditionally initializes components based on configuration</li> </ul> <p>This approach reduces startup time and memory usage when not all security features are needed.</p> <pre><code># Conditional loading example from middleware\nasync def initialize(self) -&gt; None:\n    if self.config.enable_redis and self.redis_handler:\n        await self.redis_handler.initialize()\n        # Only initialize when needed\n        if self.config.block_cloud_providers:\n            await cloud_handler.initialize_redis(\n                self.redis_handler, self.config.block_cloud_providers\n            )\n        await ip_ban_manager.initialize_redis(self.redis_handler)\n        # Only initialize if country filtering is enabled\n        if self.geo_ip_handler is not None:\n            await self.geo_ip_handler.initialize_redis(self.redis_handler)\n</code></pre>"},{"location":"api/ratelimit-manager/","title":"RateLimitManager","text":"<p>The <code>RateLimitManager</code> is responsible for managing rate limiting functionality in FastAPI Guard. It supports both in-memory rate limiting using timestamp tracking and distributed rate limiting using Redis.</p>"},{"location":"api/ratelimit-manager/#overview","title":"Overview","text":"<p>Rate limiting is an essential security feature that protects your API from abuse by limiting the number of requests a client can make within a specific time window. The <code>RateLimitManager</code> implements this functionality with the following features:</p> <ul> <li>True sliding window algorithm: Tracks individual request timestamps rather than simple counters</li> <li>In-memory timestamp tracking: Uses deques for efficient, chronological storage</li> <li>Redis-based distributed rate limiting: Optional support for distributed environments</li> <li>Atomic Redis operations: Uses Lua scripts for consistent counting across instances</li> <li>Configurable limits and windows: Set your own thresholds and time periods</li> <li>Singleton pattern: Ensures consistent state across requests</li> <li>Automatic cleanup: Expired timestamps are automatically removed</li> </ul>"},{"location":"api/ratelimit-manager/#example-usage","title":"Example Usage","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\n# Configure rate limiting\nconfig = SecurityConfig(\n    rate_limit=100,               # Max 100 requests\n    rate_limit_window=60,         # Per minute\n    enable_rate_limiting=True,    # Enable rate limiting (true by default)\n    enable_redis=True,            # Use Redis for distributed setup (true by default)\n    redis_url=\"redis://localhost:6379/0\"\n)\n\n# Add middleware with rate limiting\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ratelimit-manager/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/ratelimit-manager/#redis-integration","title":"Redis Integration","text":"<p>When using Redis for distributed rate limiting, the handler creates sorted sets with the following pattern:</p> <pre><code>{redis_prefix}rate_limit:rate:{client_ip}\n</code></pre> <p>Each entry in the sorted set represents a request timestamp. The keys automatically expire after twice the configured window duration.</p>"},{"location":"api/ratelimit-manager/#redis-lua-script","title":"Redis Lua Script","text":"<p>The rate limiter uses a Redis Lua script for atomic operations in distributed environments:</p> <ol> <li>Add the current timestamp to the sorted set</li> <li>Remove timestamps outside the current window</li> <li>Count the number of timestamps within the window</li> <li>Set expiry for the key</li> </ol> <p>This ensures that rate limiting is consistent even in high-concurrency environments.</p>"},{"location":"api/ratelimit-manager/#direct-access","title":"Direct Access","text":"<p>You can also access the handler directly if needed:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nhandler = rate_limit_handler(config)\n\n# Reset all rate limits\nawait handler.reset()\n</code></pre>"},{"location":"api/ratelimit-manager/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>In-memory rate limiting has lower latency but doesn't work in distributed environments</li> <li>Redis-based rate limiting works across multiple instances but adds network overhead</li> <li>The sliding window algorithm ensures accurate rate limiting without traffic spikes at window boundaries</li> <li>Automatic cleanup of old timestamps prevents memory leaks</li> </ul>"},{"location":"api/ratelimit-manager/#see-also","title":"See Also","text":"<ul> <li>Rate Limiting Tutorial</li> <li>Redis Integration</li> <li>SecurityMiddleware</li> </ul>"},{"location":"api/redis-manager/","title":"RedisManager","text":"<p>The <code>RedisManager</code> class handles Redis connections and atomic operations with automatic retries.</p>"},{"location":"api/redis-manager/#class-definition","title":"Class Definition","text":"<pre><code>class RedisManager:\n    \"\"\"\n    Robust Redis handler with connection pooling and automatic reconnection.\n    \"\"\"\n</code></pre>"},{"location":"api/redis-manager/#key-methods","title":"Key Methods","text":""},{"location":"api/redis-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"Initialize Redis connection with retry logic\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#get_connection","title":"get_connection","text":"<pre><code>@asynccontextmanager\nasync def get_connection(self):\n    \"\"\"Context manager for safe Redis operations\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#safe_operation","title":"safe_operation","text":"<pre><code>async def safe_operation(self, func, *args, **kwargs):\n    \"\"\"Execute Redis operation with error handling\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#atomic-operations","title":"Atomic Operations","text":""},{"location":"api/redis-manager/#get_key","title":"get_key","text":"<pre><code>async def get_key(self, namespace: str, key: str) -&gt; Any:\n    \"\"\"Get namespaced key with prefix\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#set_key","title":"set_key","text":"<pre><code>async def set_key(self, namespace: str, key: str, value: Any, ttl: int | None = None) -&gt; bool:\n    \"\"\"Set namespaced key with optional TTL\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#incr","title":"incr","text":"<pre><code>async def incr(self, namespace: str, key: str, ttl: int | None = None) -&gt; int:\n    \"\"\"Atomic increment with expiration\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.redis_handler import RedisManager\nfrom guard.models import SecurityConfig\n\nconfig = SecurityConfig(redis_url=\"redis://localhost:6379\")\nredis = RedisManager(config)\n\nasync def example():\n    await redis.initialize()\n    async with redis.get_connection() as conn:\n        await conn.set(\"test_key\", \"value\")\n\n    # Atomic operation\n    await redis.set_key(\"namespace\", \"key\", \"value\", ttl=3600)\n</code></pre>"},{"location":"api/security-middleware/","title":"SecurityMiddleware","text":"<p>The <code>SecurityMiddleware</code> class is the core component of FastAPI Guard that handles all security features.</p>"},{"location":"api/security-middleware/#class-definition","title":"Class Definition","text":"<pre><code>class SecurityMiddleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app: Callable[[Request], Awaitable[Response]],\n        config: SecurityConfig\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/security-middleware/#methods","title":"Methods","text":""},{"location":"api/security-middleware/#dispatch","title":"dispatch","text":"<pre><code>async def dispatch(\n    self,\n    request: Request,\n    call_next: Callable[[Request], Awaitable[Response]]\n) -&gt; Response:\n    \"\"\"\n    Main method that processes each request through\n    the security pipeline.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#create_error_response","title":"create_error_response","text":"<pre><code>async def create_error_response(\n    self,\n    status_code: int,\n    default_message: str\n) -&gt; Response:\n    \"\"\"\n    Creates standardized error responses.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#handler-integration","title":"Handler Integration","text":"<p>The middleware works with singleton handler instances:</p> <ul> <li>All handler classes (IPBanManager, CloudManager, etc.) use the singleton pattern</li> <li>The middleware initializes these existing instances conditionally based on configuration</li> <li>IPInfoManager is only initialized when country filtering is enabled</li> <li>CloudManager is only loaded when cloud provider blocking is configured</li> <li>This selective loading improves performance when not all features are used</li> </ul>"},{"location":"api/security-middleware/#redis-configuration","title":"Redis Configuration","text":"<p>Enable Redis in SecurityConfig:</p> <pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod:6379/0\",\n    redis_prefix=\"prod_security:\"\n)\n</code></pre> <p>The middleware automatically initializes: - CloudManager cloud provider ip ranges - IPBanManager distributed banning - IPInfoManager IP geolocation - RateLimitManager rate limiting - RedisManager Redis caching - SusPatternsManager suspicious patterns</p>"},{"location":"api/security-middleware/#proxy-security-configuration","title":"Proxy Security Configuration","text":"<p>The middleware supports secure handling of proxy headers:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # List of trusted proxy IPs/ranges\n    trusted_proxy_depth=1,  # Number of proxies in the chain\n    trust_x_forwarded_proto=True,  # Trust X-Forwarded-Proto header from trusted proxies\n)\n</code></pre> <p>This prevents IP spoofing attacks through header manipulation.</p>"},{"location":"api/security-middleware/#usage-example","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geographical_ip_manager=IPInfoManager(\"your_token\"),  # NOTE: Required when using country blocking\n    rate_limit=100\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/sus-patterns/","title":"SusPatternsManager","text":"<p>The <code>SusPatternsManager</code> class manages suspicious patterns for security threat detection.</p>"},{"location":"api/sus-patterns/#class-definition","title":"Class Definition","text":"<pre><code>class SusPatternsManager:\n    \"\"\"\n    A singleton class that manages suspicious patterns\n    for security checks.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#class-methods","title":"Class Methods","text":""},{"location":"api/sus-patterns/#add_pattern","title":"add_pattern","text":"<pre><code>@classmethod\nasync def add_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; None:\n    \"\"\"\n    Add a new pattern to the detection system.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#remove_pattern","title":"remove_pattern","text":"<pre><code>@classmethod\nasync def remove_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; bool:\n    \"\"\"\n    Remove a pattern from the detection system.\n\n    Returns:\n        bool: True if pattern was successfully removed, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_default_patterns","title":"get_default_patterns","text":"<pre><code>@classmethod\nasync def get_default_patterns(cls) -&gt; list[str]:\n    \"\"\"\n    Retrieve only the default patterns.\n\n    Returns:\n        list[str]: A list containing only default patterns.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_custom_patterns","title":"get_custom_patterns","text":"<pre><code>@classmethod\nasync def get_custom_patterns(cls) -&gt; list[str]:\n    \"\"\"\n    Retrieve only the custom patterns.\n\n    Returns:\n        list[str]: A list containing only custom patterns.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_all_patterns","title":"get_all_patterns","text":"<pre><code>@classmethod\nasync def get_all_patterns(cls) -&gt; list[str]:\n    \"\"\"\n    Get all registered patterns (both default and custom).\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_default_compiled_patterns","title":"get_default_compiled_patterns","text":"<pre><code>@classmethod\nasync def get_default_compiled_patterns(cls) -&gt; list[re.Pattern]:\n    \"\"\"\n    Retrieve only the default compiled patterns.\n\n    Returns:\n        list[re.Pattern]: A list containing only default compiled patterns.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_custom_compiled_patterns","title":"get_custom_compiled_patterns","text":"<pre><code>@classmethod\nasync def get_custom_compiled_patterns(cls) -&gt; list[re.Pattern]:\n    \"\"\"\n    Retrieve only the custom compiled patterns.\n\n    Returns:\n        list[re.Pattern]: A list containing only custom compiled patterns.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_all_compiled_patterns","title":"get_all_compiled_patterns","text":"<pre><code>@classmethod\nasync def get_all_compiled_patterns(cls) -&gt; list[re.Pattern]:\n    \"\"\"\n    Get all compiled patterns (both default and custom).\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#pattern-synchronization","title":"Pattern Synchronization","text":"<p>Custom patterns are stored in Redis when enabled:</p> <pre><code># Add pattern to Redis\nawait SusPatternsManager.add_pattern(r\"malicious.*\", custom=True)\n\n# Get patterns from Redis\npatterns = await redis.get_key(\"patterns\", \"custom\")\n</code></pre>"},{"location":"api/sus-patterns/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.suspatterns_handler import SusPatternsManager\n\n# Add custom pattern\nawait SusPatternsManager.add_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\n\n# Get default patterns only\ndefault_patterns = await SusPatternsManager.get_default_patterns()\n\n# Get custom patterns only\ncustom_patterns = await SusPatternsManager.get_custom_patterns()\n\n# Get all patterns\nall_patterns = await SusPatternsManager.get_all_patterns()\n\n# Remove pattern (returns True if successfully removed)\nsuccess = await SusPatternsManager.remove_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":"<p>The <code>utils</code> module provides various helper functions for security operations.</p>"},{"location":"api/utilities/#logging-functions","title":"Logging Functions","text":""},{"location":"api/utilities/#setup_custom_logging","title":"setup_custom_logging","text":"<pre><code>async def setup_custom_logging(\n    log_file: str\n) -&gt; logging.Logger:\n    \"\"\"\n    Setup custom logging for the application.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#log_activity","title":"log_activity","text":"<pre><code>async def log_activity(\n    request: Request,\n    logger: logging.Logger,\n    log_type: str = \"request\",\n    reason: str = \"\",\n    passive_mode: bool = False,\n    trigger_info: str = \"\",\n    level: Literal[\"INFO\", \"DEBUG\", \"WARNING\", \"ERROR\", \"CRITICAL\"] | None = \"WARNING\"\n):\n    \"\"\"\n    Universal logging function for all types of requests and activities.\n    \"\"\"\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code>: The FastAPI request object</li> <li><code>logger</code>: The logger instance</li> <li><code>log_type</code>: Type of log entry (default: \"request\", can also be \"suspicious\")</li> <li><code>reason</code>: Reason for flagging an activity</li> <li><code>passive_mode</code>: Whether to enable passive mode logging format</li> <li><code>trigger_info</code>: Details about what triggered detection</li> <li><code>level</code>: The logging level to use. If <code>None</code>, logging is disabled. Defaults to \"WARNING\".</li> </ul> <p>This is a unified logging function that handles regular requests, suspicious activities, and passive mode logging.</p>"},{"location":"api/utilities/#security-check-functions","title":"Security Check Functions","text":""},{"location":"api/utilities/#is_user_agent_allowed","title":"is_user_agent_allowed","text":"<pre><code>async def is_user_agent_allowed(\n    user_agent: str,\n    config: SecurityConfig\n) -&gt; bool:\n    \"\"\"\n    Check if user agent is allowed.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#check_ip_country","title":"check_ip_country","text":"<pre><code>async def check_ip_country(\n    request: str | Request,\n    config: SecurityConfig,\n    ipinfo_db: IPInfoManager\n) -&gt; bool:\n    \"\"\"\n    Check if IP is from a blocked country.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#is_ip_allowed","title":"is_ip_allowed","text":"<pre><code>async def is_ip_allowed(\n    ip: str,\n    config: SecurityConfig,\n    ipinfo_db: IPInfoManager | None = None\n) -&gt; bool:\n    \"\"\"\n    Check if IP address is allowed.\n    \"\"\"\n</code></pre> <p>The <code>ipinfo_db</code> parameter is now properly optional - it's only needed when country filtering is configured. If it's not provided when country filtering is configured, the function will work correctly but won't apply country filtering rules rules.</p> <p>This function intelligently handles:</p> <ul> <li>Whitelist/blacklist checking</li> <li>Country filtering (only when IPInfoManager is provided)</li> <li>Cloud provider detection (only when cloud blocking is configured)</li> </ul> <p>This selective processing aligns with FastAPI Guard's smart resource loading to optimize performance.</p>"},{"location":"api/utilities/#detect_penetration_attempt","title":"detect_penetration_attempt","text":"<pre><code>async def detect_penetration_attempt(\n    request: Request\n) -&gt; tuple[bool, str]\n</code></pre> <p>Detect potential penetration attempts in the request.</p> <p>This function checks various parts of the request (query params, body, path, headers) against a list of suspicious patterns to identify potential security threats.</p> <p>Returns a tuple where:</p> <ul> <li>First element is a boolean: <code>True</code> if a potential attack is detected, <code>False</code> otherwise</li> <li>Second element is a string with details about what triggered the detection, or empty string if no attack detected</li> </ul> <p>Example usage:</p> <pre><code>from fastapi import Request\nfrom guard.utils import detect_penetration_attempt\n\n@app.post(\"/api/submit\")\nasync def submit_data(request: Request):\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    if is_suspicious:\n        # Log the detection with details\n        logger.warning(f\"Attack detected: {trigger_info}\")\n        return {\"error\": \"Suspicious activity detected\"}\n    return {\"success\": True}\n</code></pre>"},{"location":"api/utilities/#extract_client_ip","title":"extract_client_ip","text":"<pre><code>def extract_client_ip(request: Request, config: SecurityConfig) -&gt; str:\n    \"\"\"\n    Securely extract the client IP address from the request, considering trusted proxies.\n\n    This function implements a secure approach to IP extraction that protects against\n    X-Forwarded-For header injection attacks.\n    \"\"\"\n</code></pre> <p>This function provides a secure way to extract client IPs by:</p> <ol> <li>Only trusting X-Forwarded-For headers from configured trusted proxies</li> <li>Using the connecting IP when not from a trusted proxy</li> <li>Properly handling proxy chains based on configured depth</li> </ol>"},{"location":"api/utilities/#usage-examples","title":"Usage Examples","text":"<pre><code>from guard.utils import (\n    setup_custom_logging,\n    log_activity,\n    detect_penetration_attempt\n)\n\n# Setup logging\nlogger = await setup_custom_logging(\"security.log\")\n\n# Log regular request\nawait log_activity(request, logger)\n\n# Log suspicious activity\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"Suspicious pattern detected\"\n)\n\n# Check for penetration attempts\nis_suspicious, trigger_info = await detect_penetration_attempt(request)\n</code></pre>"},{"location":"tutorial/advanced-customizations/","title":"Advanced Customization","text":"<p>FastAPI Guard uses a protocol-based architecture that makes it highly extensible. This guide explains how the protocol system works and how to create custom implementations.</p>"},{"location":"tutorial/advanced-customizations/#protocol-based-architecture","title":"Protocol-Based Architecture","text":"<p>FastAPI Guard uses Python's Protocol system to define interfaces that components must implement. This allows you to:</p> <ol> <li>Replace built-in handlers with custom implementations</li> <li>Extend functionality without modifying the core library</li> <li>Better separate concerns in your codebase</li> </ol>"},{"location":"tutorial/advanced-customizations/#why-protocols","title":"Why Protocols?","text":"<p>The protocol system solves several important problems:</p> <ol> <li>Avoiding dependency on third-party services: You can replace the built-in IPInfo geo-location with your own service</li> <li>Preventing circular imports: The protocols help break dependency cycles in the codebase</li> <li>Enabling extension points: Clear interfaces for adding custom functionality</li> </ol>"},{"location":"tutorial/advanced-customizations/#available-protocols","title":"Available Protocols","text":""},{"location":"tutorial/advanced-customizations/#geoiphandler-protocol","title":"GeoIPHandler Protocol","text":"<p>The <code>GeoIPHandler</code> protocol defines the interface for any geographical IP handler:</p> <pre><code>@runtime_checkable\nclass GeoIPHandler(Protocol):\n    \"\"\"Protocol for geographical IP handler.\"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool: ...\n\n    async def initialize(self) -&gt; None: ...\n\n    async def initialize_redis(self, redis_handler: RedisHandlerProtocol) -&gt; None: ...\n\n    def get_country(self, ip: str) -&gt; str | None: ...\n</code></pre>"},{"location":"tutorial/advanced-customizations/#method-details","title":"Method Details","text":"<ul> <li><code>is_initialized</code>: Should return whether the handler is ready to use</li> <li><code>initialize()</code>: Should set up the handler (load databases, connect to APIs, etc.)</li> <li><code>initialize_redis()</code>: Should store the redis handler for optional caching</li> <li><code>get_country()</code>: Should return the ISO 3166-1 alpha-2 country code for the IP</li> </ul>"},{"location":"tutorial/advanced-customizations/#redishandlerprotocol","title":"RedisHandlerProtocol","text":"<p>IMPORTANT: Users do NOT need to implement this protocol. It exists purely for internal use to break dependency cycles and define what the Redis handler must support for the custom GeoIP handlers.</p> <pre><code>@runtime_checkable\nclass RedisHandlerProtocol(Protocol):\n    \"\"\"Protocol for Redis handlers.\"\"\"\n\n    async def get_key(self, namespace: str, key: str) -&gt; Any: ...\n\n    async def set_key(\n        self, namespace: str, key: str, value: Any, ttl: int | None = None\n    ) -&gt; bool | None: ...\n\n    def get_connection(self) -&gt; AsyncContextManager[Redis]: ...\n\n    async def initialize(self) -&gt; None: ...\n</code></pre>"},{"location":"tutorial/advanced-customizations/#how-protocols-are-used","title":"How Protocols Are Used","text":"<p>The FastAPI Guard initialization flow works like this:</p> <ol> <li>You create a <code>SecurityConfig</code> with your custom <code>geo_ip_handler</code></li> <li>You add the <code>SecurityMiddleware</code> with this config</li> <li>When the middleware initializes, it:</li> <li>Checks if you provided a <code>geo_ip_handler</code> that implements the protocol</li> <li>If Redis is enabled, it passes its internal <code>RedisManager</code> to your handler</li> <li>Your handler can use this Redis connection for caching or whatever you need</li> </ol> <p>This makes your custom geo IP handler fully integrated with the middleware's Redis infrastructure.</p>"},{"location":"tutorial/advanced-customizations/#implementation-examples","title":"Implementation Examples","text":""},{"location":"tutorial/advanced-customizations/#example-custom-geo-ip-service","title":"Example: Custom Geo IP Service","text":"<p>Here's a complete example of a custom GeoIPHandler implementation that uses a different service:</p> <pre><code>from guard.protocols.geo_ip_protocol import GeoIPHandler\nfrom guard.protocols.redis_protocol import RedisHandlerProtocol\n\nclass CustomGeoIPHandler:\n    \"\"\"Custom handler using Custom GeoIP database\"\"\"\n\n    def __init__(self, license_key: str, db_path: str = \"CustomGeoIP.mmdb\"):\n        self._initialized = False\n        self.license_key = license_key\n        self.db_path = db_path\n        self.reader = None\n        self.redis = None  # Will store the FastAPI Guard's Redis handler\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        return self.reader is not None\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Initialize by downloading or loading the Custom GeoIP database\"\"\"\n        import os\n        import somelibrary\n\n        # Check if we have a cached copy in Redis\n        if self.redis:\n            cached_db = await self.redis.get_key(\"custom\", \"database\")\n            if cached_db:\n                with open(self.db_path, \"wb\") as f:\n                    f.write(cached_db if isinstance(cached_db, bytes)\n                            else cached_db.encode(\"latin-1\"))\n                self.reader = somelibrary.Reader(self.db_path)\n                self._initialized = True\n                return\n\n        # Download if needed (simplified - in a real app, use your API)\n        if not os.path.exists(self.db_path):\n            # Custom code to download database using license_key\n            pass\n\n        # Open the database\n        if os.path.exists(self.db_path):\n            self.reader = somelibrary.Reader(self.db_path)\n            self._initialized = True\n\n    async def initialize_redis(self, redis_handler: RedisHandlerProtocol) -&gt; None:\n        \"\"\"Store Redis handler and initialize\"\"\"\n        self.redis = redis_handler  # Store the Redis handler provided by FastAPI Guard\n        await self.initialize()\n\n    def get_country(self, ip: str) -&gt; str | None:\n        \"\"\"Get country code from IP using Custom GeoIP database\"\"\"\n        if not self.reader:\n            raise RuntimeError(\"Database not initialized\")\n\n        try:\n            response = self.reader.country(ip)\n            return response.country.iso_code\n        except Exception:\n            return None\n</code></pre>"},{"location":"tutorial/advanced-customizations/#usage-in-application","title":"Usage in Application","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom your_custom_module import CustomGeoIPHandler\n\napp = FastAPI()\n\n# Use custom handler instead of default IPInfoManager\nconfig = SecurityConfig(\n    geo_ip_handler=CustomGeoIPHandler(args),\n    blocked_countries=[\"CN\", \"RU\"],\n    # Other configuration...\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/advanced-customizations/#technical-details-how-redis-integration-works","title":"Technical Details: How Redis Integration Works","text":"<p>When you create a custom GeoIPHandler:</p> <ol> <li>FastAPI Guard's middleware will call your handler's <code>initialize_redis()</code> method</li> <li>It passes its internal <code>RedisManager</code> to your handler</li> <li>Your handler can store this manager and use it for caching</li> </ol> <p>You don't need to: - Create your own Redis connection - Implement RedisHandlerProtocol - Manage Redis connection pools</p> <p>The built-in RedisManager handles all of this for you.</p> <p>When a GeoIPHandler implementation receives a Redis handler in <code>initialize_redis()</code>, it can use it to:</p> <ol> <li>Cache lookup results to improve performance</li> <li>Store database files across application restarts</li> <li>Share state across multiple application instances</li> </ol> <p>The Redis handler provides these key methods:</p> <pre><code># Store a value with optional TTL\nawait redis_handler.set_key(\"namespace\", \"key\", \"value\", ttl=3600)\n\n# Retrieve a value\nvalue = await redis_handler.get_key(\"namespace\", \"key\")\n\n# Use the connection directly (advanced)\nasync with redis_handler.get_connection() as conn:\n    # Direct Redis operations\n    pass\n</code></pre> <p>Remember: You don't implement the RedisHandlerProtocol yourself - FastAPI Guard provides its built-in RedisManager which meets this protocol and is automatically passed to your custom GeoIPHandler.</p>"},{"location":"tutorial/first-steps/","title":"First Steps","text":"<p>Let's start with a simple example that shows how to add FastAPI Guard to your application.</p>"},{"location":"tutorial/first-steps/#create-a-fastapi-application","title":"Create a FastAPI application","text":"<p>First, create a new FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n</code></pre>"},{"location":"tutorial/first-steps/#configure-security-settings","title":"Configure Security Settings","text":"<p>Create a <code>SecurityConfig</code> instance with your desired settings:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required for geolocation\n    db_path=\"data/ipinfo/country_asn.mmdb\",  # Optional, default: ./data/ipinfo/country_asn.mmdb\n    enable_redis=True,  # Enable Redis integration\n    redis_url=\"redis://localhost:6379\",  # Redis URL\n    rate_limit=100,  # Max requests per minute\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    custom_log_file=\"security.log\"  # Custom log file\n)\n</code></pre> <p>Note: FastAPI Guard only loads resources as needed. The IPInfo database is only downloaded when country filtering is configured, and cloud IP ranges are only fetched when cloud provider blocking is enabled.</p>"},{"location":"tutorial/first-steps/#add-the-middleware","title":"Add the Middleware","text":"<p>Add the security middleware to your application:</p> <pre><code>app.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/first-steps/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing basic usage:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),\n    enable_redis=True,  # Redis enabled\n    redis_url=\"redis://localhost:6379\",\n    whitelist=[\"192.168.1.1\", \"2001:db8::1\"],\n    blacklist=[\"10.0.0.1\", \"2001:db8::2\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    rate_limit=100,\n    custom_log_file=\"security.log\"\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"tutorial/first-steps/#run-the-application","title":"Run the Application","text":"<p>Run your application using uvicorn:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Your API is now protected by FastAPI Guard! \ud83d\udee1\ufe0f</p>"},{"location":"tutorial/first-steps/#whats-next","title":"What's Next","text":"<ul> <li>Learn about IP Management</li> <li>Configure Rate Limiting</li> <li>Set up Penetration Detection</li> <li>Learn about Redis Integration</li> </ul>"},{"location":"tutorial/configuration/cors/","title":"CORS Configuration","text":"<p>FastAPI Guard provides comprehensive CORS (Cross-Origin Resource Sharing) configuration options.</p>"},{"location":"tutorial/configuration/cors/#basic-cors-setup","title":"Basic CORS Setup","text":"<p>Enable CORS with default settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\"*\"]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#advanced-configuration","title":"Advanced Configuration","text":"<p>Configure specific CORS settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://example.com\",\n        \"https://api.example.com\"\n    ],\n    cors_allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    cors_allow_headers=[\"*\"],\n    cors_allow_credentials=True,\n    cors_expose_headers=[\"X-Custom-Header\"],\n    cors_max_age=600\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#origin-patterns","title":"Origin Patterns","text":"<p>Use patterns to match multiple origins:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://*.example.com\",\n        \"https://*.api.example.com\"\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#credentials-support","title":"Credentials Support","text":"<p>Enable credentials support for authenticated requests:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_credentials=True,\n    cors_allow_origins=[\n        \"https://app.example.com\"  # Must be specific origin when using credentials\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/cors/#custom-headers","title":"Custom Headers","text":"<p>Configure custom headers for CORS:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_headers=[\n        \"Authorization\",\n        \"Content-Type\",\n        \"X-Custom-Header\"\n    ],\n    cors_expose_headers=[\n        \"X-Custom-Response-Header\"\n    ]\n)\nSecurityMiddleware.configure_cors(app, security_config)\n</code></pre>"},{"location":"tutorial/configuration/logging/","title":"Logging Configuration","text":"<p>FastAPI Guard includes powerful logging capabilities to help you monitor and track security-related events in your application.</p>"},{"location":"tutorial/configuration/logging/#basic-logging-setup","title":"Basic Logging Setup","text":"<p>Configure basic logging:</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"security.log\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#configurable-log-levels","title":"Configurable Log Levels","text":"<p>FastAPI Guard supports different log levels for normal and suspicious requests:</p> <pre><code>config = SecurityConfig(\n    # Log normal requests as INFO (or set to None to disable)\n    log_request_level=\"INFO\",\n    # Log suspicious activity as WARNING\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre> <p>Available log levels:</p> <ul> <li><code>\"INFO\"</code>: Informational messages</li> <li><code>\"DEBUG\"</code>: Detailed debug information</li> <li><code>\"WARNING\"</code>: Warning messages (default for suspicious activity)</li> <li><code>\"ERROR\"</code>: Error conditions</li> <li><code>\"CRITICAL\"</code>: Critical errors</li> <li><code>None</code>: Disable logging completely</li> </ul>"},{"location":"tutorial/configuration/logging/#performance-optimization","title":"Performance Optimization","text":"<p>For high-traffic production environments, consider disabling normal request logging:</p> <pre><code>config = SecurityConfig(\n    # Disable normal request logging (default)\n    log_request_level=None,\n    # Keep security event logging enabled\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#custom-logger","title":"Custom Logger","text":"<pre><code>from guard.utils import setup_custom_logging\n\n# Setup custom logging to a file\nlogger = await setup_custom_logging(\"security.log\")\n</code></pre>"},{"location":"tutorial/configuration/logging/#logging","title":"Logging","text":"<p>FastAPI Guard uses a unified logging approach with the <code>log_activity</code> function that handles different types of log events:</p> <pre><code>from guard.utils import log_activity\n\n# Log a regular request\nawait log_activity(request, logger)\n\n# Log suspicious activity\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"Suspicious IP address detected\"\n)\n\n# Log penetration attempt in passive mode\nawait log_activity(\n    request,\n    logger,\n    log_type=\"suspicious\",\n    reason=\"SQL injection attempt detected\",\n    passive_mode=True,\n    trigger_info=\"Detected pattern: ' OR 1=1 --\"\n)\n\n# Log with specific level\nawait log_activity(\n    request,\n    logger,\n    level=\"ERROR\",\n    reason=\"Authentication failure\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#logging-parameters","title":"Logging Parameters","text":"<p>The <code>log_activity</code> function accepts the following parameters:</p> <ul> <li><code>request</code>: The FastAPI request object</li> <li><code>logger</code>: The logger instance to use</li> <li><code>log_type</code>: Type of log entry (default: \"request\", can also be \"suspicious\")</li> <li><code>reason</code>: Reason for flagging an activity</li> <li><code>passive_mode</code>: Whether to format log as passive mode detection</li> <li><code>trigger_info</code>: Details about what triggered detection</li> <li><code>level</code>: The logging level to use. If <code>None</code>, logging is disabled. Defaults to \"WARNING\".</li> </ul>"},{"location":"tutorial/configuration/logging/#log-format","title":"Log Format","text":"<p>By default, logs include the following information:</p> <ul> <li>Timestamp</li> <li>Client IP address</li> <li>HTTP method</li> <li>Request path</li> <li>Request headers</li> <li>Request body (if available)</li> <li>Reason for logging (for suspicious activities)</li> <li>Detection trigger details (for penetration attempts)</li> </ul>"},{"location":"tutorial/examples/example-app/","title":"Example Application","text":"<p>FastAPI Guard comes with a fully functional example application that demonstrates its key security features. This example serves both as a reference implementation and a testing ground for your security settings.</p>"},{"location":"tutorial/examples/example-app/#features-demonstrated","title":"Features Demonstrated","text":"<p>The example app demonstrates:</p> <ul> <li>IP whitelist/blacklist filtering</li> <li>Rate limiting</li> <li>Penetration detection and prevention</li> <li>Auto-banning of suspicious IPs</li> <li>Geolocation-based filtering</li> <li>User agent filtering</li> <li>Redis integration</li> </ul>"},{"location":"tutorial/examples/example-app/#code-overview","title":"Code Overview","text":"<p>The example app is built using FastAPI and shows how to integrate FastAPI Guard as middleware:</p> <p>Example Code</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Initialize FastAPI app\napp = FastAPI(title=\"FastAPI Guard Playground\")\n\n# Configure FastAPI Guard\nconfig = SecurityConfig(\n    # Whitelist/Blacklist\n    whitelist=[\"0.0.0.0/32\", \"0.0.0.0\"],\n    blacklist=[\"192.168.1.100/32\", \"192.168.1.100\"],\n    ...\n)\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/examples/example-app/#running-the-example-app","title":"Running the Example App","text":""},{"location":"tutorial/examples/example-app/#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>The Docker Compose file does the following: - Builds the FastAPI Guard example app - Runs Redis with persistent data volume - Connects the application to Redis - Exposes the app on port 8000</p>"},{"location":"tutorial/examples/example-app/#docker-compose-file","title":"Docker Compose File","text":"<p>Docker Compose File</p> <pre><code>services:\n  fastapi-guard-example:\n    build:\n      context: .\n      dockerfile: ./Dockerfile\n    command: uvicorn main:app --host 0.0.0.0 --reload\n    ports:\n      - \"8000:8000\"\n    environment:\n      - REDIS_URL=redis://redis:6379\n      - REDIS_PREFIX=${REDIS_PREFIX:-\"fastapi_guard:\"}\n      - IPINFO_TOKEN=${IPINFO_TOKEN:-\"test_token\"}\n    depends_on:\n      redis:\n        condition: service_started\n  ...\n</code></pre>"},{"location":"tutorial/examples/example-app/#test-endpoints","title":"Test Endpoints","text":"<p>Once running, you can access the following endpoints:</p> <ul> <li><code>/</code>: Basic endpoint to test connection and rate limiting</li> <li><code>/ip</code>: Returns your client IP address as seen by the server</li> <li><code>/test?input=&lt;script&gt;alert(1)&lt;/script&gt;</code>: Test with various inputs to trigger penetration detection</li> <li><code>/docs</code>: Swagger UI documentation for interactive testing</li> </ul>"},{"location":"tutorial/examples/example-app/#testing-security-features","title":"Testing Security Features","text":"<p>You can use the included test battery to verify security features:</p> <p>Test battery</p> <pre><code># For rate limiting (will trigger after 15 requests)\nfor i in {1..20}; do curl http://0.0.0.0:8000/; echo \" Request $i\"; sleep 0.2; done\n\n# For XSS detection\ncurl \"http://0.0.0.0:8000/test?input=&lt;script&gt;alert(1)&lt;/script&gt;\"\n\n# For SQL injection detection\ncurl \"http://0.0.0.0:8000/test?query=SELECT%20*%20FROM%20users\"\n\n# For path traversal detection\ncurl \"http://0.0.0.0:8000/test?path=../../../etc/passwd\"\n\n# For command injection detection\ncurl \"http://0.0.0.0:8000/test?cmd=;ls;pwd;\"\n\n...\n</code></pre>"},{"location":"tutorial/examples/example-app/#environment-variables","title":"Environment Variables","text":"<p>The example app supports the following environment variables:</p> <ul> <li><code>IPINFO_TOKEN</code>: Your IPInfo API token (default: test_token)</li> <li><code>REDIS_URL</code>: Redis connection URL (default: redis://redis:6379)</li> <li><code>REDIS_PREFIX</code>: Prefix for Redis keys (default: fastapi_guard:)</li> </ul>"},{"location":"tutorial/examples/example-app/#source-code","title":"Source Code","text":"<p>You can find the complete example code in the examples directory of the GitHub repository.</p>"},{"location":"tutorial/examples/example-app/#example-with-passive-mode","title":"Example with Passive Mode","text":"<p>For production deployments where you want to assess potential false positives before fully enabling penetration detection, use the passive mode:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig, IPInfoManager\n\napp = FastAPI(title=\"My API with Security\")\n\nconfig = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),\n\n    # Rate limiting\n    rate_limit=100,  # Allow 100 requests\n    rate_limit_window=60,  # per minute\n\n    # IP filtering\n    whitelist=[\"127.0.0.1\", \"192.168.1.0/24\"],  # Office network\n\n    # Geolocation\n    blocked_countries=[\"XX\", \"YY\"],  # Block specific countries\n\n    # Logging configuration\n    log_request_level=\"INFO\",       # Log normal requests as INFO (for development)\n    # log_request_level=None,       # Or disable for production\n    log_suspicious_level=\"WARNING\", # Keep suspicious activity at WARNING level\n\n    # Penetration detection with passive mode\n    enable_penetration_detection=True,\n    passive_mode=True,  # Don't block, just log\n\n    # Auto-banning (will only be logged in passive mode)\n    enable_ip_banning=True,\n    auto_ban_threshold=5,  # Number of suspicious requests before ban\n    auto_ban_duration=3600,  # Ban duration in seconds (1 hour)\n\n    # Redis for distributed deployment (optional)\n    enable_redis=True,\n    redis_url=\"redis://localhost:6379\",\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <p>You can use any configuration with this mode, but it restricts penetration detection to passive mode. After running in this mode for some time and analyzing logs, you can switch to full protection mode by removing the <code>passive_mode=True</code> flag or setting it to <code>False</code> (false by default).</p>"},{"location":"tutorial/ip-management/banning/","title":"IP Banning","text":"<p>FastAPI Guard provides powerful IP banning capabilities through the <code>IPBanManager</code>.</p>"},{"location":"tutorial/ip-management/banning/#automatic-ip-banning","title":"Automatic IP Banning","text":"<p>Configure automatic IP banning based on suspicious activity:</p> <pre><code>config = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600,  # Ban duration in seconds (1 hour)\n)\n</code></pre>"},{"location":"tutorial/ip-management/banning/#manual-ip-banning","title":"Manual IP Banning","text":"<p>You can also manually ban IPs using the <code>IPBanManager</code>:</p> <pre><code>from guard.handlers.ipban_handler import ip_ban_manager\n\n@app.post(\"/admin/ban/{ip}\")\nasync def ban_ip(ip: str, duration: int = 3600):\n    await ip_ban_manager.ban_ip(ip, duration)\n    return {\"message\": f\"IP {ip} banned for {duration} seconds\"}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#checking-ban-status","title":"Checking Ban Status","text":"<p>Check if an IP is currently banned:</p> <pre><code>@app.get(\"/admin/check/{ip}\")\nasync def check_ban(ip: str):\n    is_banned = await ip_ban_manager.is_ip_banned(ip)\n    return {\"ip\": ip, \"banned\": is_banned}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#reset-all-bans","title":"Reset All Bans","text":"<p>Clear all active IP bans:</p> <pre><code>@app.post(\"/admin/reset\")\nasync def reset_bans():\n    await ip_ban_manager.reset()\n    return {\"message\": \"All IP bans cleared\"}\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/","title":"Cloud Provider IP Blocking","text":"<p>FastAPI Guard can automatically detect and block requests from major cloud providers. The IP ranges for these providers are only loaded when cloud blocking is enabled, improving startup performance.</p>"},{"location":"tutorial/ip-management/cloud-providers/#supported-providers","title":"Supported Providers","text":"<p>Currently supported cloud providers:</p> <ul> <li>Amazon Web Services (AWS)</li> <li>Google Cloud Platform (GCP)</li> <li>Microsoft Azure</li> </ul>"},{"location":"tutorial/ip-management/cloud-providers/#basic-configuration","title":"Basic Configuration","text":"<p>Enable cloud provider IP blocking:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\", \"GCP\", \"Azure\"}\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#selective-blocking","title":"Selective Blocking","text":"<p>Block specific providers:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\"}  # Only block AWS IPs\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#ip-range-updates","title":"IP Range Updates","text":"<p>Cloud IP ranges are automatically updated daily. You can manually refresh them:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# Refresh IP ranges\ncloud_handler.refresh()\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#custom-ip-checking","title":"Custom IP Checking","text":"<p>Check if an IP belongs to a cloud provider:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n@app.get(\"/check-cloud/{ip}\")\nasync def check_cloud_ip(ip: str):\n    is_cloud = cloud_handler.is_cloud_ip(\n        ip,\n        providers={\"AWS\", \"GCP\", \"Azure\"}\n    )\n    return {\"ip\": ip, \"is_cloud\": is_cloud}\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/","title":"IP Geolocation","text":"<p>FastAPI Guard accepts an arbitrary class that implements geolocation and country-based filtering. All it needs is to implement the following protocol:</p> <pre><code>class GeoIPHandler(Protocol):\n    \"\"\"\n    Protocol for geographical IP handler.\n    \"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool: ...\n\n    async def initialize(self) -&gt; None: ...\n\n    async def initialize_redis(self, redis_handler: \"RedisManager\") -&gt; None: ...\n\n    def get_country(self, ip: str) -&gt; str | None: ...\n</code></pre> <p>It provides an implementation that uses the ipinfo.io service:</p> <pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\n</code></pre> <p>The geolocation handler is only initialized and used when country filtering is configured, improving performance for applications that don't need these features.</p>"},{"location":"tutorial/ip-management/geolocation/#setup","title":"Setup","text":""},{"location":"tutorial/ip-management/geolocation/#option-1-using-the-built-in-ipinfohandler","title":"Option 1: Using the built-in IPInfoHandler","text":"<ol> <li>Get your IPInfo token from ipinfo.io</li> <li>Configure geolocation in your app:</li> </ol> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    blocked_countries=[\"CN\", \"RU\"],  # Block specific countries\n    whitelist_countries=[\"US\", \"CA\"],\n    db_path=\"custom/ipinfo.db\",  # Optional custom database path\n    block_cloud_providers={\"AWS\", \"GCP\"}  # Case-sensitive provider names\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#option-2-providing-a-custom-geographical-ip-handler","title":"Option 2: Providing a custom geographical IP handler","text":"<pre><code>class CustomGeoIPHandler:\n    \"\"\"\n    Your custom class.\n    \"\"\"\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        # your implementation\n        ...\n\n    async def initialize(self) -&gt; None:\n        # your implementation\n        ...\n\n    async def initialize_redis(self, redis_handler: \"RedisManager\") -&gt; None:\n        # your implementation\n        ...\n\n    def get_country(self, ip: str) -&gt; str | None:\n        # your implementation\n        ...\n\n\nconfig = SecurityConfig(\n    geo_ip_handler=CustomGeoIPHandler(),\n    blocked_countries=[\"CN\", \"RU\"],  # Block specific countries\n    whitelist_countries=[\"US\", \"CA\"],\n    db_path=\"custom/ipinfo.db\",  # Optional custom database path\n    block_cloud_providers={\"AWS\", \"GCP\"}  # Case-sensitive provider names\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-blocking","title":"Country Blocking","text":"<p>Block requests from specific countries using ISO 3166-1 alpha-2 country codes:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    blocked_countries=[\n        \"CN\",  # China\n        \"RU\",  # Russia\n        \"IR\",  # Iran\n        \"KP\"   # North Korea\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-whitelisting","title":"Country Whitelisting","text":"<p>Only allow requests from specific countries:</p> <pre><code>config = SecurityConfig(\n    geo_ip_handler=IPInfoManager(\"your_ipinfo_token_here\"),  # NOTE: Required when using country filtering\n    whitelist_countries=[\n        \"US\",  # United States\n        \"CA\",  # Canada\n        \"GB\",  # United Kingdom\n        \"AU\"   # Australia\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#custom-geolocation-logic","title":"Custom Geolocation Logic","text":"<p>You can also use the <code>IPInfoManager</code> directly for custom geolocation logic:</p> <pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\n\nipinfo_db = IPInfoManager(token=\"your_ipinfo_token_here\")  # NOTE: Required when using custom geolocation\nawait ipinfo_db.initialize()\n\n@app.get(\"/country/{ip}\")\nasync def get_ip_country(ip: str):\n    country = ipinfo_db.get_country(ip)\n    return {\"ip\": ip, \"country\": country}\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security feature that protects your API from abuse, DoS attacks, and excessive usage. FastAPI Guard provides a robust rate limiting system through the dedicated <code>RateLimitManager</code> class.</p>"},{"location":"tutorial/ip-management/rate-limiter/#basic-configuration","title":"Basic Configuration","text":"<p>To enable rate limiting, configure the following parameters in your <code>SecurityConfig</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,               # Maximum number of requests allowed\n    rate_limit_window=60,         # Time window in seconds\n    # ... other configuration options ...\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#how-it-works","title":"How It Works","text":"<p>FastAPI Guard implements a sliding window rate limiting algorithm:</p> <ol> <li>Each client request is tracked using a timestamp</li> <li>Only requests within the current time window (last <code>rate_limit_window</code> seconds) are counted</li> <li>When a new request arrives, timestamps older than the window are automatically discarded</li> <li>If the count of valid timestamps exceeds <code>rate_limit</code>, the request is rejected with a 429 status</li> <li>This ensures precise rate limiting without artificial time boundaries</li> </ol> <p>The sliding window approach offers several advantages over fixed windows: - No traffic spikes at window boundaries - More consistent load on your API - Fair treatment of users across time periods - More accurate request counting</p>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-vs-redis-rate-limiting","title":"In-Memory vs. Redis Rate Limiting","text":"<p>FastAPI Guard supports two rate limiting storage backends:</p>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-rate-limiting","title":"In-Memory Rate Limiting","text":"<p>By default, rate limiting uses an in-memory deque for tracking request timestamps:</p> <pre><code>config = SecurityConfig(\n    # Rate limit is enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    enable_redis=False,\n)\n</code></pre> <p>Pros: - Simple setup (no external dependencies) - Fast performance - Automatic cleanup of old timestamps - True sliding window algorithm</p> <p>Cons: - Doesn't work across multiple application instances - Lost on application restart - Consumes application memory</p>"},{"location":"tutorial/ip-management/rate-limiter/#redis-based-rate-limiting","title":"Redis-Based Rate Limiting","text":"<p>For distributed environments, enable Redis-based rate limiting:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"myapp:\"  # Optional prefix for Redis keys (override default)\n)\n</code></pre> <p>Pros: - Works across multiple application instances - Persists through application restarts - Uses atomic Lua scripts for reliable concurrency handling - Consistent rate limiting across distributed systems</p> <p>Cons: - Requires a Redis server - Slightly higher latency due to network calls - Additional infrastructure dependency</p>"},{"location":"tutorial/ip-management/rate-limiter/#custom-response-messages","title":"Custom Response Messages","text":"<p>You can customize the rate limit exceeded message:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    custom_error_responses={\n        429: \"Rate limit exceeded. Please try again later.\"\n    }\n)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorial/ip-management/rate-limiter/#accessing-the-rate-limiter-directly","title":"Accessing the Rate Limiter Directly","text":"<p>For advanced use cases, you can access the rate limiter directly:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nasync def some_route():\n    # Get a reference to the handler\n    handler = rate_limit_handler(config)\n\n    # Reset rate limits (e.g., for a premium user)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#resetting-rate-limits","title":"Resetting Rate Limits","text":"<p>You might want to reset rate limits in certain scenarios:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\nasync def reset_rate_limits_for_user(user_id: str):\n    handler = rate_limit_handler(config)\n\n    # Clear all rate limits (use with caution)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#implementation-details","title":"Implementation Details","text":"<p>The <code>RateLimitManager</code> is implemented as a singleton to ensure consistent state across requests. It uses:</p> <ul> <li>TTLCache for in-memory storage with automatic expiration</li> <li>Redis increments with TTL for distributed storage</li> <li>Efficient counter storage to minimize memory footprint</li> </ul>"},{"location":"tutorial/ip-management/rate-limiter/#best-practices","title":"Best Practices","text":"<ol> <li>Set reasonable limits: Consider your API's typical usage patterns</li> <li>Use Redis in production: For reliability in distributed environments</li> <li>Implement graduated limits: Consider different limits for different API endpoints</li> <li>Inform clients: Return appropriate headers with rate limit information</li> <li>Monitor usage patterns: Keep an eye on rate limit hits to adjust as needed</li> </ol>"},{"location":"tutorial/ip-management/rate-limiter/#see-also","title":"See Also","text":"<ul> <li>RateLimitManager API Reference</li> <li>Redis Integration</li> <li>Security Middleware</li> </ul>"},{"location":"tutorial/redis-integration/caching/","title":"Redis Integration","text":"<p>FastAPI Guard uses Redis for distributed state management across multiple instances.</p>"},{"location":"tutorial/redis-integration/caching/#basic-configuration","title":"Basic Configuration","text":"<pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod-redis:6379/1\",\n    redis_prefix=\"myapp:security:\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-features","title":"Key Features","text":"<ul> <li>Distributed Rate Limiting</li> <li>Shared IP Ban List</li> <li>Cloud IP Range Caching</li> <li>Pattern Storage for Penetration Detection</li> </ul>"},{"location":"tutorial/redis-integration/caching/#fallback-behavior","title":"Fallback Behavior","text":"<p>When Redis is disabled (<code>enable_redis=False</code>):</p> <ul> <li>Uses in-memory storage (TTLCache)</li> <li>Rate limits are instance-local</li> <li>IP bans only affect current instance</li> <li>Cloud IP ranges refresh hourly</li> </ul>"},{"location":"tutorial/redis-integration/caching/#connection-management","title":"Connection Management","text":"<pre><code># Get RedisManager instance from middleware\nredis = request.app.state.security_middleware.redis_handler\n\n# Manual connection handling example\nasync with redis.get_connection() as conn:\n    await conn.set(\"key\", \"value\")\n\n# Automatic operation retry with proper arguments\nawait redis.safe_operation(\n    lambda conn: conn.get(\"my_key\"),\n    namespace=\"data\",\n    key=\"my_key\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-namespacing","title":"Key Namespacing","text":"<p>Keys are automatically prefixed using: <code>{redis_prefix}{namespace}:{key}</code></p> <p>Example: <code>fastapi_guard:cloud_ranges:AWS</code></p>"},{"location":"tutorial/redis-integration/caching/#best-practices","title":"Best Practices","text":"<ol> <li>Use separate Redis databases for different environments</li> <li>Set appropriate TTLs for transient data</li> <li>Monitor connection pool size in high-traffic deployments</li> <li>Use <code>safe_operation</code> for all Redis interactions</li> </ol>"},{"location":"tutorial/security/custom-patterns/","title":"Custom Patterns","text":"<p>FastAPI Guard allows you to add custom patterns for detecting suspicious activity.</p>"},{"location":"tutorial/security/custom-patterns/#adding-custom-patterns","title":"Adding Custom Patterns","text":"<p>Add your own patterns to the detection system:</p> <pre><code>from guard.handlers.suspatterns_handler import SusPatternsManager\n\nasync def setup_patterns():\n    # Add custom pattern\n    await SusPatternsManager.add_pattern(\n        r\"malicious_pattern.*\",\n        custom=True\n    )\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-types","title":"Pattern Types","text":"<p>You can add patterns for different types of attacks:</p> <pre><code># Custom XSS pattern\nawait SusPatternsManager.add_pattern(\n    r\"&lt;script\\s*src=.*&gt;\",\n    custom=True\n)\n\n# Custom SQL injection pattern\nawait SusPatternsManager.add_pattern(\n    r\";\\s*DROP\\s+TABLE\",\n    custom=True\n)\n\n# Custom file path pattern\nawait SusPatternsManager.add_pattern(\n    r\"\\.\\.\\/.*\\/etc\\/passwd\",\n    custom=True\n)\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#managing-patterns","title":"Managing Patterns","text":"<p>Remove or modify existing patterns:</p> <pre><code># Remove a custom pattern\nsuccess = await SusPatternsManager.remove_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\nif success:\n    print(\"Pattern removed successfully\")\nelse:\n    print(\"Pattern not found\")\n\n# Get all patterns (both default and custom)\nall_patterns = await SusPatternsManager.get_all_patterns()\n\n# Get only default patterns\ndefault_patterns = await SusPatternsManager.get_default_patterns()\n\n# Get only custom patterns\ncustom_patterns = await SusPatternsManager.get_custom_patterns()\n\n# Get all compiled patterns\nall_compiled_patterns = await SusPatternsManager.get_all_compiled_patterns()\n\n# Get only default compiled patterns\ndefault_compiled = await SusPatternsManager.get_default_compiled_patterns()\n\n# Get only custom compiled patterns\ncustom_compiled = await SusPatternsManager.get_custom_compiled_patterns()\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-testing","title":"Pattern Testing","text":"<p>Test your patterns against requests:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/test/patterns\")\nasync def test_patterns(request: Request):\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    return {\n        \"suspicious\": is_suspicious,\n        \"trigger_info\": trigger_info,\n        \"request_body\": await request.body()\n    }\n</code></pre>"},{"location":"tutorial/security/monitoring/","title":"Security Monitoring","text":"<p>FastAPI Guard provides robust security logging capabilities that can be leveraged for monitoring and analytics. This guide covers how to work with the logs generated by FastAPI Guard and options for deeper security analytics.</p>"},{"location":"tutorial/security/monitoring/#basic-logging","title":"Basic Logging","text":"<p>By default, FastAPI Guard logs all security events to standard Python logging facilities. You can configure custom log paths using the <code>custom_log_file</code> parameter in the <code>SecurityConfig</code>.</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"/path/to/security.log\"\n)\n</code></pre>"},{"location":"tutorial/security/monitoring/#passive-mode-for-penetration-detection","title":"Passive Mode for Penetration Detection","text":"<p>When deploying in production environments, it's often best to start with passive mode to understand your traffic patterns before enabling blocking rules.</p> <pre><code>config = SecurityConfig(\n    enable_penetration_detection=True,\n    passive_mode=True  # Log but don't block\n)\n</code></pre> <p>In passive mode, FastAPI Guard will detect potential penetration attempts, but instead of blocking the request, it will only log the incident with the prefix <code>[PASSIVE MODE]</code> in your logs. This helps identify false positives before enabling full blocking mode.</p>"},{"location":"tutorial/security/monitoring/#configurable-log-levels","title":"Configurable Log Levels","text":"<p>FastAPI Guard allows you to configure different log levels for normal and suspicious requests:</p> <pre><code>config = SecurityConfig(\n    # Normal requests logged at INFO level (or None to disable)\n    log_request_level=\"INFO\",\n    # Security events logged at WARNING level\n    log_suspicious_level=\"WARNING\"\n)\n</code></pre> <p>This separation allows:</p> <ul> <li>Quieter logs in production by disabling or reducing normal request logging</li> <li>Maintaining visibility for security events</li> <li>Different log routing based on severity</li> </ul> <p>Available log levels include: <code>\"INFO\"</code>, <code>\"DEBUG\"</code>, <code>\"WARNING\"</code>, <code>\"ERROR\"</code>, <code>\"CRITICAL\"</code>, and <code>None</code> (to disable).</p>"},{"location":"tutorial/security/monitoring/#log-analysis","title":"Log Analysis","text":"<p>FastAPI Guard logs contain valuable security intelligence, including:</p> <ul> <li>IP addresses attempting suspicious actions</li> <li>Pattern matches indicating attack vectors (SQL injection, XSS, etc.)</li> <li>Geographic origins of traffic</li> <li>Rate limiting violations</li> <li>Cloud provider origins</li> </ul> <p>You can use standard log analysis tools to process and visualize these logs.</p>"},{"location":"tutorial/security/penetration-detection/","title":"Penetration Detection","text":"<p>FastAPI Guard includes sophisticated penetration attempt detection to identify and block malicious requests.</p>"},{"location":"tutorial/security/penetration-detection/#basic-configuration","title":"Basic Configuration","text":"<p>Enable penetration detection:</p> <pre><code>config = SecurityConfig(\n    enable_penetration_detection=True,\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600  # Ban duration in seconds\n)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#detection-patterns","title":"Detection Patterns","text":"<p>The system checks for various attack patterns including:</p> <ul> <li>SQL Injection attempts</li> <li>XSS (Cross-Site Scripting)</li> <li>Command Injection</li> <li>Path Traversal</li> <li>Template Injection</li> <li>HTTP Response Splitting</li> <li>LDAP Injection</li> <li>XML Injection</li> <li>NoSQL Injection</li> <li>File Upload attacks</li> </ul>"},{"location":"tutorial/security/penetration-detection/#custom-detection-logic","title":"Custom Detection Logic","text":"<p>You can use the penetration detection directly in your routes:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/api/data\")\nasync def submit_data(request: Request):\n    is_suspicious, trigger_info = await detect_penetration_attempt(request)\n    if is_suspicious:\n        return JSONResponse(\n            status_code=400,\n            content={\"error\": f\"Suspicious activity detected: {trigger_info}\"}\n        )\n    # Process legitimate request\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#logging-suspicious-activity","title":"Logging Suspicious Activity","text":"<p>Configure logging for suspicious activities:</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"security.log\",\n    log_level=\"WARNING\"\n)\n</code></pre> <p>Example log output:</p> <pre><code>2024-01-20 10:15:23 - WARNING - Suspicious activity detected from 192.168.1.1: POST /api/data - Reason: SQL injection attempt\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#passive-mode","title":"Passive Mode","text":"<p>When <code>passive_mode</code> is enabled, FastAPI Guard will:</p> <ol> <li>Detect potential penetration attempts (work as usual)</li> <li>Log them with detailed information about what triggered the detection</li> <li>Allow the requests to proceed without blocking</li> </ol> <p>This helps you understand your traffic patterns and fine-tune your security settings before enforcing blocks that might affect legitimate users.</p>"},{"location":"tutorial/security/penetration-detection/#how-to-use-passive-mode","title":"How to Use Passive Mode","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware, SecurityConfig\n\napp = FastAPI()\n\n# Create a configuration with passive mode enabled\nconfig = SecurityConfig(\n    enable_penetration_detection=True,  # True by default\n    passive_mode=True,  # Enable passive mode\n)\n\n# Add the middleware to your application\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#checking-logs","title":"Checking Logs","text":"<p>When using passive mode, watch your logs for entries starting with \"[PASSIVE MODE]\". These entries provide detailed information about what triggered the detection, including:</p> <ul> <li>The client's IP address</li> <li>The HTTP method and URL</li> <li>The specific pattern that was matched</li> <li>Which part of the request triggered the detection (query parameter, body, header, etc.)</li> </ul>"},{"location":"tutorial/security/proxy-security/","title":"Proxy Security","text":"<p>When your application is behind a proxy, load balancer, or CDN, properly handling the <code>X-Forwarded-For</code> header is critical for security. FastAPI Guard implements a secure approach to prevent IP spoofing attacks.</p>"},{"location":"tutorial/security/proxy-security/#the-problem","title":"The Problem","text":"<p>The <code>X-Forwarded-For</code> header is sent by proxies to identify the original client IP, but since it can be manipulated by clients, it poses a security risk if trusted blindly.</p> <p>Common security issues include:</p> <ul> <li>IP spoofing to bypass IP-based access controls</li> <li>False attribution in security logs</li> <li>Bypassing rate limiting and IP bans</li> </ul>"},{"location":"tutorial/security/proxy-security/#secure-configuration","title":"Secure Configuration","text":"<p>FastAPI Guard implements a secure-by-default approach where X-Forwarded-For headers are only trusted from explicitly configured trusted proxies:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\", \"192.168.1.0/24\"],  # List of trusted proxy IPs/ranges\n    trusted_proxy_depth=1,  # Number of proxies in the chain (default: 1)\n    trust_x_forwarded_proto=True,  # Whether to trust X-Forwarded-Proto for HTTPS detection\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#how-it-works","title":"How It Works","text":"<ol> <li>When a request arrives, FastAPI Guard checks if it's from a trusted proxy</li> <li>If not from a trusted proxy, the direct connecting IP is always used</li> <li>If from a trusted proxy, the X-Forwarded-For header is parsed to extract the original client IP</li> <li>The extracted IP is then used for all security checks</li> </ol>"},{"location":"tutorial/security/proxy-security/#configuration-options","title":"Configuration Options","text":""},{"location":"tutorial/security/proxy-security/#trusted_proxies","title":"trusted_proxies","text":"<p>List of IP addresses or CIDR ranges that are allowed to set X-Forwarded-For headers:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.1\",         # Single IP\n        \"192.168.1.0/24\",   # CIDR range\n        \"172.16.0.0/16\"     # Another CIDR range\n    ]\n)\n</code></pre> <p>If empty (default), X-Forwarded-For headers will not be trusted at all.</p>"},{"location":"tutorial/security/proxy-security/#trusted_proxy_depth","title":"trusted_proxy_depth","text":"<p>Controls how the client IP is extracted from the X-Forwarded-For header:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],\n    trusted_proxy_depth=2  # Assumes two proxies in the chain\n)\n</code></pre> <p>The X-Forwarded-For format is: <code>client, proxy1, proxy2, ...</code> (leftmost is the original client) - With depth=1 (default): Assumes one proxy in chain, uses leftmost IP as client - With depth=2: Assumes two proxies in chain, still uses leftmost IP - Higher values handle more complex proxy chains</p>"},{"location":"tutorial/security/proxy-security/#trust_x_forwarded_proto","title":"trust_x_forwarded_proto","text":"<p>Whether to trust the X-Forwarded-Proto header for HTTPS detection:</p> <pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],\n    trust_x_forwarded_proto=True  # Trust X-Forwarded-Proto from trusted proxies\n)\n</code></pre> <p>This only applies when the request comes from a trusted proxy.</p>"},{"location":"tutorial/security/proxy-security/#real-world-examples","title":"Real-World Examples","text":""},{"location":"tutorial/security/proxy-security/#single-reverse-proxy","title":"Single Reverse Proxy","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\"10.0.0.1\"],  # Your Nginx/HAProxy IP\n    trusted_proxy_depth=1,         # One proxy\n    trust_x_forwarded_proto=True   # Trust HTTPS status from proxy\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#load-balancer-proxy","title":"Load Balancer + Proxy","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.1\",         # Load balancer IP\n        \"192.168.1.0/24\"    # Internal proxy subnet\n    ],\n    trusted_proxy_depth=2,  # Two proxies in chain\n    trust_x_forwarded_proto=True\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#cloud-provider-load-balancer","title":"Cloud Provider Load Balancer","text":"<pre><code>config = SecurityConfig(\n    trusted_proxies=[\n        \"10.0.0.0/8\"        # Cloud provider's internal IP range\n    ],\n    trusted_proxy_depth=1,\n    trust_x_forwarded_proto=True\n)\n</code></pre>"},{"location":"tutorial/security/proxy-security/#best-practices","title":"Best Practices","text":"<ol> <li>Be specific: Only include the exact IPs or ranges of your known proxies</li> <li>Use correct depth: Configure based on your actual proxy chain</li> <li>Regular audits: Periodically review your trusted proxy list</li> <li>Test configuration: Verify correct IP extraction in your environment</li> </ol>"}]}