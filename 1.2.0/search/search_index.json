{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Guard","text":"<p><code>fastapi-guard</code> is a comprehensive security library for FastAPI applications, providing middleware to control IPs, log requests, and detect penetration attempts. It integrates seamlessly with FastAPI to offer robust protection against various security threats, ensuring your application remains secure and reliable.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    ipinfo_token=\"your_token_here\",\n    enable_redis=False,\n    rate_limit=100,\n    auto_ban_threshold=5\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"#example-app","title":"Example App","text":"<p>Inside examples, you can find a simple example app that demonstrates how to use FastAPI Guard.</p> <p>You can also download the example app as a Docker container from GitHub Container Registry.</p> <pre><code># Pull the latest version\ndocker pull ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Or pull a specific version (matches library releases)\ndocker pull ghcr.io/rennf93/fastapi-guard-example:v1.1.0\n</code></pre>"},{"location":"#running-the-example-app","title":"Running the Example App","text":""},{"location":"#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example app is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>This will start both the FastAPI Guard example app and Redis service. The app will be available at http://0.0.0.0:8000.</p>"},{"location":"#using-docker-container-only","title":"Using Docker Container Only","text":"<p>Alternatively, you can run just the container:</p> <pre><code># Run with default settings\ndocker run -host 0.0.0.0 -p 8000:8000 ghcr.io/rennf93/fastapi-guard-example:latest\n\n# Run with custom Redis connection\ndocker run -host 0.0.0.0 -p 8000:8000\n -e REDIS_URL=redis://your-redis-host:your-redis-port\n -e REDIS_PREFIX=your-redis-prefix\n -e IPINFO_TOKEN=your-ipinfo-token\n ghcr.io/rennf93/fastapi-guard-example:latest\n</code></pre> <p>The example app includes endpoints to test various security features of FastAPI Guard. Access the Swagger documentation at http://0.0.0.0:8000/docs after running the container.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>IP Whitelisting and Blacklisting: Control access based on IP addresses.</li> <li>User Agent Filtering: Block requests from specific user agents.</li> <li>Rate Limiting: Limit the number of requests from a single IP.</li> <li>Automatic IP Banning: Automatically ban IPs after a certain number of suspicious requests.</li> <li>Penetration Attempt Detection: Detect and log potential penetration attempts.</li> <li>Custom Logging: Log security events to a custom file.</li> <li>CORS Configuration: Configure CORS settings for your FastAPI application.</li> <li>Cloud Provider IP Blocking: Block requests from cloud provider IPs (AWS, GCP, Azure).</li> <li>IP Geolocation: Use IPInfo.io API to determine the country of an IP address.</li> <li>Flexible Storage: Choose between Redis-backed distributed state or in-memory storage</li> <li>Automatic Fallback: Seamless operation with/without Redis connection</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>First Steps</li> <li>IP Management</li> <li>Rate Limiting</li> <li>API Reference</li> <li>Redis Integration Guide</li> <li>Example App \ud83d\udcd6 Learn More in the Tutorial</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Install <code>fastapi-guard</code> using pip:</p> <pre><code>pip install fastapi-guard\n</code></pre> <p>Note: Ensure you have Python 3.10 or higher installed.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before using <code>fastapi-guard</code>, obtain an IPInfo token:</p> <ol> <li>Visit IPInfo's website to create a free account.</li> <li>After signing up, you'll receive an API token.</li> <li>The free tier includes:</li> <li>Up to 50,000 requests per month.</li> <li>Access to IP to Country database.</li> <li>Daily database updates.</li> <li>IPv4 &amp; IPv6 support.</li> </ol> <p>Usage Example:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\nconfig = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",\n    enable_redis=True,  # Enabled by default, disable to use in-memory storage\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"prod:security:\",\n    whitelist=[\"192.168.1.1\"],\n    blacklist=[\"10.0.0.1\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    blocked_user_agents=[\"curl\", \"wget\"],\n    auto_ban_threshold=5,\n    auto_ban_duration=86400,\n    custom_log_file=\"security.log\",\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre> <p>Note: When Redis is disabled: - Rate limiting and IP bans become instance-local - Cloud provider IP ranges refresh every hour - Penetration patterns reset on app restart</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#v120-2025-04-04","title":"v1.2.0 (2025-04-04)","text":""},{"location":"release-notes/#new-features","title":"New Features","text":"<ul> <li>Added dedicated <code>RateLimitManager</code> for improved rate limiting functionality</li> <li>TTLCache-based in-memory rate limiting still available</li> <li>Extended Redis support for distributed rate limiting</li> </ul>"},{"location":"release-notes/#improvements","title":"Improvements","text":"<ul> <li>Fixed rate limiting logic to properly handle rate limiting</li> <li>Standardized Singleton pattern across all handlers</li> <li>Added new <code>keys</code>and <code>delete_pattern</code> methods to <code>RedisManager</code> for easy key/pattern retrieval/cleanup</li> </ul>"},{"location":"release-notes/#v110-2025-03-21","title":"v1.1.0 (2025-03-21)","text":""},{"location":"release-notes/#new-features_1","title":"New Features","text":"<ul> <li>Added proper typing throughout the codebase</li> <li>Added custom Docker container for example app</li> <li>Added better Docker Compose support</li> </ul>"},{"location":"release-notes/#improvements_1","title":"Improvements","text":"<ul> <li>Fixed multiple typing issues across test files</li> <li>Improved documentation for Docker container usage</li> <li>Enhanced serialization of Redis data</li> </ul>"},{"location":"release-notes/#v100-2025-02-19","title":"v1.0.0 (2025-02-19)","text":""},{"location":"release-notes/#new-features_2","title":"New Features","text":"<ul> <li>Added Redis integration for distributed state management</li> </ul>"},{"location":"release-notes/#improvements_2","title":"Improvements","text":"<ul> <li>Improved tests &amp; testing coverage (100% coverage)</li> </ul>"},{"location":"release-notes/#v040-2025-02-16","title":"v0.4.0 (2025-02-16)","text":""},{"location":"release-notes/#new-features_3","title":"New Features","text":"<ul> <li>Added <code>db_path</code> parameter to <code>IPInfoManager</code> for custom database locations</li> </ul>"},{"location":"release-notes/#improvements_3","title":"Improvements","text":"<ul> <li>Improved IPInfo database handling with local caching</li> </ul>"},{"location":"release-notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed Azure IP ranges download by adding proper User-Agent headers (#19)</li> <li>Fixed cloud provider validation logic to properly filter invalid entries</li> <li>Resolved test coverage gaps on all test files</li> </ul>"},{"location":"release-notes/#v034-2025-01-26","title":"v0.3.4 (2025-01-26)","text":""},{"location":"release-notes/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed issue with accepted <code>Headers</code> on <code>Swagger UI</code> access/requests.</li> </ul>"},{"location":"release-notes/#v033-2024-12-14","title":"v0.3.3 (2024-12-14)","text":""},{"location":"release-notes/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Fixed package structure to properly include all required modules</li> <li>Resolved import issues with handlers package</li> <li>Improved package installation reliability</li> </ul>"},{"location":"api/cloud-manager/","title":"CloudManager","text":"<p>The <code>CloudManager</code> class manages detection of IP addresses from major cloud providers. It uses a singleton pattern to ensure only one instance exists throughout the application.</p>"},{"location":"api/cloud-manager/#class-definition","title":"Class Definition","text":"<pre><code>class CloudManager:\n    _instance = None\n    ip_ranges: dict[str, set[ipaddress.IPv4Network]]\n    redis_handler: Any = None\n    logger: logging.Logger\n\n    def __new__(cls: type[\"CloudManager\"]) -&gt; \"CloudManager\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.ip_ranges = {\n                \"AWS\": set(),\n                \"GCP\": set(),\n                \"Azure\": set(),\n            }\n            cls._instance.redis_handler = None\n            cls._instance.logger = logging.getLogger(__name__)\n            cls._instance._initial_refresh()\n        return cls._instance\n</code></pre>"},{"location":"api/cloud-manager/#redis-integration","title":"Redis Integration","text":"<p>When Redis is enabled, CloudManager automatically: - Caches cloud IP ranges in Redis with 1-hour TTL - Uses cached ranges if available - Synchronizes ranges across instances</p>"},{"location":"api/cloud-manager/#methods","title":"Methods","text":""},{"location":"api/cloud-manager/#refresh","title":"refresh","text":"<pre><code>def refresh(self):\n    \"\"\"\n    Refresh IP ranges from all cloud providers.\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#is_cloud_ip","title":"is_cloud_ip","text":"<pre><code>def is_cloud_ip(\n    self,\n    ip: str,\n    providers: set[str]\n) -&gt; bool:\n    \"\"\"\n    Check if an IP belongs to specified cloud providers.\n\n    Args:\n        ip: IP address to check\n        providers: Set of provider names ('AWS', 'GCP', 'Azure')\n    \"\"\"\n</code></pre>"},{"location":"api/cloud-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# The singleton instance is already created\n\n# Check if IP is from AWS\nis_aws = cloud_handler.is_cloud_ip(\"54.239.28.85\", {\"AWS\"})\n\n# Check multiple providers\nis_cloud = cloud_handler.is_cloud_ip(\n    \"35.186.224.25\",\n    {\"AWS\", \"GCP\", \"Azure\"}\n)\n\n# Refresh IP ranges manually if needed\ncloud_handler.refresh()  # Synchronous refresh\nawait cloud_handler.refresh_async()  # Asynchronous with Redis\n</code></pre>"},{"location":"api/ipban-manager/","title":"IPBanManager","text":"<p>The <code>IPBanManager</code> class handles temporary IP bans in your FastAPI application.</p>"},{"location":"api/ipban-manager/#overview","title":"Overview","text":"<pre><code>from guard.handlers.ipban_handler import IPBanManager\n\nip_ban_manager = IPBanManager()\n</code></pre> <p>The <code>IPBanManager</code> uses an in-memory cache to track banned IPs and their ban durations.</p>"},{"location":"api/ipban-manager/#distributed-banning","title":"Distributed Banning","text":"<p>When Redis is enabled: - Bans are shared across instances - Ban expiration is handled automatically - Supports atomic ban operations</p> <pre><code># Cluster-wide ban\nawait ip_ban_manager.ban_ip(\"192.168.1.1\", 3600, distributed=True)\n\n# Check ban status across cluster\nis_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\", check_redis=True)\n</code></pre>"},{"location":"api/ipban-manager/#methods","title":"Methods","text":""},{"location":"api/ipban-manager/#ban_ip","title":"ban_ip","text":"<p>Ban an IP address for a specified duration.</p> <pre><code>async def ban_ip(ip: str, duration: int) -&gt; None\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to ban - <code>duration</code>: Ban duration in seconds</p> <p>Example: <pre><code>await ip_ban_manager.ban_ip(\"192.168.1.1\", 3600)  # Ban for 1 hour\n</code></pre></p>"},{"location":"api/ipban-manager/#is_ip_banned","title":"is_ip_banned","text":"<p>Check if an IP address is currently banned.</p> <pre><code>async def is_ip_banned(ip: str) -&gt; bool\n</code></pre> <p>Parameters: - <code>ip</code>: The IP address to check</p> <p>Returns: - <code>bool</code>: True if the IP is banned, False otherwise</p> <p>Example: <pre><code>is_banned = await ip_ban_manager.is_ip_banned(\"192.168.1.1\")\n</code></pre></p>"},{"location":"api/ipban-manager/#reset","title":"reset","text":"<p>Reset all banned IPs.</p> <pre><code>async def reset() -&gt; None\n</code></pre> <p>Example: <pre><code>await ip_ban_manager.reset()\n</code></pre></p>"},{"location":"api/ipban-manager/#usage-with-securitymiddleware","title":"Usage with SecurityMiddleware","text":"<p>The <code>IPBanManager</code> is automatically integrated when you use the <code>SecurityMiddleware</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600  # Ban for 1 hour\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ipinfo-manager/","title":"IPInfoManager","text":"<p>The <code>IPInfoManager</code> class handles IP geolocation using IPInfo's database. It uses a singleton pattern to ensure only one instance exists throughout the application.</p>"},{"location":"api/ipinfo-manager/#class-definition","title":"Class Definition","text":"<pre><code>class IPInfoManager:\n    _instance = None\n    token: str\n    db_path: Path\n    reader: Reader | None = None\n    redis_handler: Any = None\n\n    def __new__(cls: type[\"IPInfoManager\"], token: str, db_path: Path | None = None) -&gt; \"IPInfoManager\":\n        if not token:\n            raise ValueError(\"IPInfo token is required!\")\n\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.token = token\n            cls._instance.db_path = db_path or Path(\"data/ipinfo/country_asn.mmdb\")\n            cls._instance.reader = None\n            cls._instance.redis_handler = None\n        # Update token\n        elif token:\n            cls._instance.token = token\n            # Update db_path\n            if db_path is not None:\n                cls._instance.db_path = db_path\n        return cls._instance\n</code></pre>"},{"location":"api/ipinfo-manager/#methods","title":"Methods","text":""},{"location":"api/ipinfo-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"\n    Initialize and download the database if needed.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#get_country","title":"get_country","text":"<pre><code>def get_country(self, ip: str) -&gt; str | None:\n    \"\"\"\n    Get country code for an IP address.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#close","title":"close","text":"<pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n</code></pre>"},{"location":"api/ipinfo-manager/#redis-caching","title":"Redis Caching","text":"<p>The database is cached in Redis with 24-hour TTL when enabled:</p> <pre><code># Get cached database\ndb_content = await redis.get_key(\"ipinfo\", \"database\")\n\n# Force refresh cache\nawait ipinfo_db.initialize()  # Will update Redis cache\n</code></pre>"},{"location":"api/ipinfo-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\nfrom pathlib import Path\n\n# Initialize with custom database location\nipinfo_db = IPInfoManager(\n    token=\"your_token\",\n    db_path=Path(\"/custom/path/ipinfo.db\") # default is ./data/ipinfo/country_asn.mmdb\n)\nawait ipinfo_db.initialize()\n\n# Get country for IP\ncountry = ipinfo_db.get_country(\"8.8.8.8\")\nprint(f\"Country: {country}\")  # Output: \"US\"\n\n# Clean up\nipinfo_db.close()\n\n# Get the same instance\nsame_db = IPInfoManager(token=\"your_token\")  # Same instance returned\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>FastAPI Guard consists of several core components:</p>"},{"location":"api/overview/#core-components","title":"Core Components","text":"<ul> <li>SecurityMiddleware: The main middleware that handles all security features</li> <li>IPBanManager: Manages IP banning functionality</li> <li>IPInfoManager: Handles IP geolocation using IPInfo's database</li> <li>SusPatternsManager: Manages suspicious patterns for threat detection</li> <li>CloudManager: Handles cloud provider IP range detection</li> <li>Utilities: Helper functions for logging and request analysis</li> <li>RateLimitManager: Handles rate limiting functionality</li> <li>RedisManager: Handles Redis connections and atomic operations</li> </ul>"},{"location":"api/overview/#key-classes-and-instances","title":"Key Classes and Instances","text":"<pre><code># Core middleware\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Handler classes and their pre-initialized instances\nfrom guard.handlers.cloud_handler import CloudManager, cloud_handler\nfrom guard.handlers.ipban_handler import IPBanManager, ip_ban_manager\nfrom guard.handlers.ratelimit_handler import RateLimitManager, rate_limit_handler\nfrom guard.handlers.redis_handler import RedisManager, redis_handler\nfrom guard.handlers.suspatterns_handler import SusPatternsManager, sus_patterns_handler\n\n# Special case - requires parameters\nfrom guard.handlers.ipinfo_handler import IPInfoManager\n</code></pre>"},{"location":"api/overview/#singleton-pattern","title":"Singleton Pattern","text":"<p>Most handler classes use a singleton pattern with <code>__new__</code> to ensure only one instance:</p> <pre><code>class ExampleHandler:\n    _instance = None\n\n    def __new__(cls, *args, **kwargs) -&gt; \"ExampleHandler\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            # Initialize instance attributes\n        return cls._instance\n</code></pre>"},{"location":"api/overview/#configuration-model","title":"Configuration Model","text":"<p>The <code>SecurityConfig</code> class is the central configuration point:</p> <pre><code>class SecurityConfig:\n    def __init__(\n        self,\n        ipinfo_token: str,\n        whitelist: Optional[List[str]] = None,\n        blacklist: List[str] = [],\n        blocked_countries: List[str] = [],\n        whitelist_countries: List[str] = [],\n        blocked_user_agents: List[str] = [],\n        auto_ban_threshold: int = 5,\n        auto_ban_duration: int = 3600,\n        rate_limit: int = 100,\n        rate_limit_window: int = 60,\n        enable_cors: bool = False,\n        # ... other parameters\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/ratelimit-manager/","title":"RateLimitManager","text":"<p>The <code>RateLimitManager</code> is responsible for managing rate limiting functionality in FastAPI Guard. It supports both in-memory rate limiting using TTLCache and distributed rate limiting using Redis.</p>"},{"location":"api/ratelimit-manager/#overview","title":"Overview","text":"<p>Rate limiting is an essential security feature that protects your API from abuse by limiting the number of requests a client can make within a specific time window. The <code>RateLimitManager</code> implements this functionality with the following features:</p> <ul> <li>In-memory rate limiting: Uses TTLCache for efficient, expiring counters</li> <li>Redis-based distributed rate limiting: Optional support for distributed environments</li> <li>Configurable limits and windows: Set your own thresholds and time periods</li> <li>Singleton pattern: Ensures consistent state across requests</li> <li>Automatic cleanup: Expired limits are automatically removed</li> </ul>"},{"location":"api/ratelimit-manager/#example-usage","title":"Example Usage","text":"<pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\n# Configure rate limiting\nconfig = SecurityConfig(\n    rate_limit=100,               # Max 100 requests\n    rate_limit_window=60,         # Per minute\n    enable_rate_limiting=True,    # Enable rate limiting (true by default)\n    enable_redis=True,            # Use Redis for distributed setup (true by default)\n    redis_url=\"redis://localhost:6379/0\"\n)\n\n# Add middleware with rate limiting\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/ratelimit-manager/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/ratelimit-manager/#redis-integration","title":"Redis Integration","text":"<p>When using Redis for distributed rate limiting, the handler creates rate limit keys with the following pattern:</p> <pre><code>{redis_prefix}rate_limit:rate:{client_ip}\n</code></pre> <p>The keys automatically expire after the configured window duration.</p>"},{"location":"api/ratelimit-manager/#direct-access","title":"Direct Access","text":"<p>You can also access the handler directly if needed:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nhandler = rate_limit_handler(config)\n\n# Reset all rate limits\nawait handler.reset()\n</code></pre>"},{"location":"api/ratelimit-manager/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>In-memory rate limiting is faster but doesn't work in distributed environments with multiple instances</li> <li>Redis-based rate limiting works across multiple instances but adds network overhead</li> <li>The TTLCache-based implementation automatically handles expiration without manual cleanup</li> </ul>"},{"location":"api/ratelimit-manager/#see-also","title":"See Also","text":"<ul> <li>Rate Limiting Tutorial</li> <li>Redis Integration</li> <li>SecurityMiddleware</li> </ul>"},{"location":"api/redis-manager/","title":"RedisManager","text":"<p>The <code>RedisManager</code> class handles Redis connections and atomic operations with automatic retries.</p>"},{"location":"api/redis-manager/#class-definition","title":"Class Definition","text":"<pre><code>class RedisManager:\n    \"\"\"\n    Robust Redis handler with connection pooling and automatic reconnection.\n    \"\"\"\n</code></pre>"},{"location":"api/redis-manager/#key-methods","title":"Key Methods","text":""},{"location":"api/redis-manager/#initialize","title":"initialize","text":"<pre><code>async def initialize(self):\n    \"\"\"Initialize Redis connection with retry logic\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#get_connection","title":"get_connection","text":"<pre><code>@asynccontextmanager\nasync def get_connection(self):\n    \"\"\"Context manager for safe Redis operations\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#safe_operation","title":"safe_operation","text":"<pre><code>async def safe_operation(self, func, *args, **kwargs):\n    \"\"\"Execute Redis operation with error handling\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#atomic-operations","title":"Atomic Operations","text":""},{"location":"api/redis-manager/#get_key","title":"get_key","text":"<pre><code>async def get_key(self, namespace: str, key: str) -&gt; Any:\n    \"\"\"Get namespaced key with prefix\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#set_key","title":"set_key","text":"<pre><code>async def set_key(self, namespace: str, key: str, value: Any, ttl: Optional[int]) -&gt; bool:\n    \"\"\"Set namespaced key with optional TTL\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#incr","title":"incr","text":"<pre><code>async def incr(self, namespace: str, key: str, ttl: Optional[int]) -&gt; int:\n    \"\"\"Atomic increment with expiration\"\"\"\n</code></pre>"},{"location":"api/redis-manager/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.redis_handler import RedisManager\nfrom guard.models import SecurityConfig\n\nconfig = SecurityConfig(redis_url=\"redis://localhost:6379\")\nredis = RedisManager(config)\n\nasync def example():\n    await redis.initialize()\n    async with redis.get_connection() as conn:\n        await conn.set(\"test_key\", \"value\")\n\n    # Atomic operation\n    await redis.set_key(\"namespace\", \"key\", \"value\", ttl=3600)\n</code></pre>"},{"location":"api/security-middleware/","title":"SecurityMiddleware","text":"<p>The <code>SecurityMiddleware</code> class is the core component of FastAPI Guard that handles all security features.</p>"},{"location":"api/security-middleware/#class-definition","title":"Class Definition","text":"<pre><code>class SecurityMiddleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app: Callable[[Request], Awaitable[Response]],\n        config: SecurityConfig\n    ):\n        # ... initialization\n</code></pre>"},{"location":"api/security-middleware/#methods","title":"Methods","text":""},{"location":"api/security-middleware/#dispatch","title":"dispatch","text":"<pre><code>async def dispatch(\n    self,\n    request: Request,\n    call_next: Callable[[Request], Awaitable[Response]]\n) -&gt; Response:\n    \"\"\"\n    Main method that processes each request through\n    the security pipeline.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#create_error_response","title":"create_error_response","text":"<pre><code>async def create_error_response(\n    self,\n    status_code: int,\n    default_message: str\n) -&gt; Response:\n    \"\"\"\n    Creates standardized error responses.\n    \"\"\"\n</code></pre>"},{"location":"api/security-middleware/#handler-integration","title":"Handler Integration","text":"<p>The middleware works with singleton handler instances:</p> <ul> <li>All handler classes (IPBanManager, CloudManager, etc.) use the singleton pattern</li> <li>The middleware initializes these existing instances</li> <li>Handlers persist their state throughout the application lifecycle</li> </ul>"},{"location":"api/security-middleware/#redis-configuration","title":"Redis Configuration","text":"<p>Enable Redis in SecurityConfig:</p> <pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod:6379/0\",\n    redis_prefix=\"prod_security:\"\n)\n</code></pre> <p>The middleware automatically initializes: - CloudManager cloud provider ip ranges - IPBanManager distributed banning - IPInfoManager IP geolocation - RateLimitManager rate limiting - RedisManager Redis caching - SusPatternsManager suspicious patterns</p>"},{"location":"api/security-middleware/#usage-example","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    ipinfo_token=\"your_token\",\n    rate_limit=100\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"api/sus-patterns/","title":"SusPatternsManager","text":"<p>The <code>SusPatternsManager</code> class manages suspicious patterns for security threat detection.</p>"},{"location":"api/sus-patterns/#class-definition","title":"Class Definition","text":"<pre><code>class SusPatternsManager:\n    \"\"\"\n    A singleton class that manages suspicious patterns\n    for security checks.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#class-methods","title":"Class Methods","text":""},{"location":"api/sus-patterns/#add_pattern","title":"add_pattern","text":"<pre><code>@classmethod\nasync def add_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; None:\n    \"\"\"\n    Add a new pattern to the detection system.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#remove_pattern","title":"remove_pattern","text":"<pre><code>@classmethod\nasync def remove_pattern(\n    cls,\n    pattern: str,\n    custom: bool = False\n) -&gt; None:\n    \"\"\"\n    Remove a pattern from the detection system.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#get_all_patterns","title":"get_all_patterns","text":"<pre><code>@classmethod\nasync def get_all_patterns(cls) -&gt; List[str]:\n    \"\"\"\n    Get all registered patterns.\n    \"\"\"\n</code></pre>"},{"location":"api/sus-patterns/#pattern-synchronization","title":"Pattern Synchronization","text":"<p>Custom patterns are stored in Redis when enabled:</p> <pre><code># Add pattern to Redis\nawait SusPatternsManager.add_pattern(r\"malicious.*\", custom=True)\n\n# Get patterns from Redis\npatterns = await redis.get_key(\"patterns\", \"custom\")\n</code></pre>"},{"location":"api/sus-patterns/#usage-example","title":"Usage Example","text":"<pre><code>from guard.handlers.suspatterns_handler import SusPatternsManager\n\n# Add custom pattern\nawait SusPatternsManager.add_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\n\n# Get all patterns\npatterns = await SusPatternsManager.get_all_patterns()\n\n# Remove pattern\nawait SusPatternsManager.remove_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":"<p>The <code>utils</code> module provides various helper functions for security operations.</p>"},{"location":"api/utilities/#logging-functions","title":"Logging Functions","text":""},{"location":"api/utilities/#setup_custom_logging","title":"setup_custom_logging","text":"<pre><code>async def setup_custom_logging(\n    log_file: str\n) -&gt; logging.Logger:\n    \"\"\"\n    Setup custom logging for the application.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#log_request","title":"log_request","text":"<pre><code>async def log_request(\n    request: Request,\n    logger: logging.Logger\n):\n    \"\"\"\n    Log details of an incoming request.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#log_suspicious_activity","title":"log_suspicious_activity","text":"<pre><code>async def log_suspicious_activity(\n    request: Request,\n    reason: str,\n    logger: logging.Logger\n):\n    \"\"\"\n    Log suspicious activity detected in a request.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#security-check-functions","title":"Security Check Functions","text":""},{"location":"api/utilities/#is_user_agent_allowed","title":"is_user_agent_allowed","text":"<pre><code>async def is_user_agent_allowed(\n    user_agent: str,\n    config: SecurityConfig\n) -&gt; bool:\n    \"\"\"\n    Check if user agent is allowed.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#check_ip_country","title":"check_ip_country","text":"<pre><code>async def check_ip_country(\n    request: Union[str, Request],\n    config: SecurityConfig,\n    ipinfo_db: IPInfoManager\n) -&gt; bool:\n    \"\"\"\n    Check if IP is from a blocked country.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#is_ip_allowed","title":"is_ip_allowed","text":"<pre><code>async def is_ip_allowed(\n    ip: str,\n    config: SecurityConfig,\n    ipinfo_db: Optional[IPInfoManager] = None\n) -&gt; bool:\n    \"\"\"\n    Check if IP address is allowed.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#detect_penetration_attempt","title":"detect_penetration_attempt","text":"<pre><code>async def detect_penetration_attempt(\n    request: Request\n) -&gt; bool:\n    \"\"\"\n    Detect potential penetration attempts.\n    \"\"\"\n</code></pre>"},{"location":"api/utilities/#usage-examples","title":"Usage Examples","text":"<pre><code>from guard.utils import (\n    setup_custom_logging,\n    log_request,\n    detect_penetration_attempt\n)\n\n# Setup logging\nlogger = await setup_custom_logging(\"security.log\")\n\n# Log request\nawait log_request(request, logger)\n\n# Check for penetration attempts\nis_suspicious = await detect_penetration_attempt(request)\n</code></pre>"},{"location":"tutorial/first-steps/","title":"First Steps","text":"<p>Let's start with a simple example that shows how to add FastAPI Guard to your application.</p>"},{"location":"tutorial/first-steps/#create-a-fastapi-application","title":"Create a FastAPI application","text":"<p>First, create a new FastAPI application:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n</code></pre>"},{"location":"tutorial/first-steps/#configure-security-settings","title":"Configure Security Settings","text":"<p>Create a <code>SecurityConfig</code> instance with your desired settings:</p> <pre><code>config = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",  # Required for geolocation\n    db_path=\"data/ipinfo/country_asn.mmdb\",  # Optional, default: ./data/ipinfo/country_asn.mmdb\n    enable_redis=True,  # Enable Redis integration\n    redis_url=\"redis://localhost:6379\",  # Redis URL\n    rate_limit=100,  # Max requests per minute\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    custom_log_file=\"security.log\"  # Custom log file\n)\n</code></pre>"},{"location":"tutorial/first-steps/#add-the-middleware","title":"Add the Middleware","text":"<p>Add the security middleware to your application:</p> <pre><code>app.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/first-steps/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing basic usage:</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",\n    enable_redis=True,  # Redis enabled\n    redis_url=\"redis://localhost:6379\",\n    whitelist=[\"192.168.1.1\"],\n    blacklist=[\"10.0.0.1\"],\n    blocked_countries=[\"AR\", \"IT\"],\n    rate_limit=100,\n    custom_log_file=\"security.log\"\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"tutorial/first-steps/#run-the-application","title":"Run the Application","text":"<p>Run your application using uvicorn:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Your API is now protected by FastAPI Guard! \ud83d\udee1\ufe0f</p>"},{"location":"tutorial/first-steps/#whats-next","title":"What's Next","text":"<ul> <li>Learn about IP Management</li> <li>Configure Rate Limiting</li> <li>Set up Penetration Detection</li> <li>Learn about Redis Integration</li> </ul>"},{"location":"tutorial/configuration/cors/","title":"CORS Configuration","text":"<p>FastAPI Guard provides comprehensive CORS (Cross-Origin Resource Sharing) configuration options.</p>"},{"location":"tutorial/configuration/cors/#basic-cors-setup","title":"Basic CORS Setup","text":"<p>Enable CORS with default settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\"*\"]\n)\n</code></pre>"},{"location":"tutorial/configuration/cors/#advanced-configuration","title":"Advanced Configuration","text":"<p>Configure specific CORS settings:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://example.com\",\n        \"https://api.example.com\"\n    ],\n    cors_allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    cors_allow_headers=[\"*\"],\n    cors_allow_credentials=True,\n    cors_expose_headers=[\"X-Custom-Header\"],\n    cors_max_age=600\n)\n</code></pre>"},{"location":"tutorial/configuration/cors/#origin-patterns","title":"Origin Patterns","text":"<p>Use patterns to match multiple origins:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_origins=[\n        \"https://*.example.com\",\n        \"https://*.api.example.com\"\n    ]\n)\n</code></pre>"},{"location":"tutorial/configuration/cors/#credentials-support","title":"Credentials Support","text":"<p>Enable credentials support for authenticated requests:</p> <pre><code>config = SecurityConfig(\n    enable_cors=True,\n    cors_allow_credentials=True,\n    cors_allow_origins=[\n        \"https://app.example.com\"  # Must be specific origin when using credentials\n    ]\n)\n</code></pre>"},{"location":"tutorial/configuration/cors/#custom-headers","title":"Custom Headers","text":"<p>Configure custom headers for CORS:</p> <p>```python config = SecurityConfig(     enable_cors=True,     cors_allow_headers=[         \"Authorization\",         \"Content-Type\",         \"X-Custom-Header\"     ],     cors_expose_headers=[         \"X-Custom-Response-Header\"     ] ) </p>"},{"location":"tutorial/configuration/logging/","title":"Logging Configuration","text":"<p>FastAPI Guard provides detailed logging capabilities for security events.</p>"},{"location":"tutorial/configuration/logging/#basic-logging-setup","title":"Basic Logging Setup","text":"<p>Configure basic logging:</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"security.log\"\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#log-levels","title":"Log Levels","text":"<p>Configure different log levels:</p> <pre><code>import logging\n\nconfig = SecurityConfig(\n    custom_log_file=\"security.log\",\n    log_level=logging.WARNING\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#custom-logger","title":"Custom Logger","text":"<p>Use the logging utilities directly:</p> <pre><code>from guard.utils import setup_custom_logging, log_suspicious_activity\n\n# Setup logger\nlogger = await setup_custom_logging(\"custom.log\")\n\n# Log suspicious activity\nawait log_suspicious_activity(\n    request,\n    \"Suspicious pattern detected\",\n    logger\n)\n</code></pre>"},{"location":"tutorial/configuration/logging/#log-format","title":"Log Format","text":"<p>Default log format: <pre><code>2024-01-20 10:15:23 - WARNING - Suspicious activity detected from 192.168.1.1: POST /api/data - Headers: {'User-Agent': 'curl/7.64.1'}\n</code></pre></p>"},{"location":"tutorial/configuration/logging/#request-logging","title":"Request Logging","text":"<p>Log all incoming requests:</p> <pre><code>from guard.utils import log_request\n\n@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next):\n    await log_request(request, logger)\n    response = await call_next(request)\n    return response\n</code></pre>"},{"location":"tutorial/examples/example-app/","title":"Example Application","text":"<p>FastAPI Guard comes with a fully functional example application that demonstrates its key security features. This example serves both as a reference implementation and a testing ground for your security settings.</p>"},{"location":"tutorial/examples/example-app/#features-demonstrated","title":"Features Demonstrated","text":"<p>The example app demonstrates:</p> <ul> <li>IP whitelist/blacklist filtering</li> <li>Rate limiting</li> <li>Penetration detection and prevention</li> <li>Auto-banning of suspicious IPs</li> <li>Geolocation-based filtering</li> <li>User agent filtering</li> <li>Redis integration</li> </ul>"},{"location":"tutorial/examples/example-app/#code-overview","title":"Code Overview","text":"<p>The example app is built using FastAPI and shows how to integrate FastAPI Guard as middleware:</p> <p>Example Code</p> <pre><code>from fastapi import FastAPI\nfrom guard.middleware import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\n# Initialize FastAPI app\napp = FastAPI(title=\"FastAPI Guard Playground\")\n\n# Configure FastAPI Guard\nconfig = SecurityConfig(\n    # Whitelist/Blacklist\n    whitelist=[\"0.0.0.0/32\", \"0.0.0.0\"],\n    blacklist=[\"192.168.1.100/32\", \"192.168.1.100\"],\n    ...\n)\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/examples/example-app/#running-the-example-app","title":"Running the Example App","text":""},{"location":"tutorial/examples/example-app/#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>The easiest way to run the example is with Docker Compose, which automatically sets up Redis:</p> <pre><code># Clone the repository\ngit clone https://github.com/rennf93/fastapi-guard.git\ncd fastapi-guard/examples\n\n# Start the app with Redis\ndocker compose up\n</code></pre> <p>The Docker Compose file does the following: - Builds the FastAPI Guard example app - Runs Redis with persistent data volume - Connects the application to Redis - Exposes the app on port 8000</p>"},{"location":"tutorial/examples/example-app/#docker-compose-file","title":"Docker Compose File","text":"<p>Docker Compose File</p> <pre><code>services:\n  fastapi-guard-example:\n    build:\n      context: .\n      dockerfile: ./Dockerfile\n    command: uvicorn main:app --host 0.0.0.0 --reload\n    ports:\n      - \"8000:8000\"\n    environment:\n      - REDIS_URL=redis://redis:6379\n      - REDIS_PREFIX=${REDIS_PREFIX:-\"fastapi_guard:\"}\n      - IPINFO_TOKEN=${IPINFO_TOKEN:-\"test_token\"}\n    depends_on:\n      redis:\n        condition: service_started\n  ...\n</code></pre>"},{"location":"tutorial/examples/example-app/#test-endpoints","title":"Test Endpoints","text":"<p>Once running, you can access the following endpoints:</p> <ul> <li><code>/</code>: Basic endpoint to test connection and rate limiting</li> <li><code>/ip</code>: Returns your client IP address as seen by the server</li> <li><code>/test?input=&lt;script&gt;alert(1)&lt;/script&gt;</code>: Test with various inputs to trigger penetration detection</li> <li><code>/docs</code>: Swagger UI documentation for interactive testing</li> </ul>"},{"location":"tutorial/examples/example-app/#testing-security-features","title":"Testing Security Features","text":"<p>You can use the included test battery to verify security features:</p> <p>Test battery</p> <pre><code># For rate limiting (will trigger after 15 requests)\nfor i in {1..20}; do curl http://0.0.0.0:8000/; echo \" Request $i\"; sleep 0.2; done\n\n# For XSS detection\ncurl \"http://0.0.0.0:8000/test?input=&lt;script&gt;alert(1)&lt;/script&gt;\"\n\n# For SQL injection detection\ncurl \"http://0.0.0.0:8000/test?query=SELECT%20*%20FROM%20users\"\n\n# For path traversal detection\ncurl \"http://0.0.0.0:8000/test?path=../../../etc/passwd\"\n\n# For command injection detection\ncurl \"http://0.0.0.0:8000/test?cmd=;ls;pwd;\"\n\n...\n</code></pre>"},{"location":"tutorial/examples/example-app/#environment-variables","title":"Environment Variables","text":"<p>The example app supports the following environment variables:</p> <ul> <li><code>IPINFO_TOKEN</code>: Your IPInfo API token (default: test_token)</li> <li><code>REDIS_URL</code>: Redis connection URL (default: redis://redis:6379)</li> <li><code>REDIS_PREFIX</code>: Prefix for Redis keys (default: fastapi_guard:)</li> </ul>"},{"location":"tutorial/examples/example-app/#source-code","title":"Source Code","text":"<p>You can find the complete example code in the examples directory of the GitHub repository.</p>"},{"location":"tutorial/ip-management/banning/","title":"IP Banning","text":"<p>FastAPI Guard provides powerful IP banning capabilities through the <code>IPBanManager</code>.</p>"},{"location":"tutorial/ip-management/banning/#automatic-ip-banning","title":"Automatic IP Banning","text":"<p>Configure automatic IP banning based on suspicious activity:</p> <pre><code>config = SecurityConfig(\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600,  # Ban duration in seconds (1 hour)\n)\n</code></pre>"},{"location":"tutorial/ip-management/banning/#manual-ip-banning","title":"Manual IP Banning","text":"<p>You can also manually ban IPs using the <code>IPBanManager</code>:</p> <pre><code>from guard.handlers.ipban_handler import ip_ban_manager\n\n@app.post(\"/admin/ban/{ip}\")\nasync def ban_ip(ip: str, duration: int = 3600):\n    await ip_ban_manager.ban_ip(ip, duration)\n    return {\"message\": f\"IP {ip} banned for {duration} seconds\"}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#checking-ban-status","title":"Checking Ban Status","text":"<p>Check if an IP is currently banned:</p> <pre><code>@app.get(\"/admin/check/{ip}\")\nasync def check_ban(ip: str):\n    is_banned = await ip_ban_manager.is_ip_banned(ip)\n    return {\"ip\": ip, \"banned\": is_banned}\n</code></pre>"},{"location":"tutorial/ip-management/banning/#reset-all-bans","title":"Reset All Bans","text":"<p>Clear all active IP bans:</p> <p>```python @app.post(\"/admin/reset\") async def reset_bans():     await ip_ban_manager.reset()     return {\"message\": \"All IP bans cleared\"}</p>"},{"location":"tutorial/ip-management/cloud-providers/","title":"Cloud Provider IP Blocking","text":"<p>FastAPI Guard can automatically detect and block requests from major cloud providers.</p>"},{"location":"tutorial/ip-management/cloud-providers/#supported-providers","title":"Supported Providers","text":"<p>Currently supported cloud providers: - Amazon Web Services (AWS) - Google Cloud Platform (GCP) - Microsoft Azure</p>"},{"location":"tutorial/ip-management/cloud-providers/#basic-configuration","title":"Basic Configuration","text":"<p>Enable cloud provider IP blocking:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\", \"GCP\", \"Azure\"}\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#selective-blocking","title":"Selective Blocking","text":"<p>Block specific providers:</p> <pre><code>config = SecurityConfig(\n    block_cloud_providers={\"AWS\"}  # Only block AWS IPs\n)\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#ip-range-updates","title":"IP Range Updates","text":"<p>Cloud IP ranges are automatically updated daily. You can manually refresh them:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n# Refresh IP ranges\ncloud_handler.refresh()\n</code></pre>"},{"location":"tutorial/ip-management/cloud-providers/#custom-ip-checking","title":"Custom IP Checking","text":"<p>Check if an IP belongs to a cloud provider:</p> <pre><code>from guard.handlers.cloud_handler import cloud_handler\n\n@app.get(\"/check-cloud/{ip}\")\nasync def check_cloud_ip(ip: str):\n    is_cloud = cloud_handler.is_cloud_ip(\n        ip,\n        providers={\"AWS\", \"GCP\", \"Azure\"}\n    )\n    return {\"ip\": ip, \"is_cloud\": is_cloud}\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/","title":"IP Geolocation","text":"<p>FastAPI Guard uses IPInfo's database for IP geolocation and country-based filtering.</p>"},{"location":"tutorial/ip-management/geolocation/#setup","title":"Setup","text":"<ol> <li>Get your IPInfo token from ipinfo.io</li> <li>Configure geolocation in your app:</li> </ol> <pre><code>config = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",\n    blocked_countries=[\"CN\", \"RU\"],  # Block specific countries\n    whitelist_countries=[\"US\", \"CA\"],\n    db_path=\"custom/ipinfo.db\",  # Optional custom database path\n    block_cloud_providers={\"AWS\", \"GCP\"}  # Case-sensitive provider names\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-blocking","title":"Country Blocking","text":"<p>Block requests from specific countries using ISO 3166-1 alpha-2 country codes:</p> <pre><code>config = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",\n    blocked_countries=[\n        \"CN\",  # China\n        \"RU\",  # Russia\n        \"IR\",  # Iran\n        \"KP\"   # North Korea\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#country-whitelisting","title":"Country Whitelisting","text":"<p>Only allow requests from specific countries:</p> <pre><code>config = SecurityConfig(\n    ipinfo_token=\"your_ipinfo_token_here\",\n    whitelist_countries=[\n        \"US\",  # United States\n        \"CA\",  # Canada\n        \"GB\",  # United Kingdom\n        \"AU\"   # Australia\n    ]\n)\n</code></pre>"},{"location":"tutorial/ip-management/geolocation/#custom-geolocation-logic","title":"Custom Geolocation Logic","text":"<p>You can also use the <code>IPInfoManager</code> directly for custom geolocation logic:</p> <pre><code>from guard.handlers.ipinfo_handler import IPInfoManager\n\nipinfo_db = IPInfoManager(token=\"your_ipinfo_token_here\")\nawait ipinfo_db.initialize()\n\n@app.get(\"/country/{ip}\")\nasync def get_ip_country(ip: str):\n    country = ipinfo_db.get_country(ip)\n    return {\"ip\": ip, \"country\": country}\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/","title":"Rate Limiting","text":"<p>Rate limiting is a crucial security feature that protects your API from abuse, DoS attacks, and excessive usage. FastAPI Guard provides a robust rate limiting system through the dedicated <code>RateLimitManager</code> class.</p>"},{"location":"tutorial/ip-management/rate-limiter/#basic-configuration","title":"Basic Configuration","text":"<p>To enable rate limiting, configure the following parameters in your <code>SecurityConfig</code>:</p> <pre><code>from fastapi import FastAPI\nfrom guard import SecurityMiddleware\nfrom guard.models import SecurityConfig\n\napp = FastAPI()\n\nconfig = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,               # Maximum number of requests allowed\n    rate_limit_window=60,         # Time window in seconds\n    # ... other configuration options ...\n)\n\napp.add_middleware(SecurityMiddleware, config=config)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#how-it-works","title":"How It Works","text":"<p>The rate limiter tracks requests by client IP address:</p> <ol> <li>When a request arrives, the rate limiter checks if the client has exceeded their limit</li> <li>If within limits, the request counter is incremented and the request proceeds</li> <li>If the limit is exceeded, a 429 Too Many Requests response is returned</li> <li>Counters automatically expire after the configured time window</li> </ol>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-vs-redis-rate-limiting","title":"In-Memory vs. Redis Rate Limiting","text":"<p>FastAPI Guard supports two rate limiting storage backends:</p>"},{"location":"tutorial/ip-management/rate-limiter/#in-memory-rate-limiting","title":"In-Memory Rate Limiting","text":"<p>By default, rate limiting uses an in-memory TTLCache for tracking request counts:</p> <pre><code>config = SecurityConfig(\n    #\u00a0Rate limit is enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    enable_redis=False,\n)\n</code></pre> <p>Pros: - Simple setup (no external dependencies) - Fast performance - Automatic expiration of old counters</p> <p>Cons: - Doesn't work across multiple application instances - Lost on application restart - Consumes application memory</p>"},{"location":"tutorial/ip-management/rate-limiter/#redis-based-rate-limiting","title":"Redis-Based Rate Limiting","text":"<p>For distributed environments, enable Redis-based rate limiting:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    redis_url=\"redis://localhost:6379/0\",\n    redis_prefix=\"myapp:\"  # Optional prefix for Redis keys (override default)\n)\n</code></pre> <p>Pros: - Works across multiple application instances - Persists through application restarts - Centralized rate limit tracking</p> <p>Cons: - Requires a Redis server - Slightly higher latency due to network calls - Additional infrastructure dependency</p>"},{"location":"tutorial/ip-management/rate-limiter/#custom-response-messages","title":"Custom Response Messages","text":"<p>You can customize the rate limit exceeded message:</p> <pre><code>config = SecurityConfig(\n    # NOTE: enable_rate_limiting is not required, it's enabled by default\n    rate_limit=100,\n    rate_limit_window=60,\n    custom_error_responses={\n        429: \"Rate limit exceeded. Please try again later.\"\n    }\n)\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorial/ip-management/rate-limiter/#accessing-the-rate-limiter-directly","title":"Accessing the Rate Limiter Directly","text":"<p>For advanced use cases, you can access the rate limiter directly:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\n# Get the singleton instance\nasync def some_route():\n    # Get a reference to the handler\n    handler = rate_limit_handler(config)\n\n    # Reset rate limits (e.g., for a premium user)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#resetting-rate-limits","title":"Resetting Rate Limits","text":"<p>You might want to reset rate limits in certain scenarios:</p> <pre><code>from guard.handlers.ratelimit_handler import rate_limit_handler\n\nasync def reset_rate_limits_for_user(user_id: str):\n    handler = rate_limit_handler(config)\n\n    # Clear all rate limits (use with caution)\n    await handler.reset()\n</code></pre>"},{"location":"tutorial/ip-management/rate-limiter/#implementation-details","title":"Implementation Details","text":"<p>The <code>RateLimitManager</code> is implemented as a singleton to ensure consistent state across requests. It uses:</p> <ul> <li>TTLCache for in-memory storage with automatic expiration</li> <li>Redis increments with TTL for distributed storage</li> <li>Efficient counter storage to minimize memory footprint</li> </ul>"},{"location":"tutorial/ip-management/rate-limiter/#best-practices","title":"Best Practices","text":"<ol> <li>Set reasonable limits: Consider your API's typical usage patterns</li> <li>Use Redis in production: For reliability in distributed environments</li> <li>Implement graduated limits: Consider different limits for different API endpoints</li> <li>Inform clients: Return appropriate headers with rate limit information</li> <li>Monitor usage patterns: Keep an eye on rate limit hits to adjust as needed</li> </ol>"},{"location":"tutorial/ip-management/rate-limiter/#see-also","title":"See Also","text":"<ul> <li>RateLimitManager API Reference</li> <li>Redis Integration</li> <li>Security Middleware</li> </ul>"},{"location":"tutorial/redis-integration/caching/","title":"Redis Integration","text":"<p>FastAPI Guard uses Redis for distributed state management across multiple instances.</p>"},{"location":"tutorial/redis-integration/caching/#basic-configuration","title":"Basic Configuration","text":"<pre><code>config = SecurityConfig(\n    enable_redis=True,\n    redis_url=\"redis://prod-redis:6379/1\",\n    redis_prefix=\"myapp:security:\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-features","title":"Key Features","text":"<ol> <li>Distributed Rate Limiting</li> <li>Shared IP Ban List</li> <li>Cloud IP Range Caching</li> <li>Pattern Storage for Penetration Detection</li> </ol>"},{"location":"tutorial/redis-integration/caching/#fallback-behavior","title":"Fallback Behavior","text":"<p>When Redis is disabled (<code>enable_redis=False</code>): - Uses in-memory storage (TTLCache) - Rate limits are instance-local - IP bans only affect current instance - Cloud IP ranges refresh hourly</p>"},{"location":"tutorial/redis-integration/caching/#connection-management","title":"Connection Management","text":"<pre><code># Get RedisManager instance from middleware\nredis = request.app.state.security_middleware.redis_handler\n\n# Manual connection handling example\nasync with redis.get_connection() as conn:\n    await conn.set(\"key\", \"value\")\n\n# Automatic operation retry with proper arguments\nawait redis.safe_operation(\n    lambda conn: conn.get(\"my_key\"),\n    namespace=\"data\",\n    key=\"my_key\"\n)\n</code></pre>"},{"location":"tutorial/redis-integration/caching/#key-namespacing","title":"Key Namespacing","text":"<p>Keys are automatically prefixed using: <code>{redis_prefix}{namespace}:{key}</code></p> <p>Example: <code>fastapi_guard:cloud_ranges:AWS</code></p>"},{"location":"tutorial/redis-integration/caching/#best-practices","title":"Best Practices","text":"<ol> <li>Use separate Redis databases for different environments</li> <li>Set appropriate TTLs for transient data</li> <li>Monitor connection pool size in high-traffic deployments</li> <li>Use <code>safe_operation</code> for all Redis interactions</li> </ol>"},{"location":"tutorial/security/custom-patterns/","title":"Custom Patterns","text":"<p>FastAPI Guard allows you to add custom patterns for detecting suspicious activity.</p>"},{"location":"tutorial/security/custom-patterns/#adding-custom-patterns","title":"Adding Custom Patterns","text":"<p>Add your own patterns to the detection system:</p> <pre><code>from guard.handlers.suspatterns_handler import SusPatternsManager\n\nasync def setup_patterns():\n    # Add custom pattern\n    await SusPatternsManager.add_pattern(\n        r\"malicious_pattern.*\",\n        custom=True\n    )\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-types","title":"Pattern Types","text":"<p>You can add patterns for different types of attacks:</p> <pre><code># Custom XSS pattern\nawait SusPatternsManager.add_pattern(\n    r\"&lt;script\\s*src=.*&gt;\",\n    custom=True\n)\n\n# Custom SQL injection pattern\nawait SusPatternsManager.add_pattern(\n    r\";\\s*DROP\\s+TABLE\",\n    custom=True\n)\n\n# Custom file path pattern\nawait SusPatternsManager.add_pattern(\n    r\"\\.\\.\\/.*\\/etc\\/passwd\",\n    custom=True\n)\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#managing-patterns","title":"Managing Patterns","text":"<p>Remove or modify existing patterns:</p> <pre><code># Remove a custom pattern\nawait SusPatternsManager.remove_pattern(\n    r\"malicious_pattern.*\",\n    custom=True\n)\n\n# Get all patterns\npatterns = await SusPatternsManager.get_all_patterns()\n\n# Get compiled patterns\ncompiled_patterns = await SusPatternsManager.get_all_compiled_patterns()\n</code></pre>"},{"location":"tutorial/security/custom-patterns/#pattern-testing","title":"Pattern Testing","text":"<p>Test your patterns against requests:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/test/patterns\")\nasync def test_patterns(request: Request):\n    is_suspicious = await detect_penetration_attempt(request)\n    return {\n        \"suspicious\": is_suspicious,\n        \"request_body\": await request.body()\n    }\n</code></pre>"},{"location":"tutorial/security/penetration-detection/","title":"Penetration Detection","text":"<p>FastAPI Guard includes sophisticated penetration attempt detection to identify and block malicious requests.</p>"},{"location":"tutorial/security/penetration-detection/#basic-configuration","title":"Basic Configuration","text":"<p>Enable penetration detection:</p> <pre><code>config = SecurityConfig(\n    enable_penetration_detection=True,\n    auto_ban_threshold=5,  # Ban after 5 suspicious requests\n    auto_ban_duration=3600  # Ban duration in seconds\n)\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#detection-patterns","title":"Detection Patterns","text":"<p>The system checks for various attack patterns including:</p> <ul> <li>SQL Injection attempts</li> <li>XSS (Cross-Site Scripting)</li> <li>Command Injection</li> <li>Path Traversal</li> <li>Template Injection</li> <li>HTTP Response Splitting</li> <li>LDAP Injection</li> <li>XML Injection</li> <li>NoSQL Injection</li> <li>File Upload attacks</li> </ul>"},{"location":"tutorial/security/penetration-detection/#custom-detection-logic","title":"Custom Detection Logic","text":"<p>You can use the penetration detection directly in your routes:</p> <pre><code>from guard.utils import detect_penetration_attempt\n\n@app.post(\"/api/data\")\nasync def submit_data(request: Request):\n    if await detect_penetration_attempt(request):\n        return JSONResponse(\n            status_code=400,\n            content={\"error\": \"Suspicious activity detected\"}\n        )\n    # Process legitimate request\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"tutorial/security/penetration-detection/#logging-suspicious-activity","title":"Logging Suspicious Activity","text":"<p>Configure logging for suspicious activities:</p> <pre><code>config = SecurityConfig(\n    custom_log_file=\"security.log\",\n    log_level=\"WARNING\"\n)\n</code></pre> <p>Example log output: <pre><code>2024-01-20 10:15:23 - WARNING - Suspicious activity detected from 192.168.1.1: POST /api/data - Reason: SQL injection attempt\n</code></pre></p>"}]}